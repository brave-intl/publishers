# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sentry-raven` gem.
# Please instead update this file by running `bin/tapioca gem sentry-raven`.

module Rake
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::Rake::FileUtilsExt

  class << self
    def add_rakelib(*files); end
    def application; end
    def application=(app); end
    def each_dir_parent(dir); end
    def from_pathname(path); end
    def load_rakefile(path); end
    def original_dir; end
    def suggested_thread_count; end
    def with_application(block_application = T.unsafe(nil)); end
  end
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput

  def initialize; end

  def add_import(fn); end
  def add_loader(ext, loader); end
  def collect_command_line_tasks(args); end
  def default_task_name; end
  def deprecate(old_usage, new_usage, call_site); end
  def display_cause_details(ex); end
  def display_error_message(ex); end
  def display_exception_backtrace(ex); end
  def display_exception_details(ex); end
  def display_exception_details_seen; end
  def display_exception_message_details(ex); end
  def display_prerequisites; end
  def display_tasks_and_comments; end
  def dynamic_width; end
  def dynamic_width_stty; end
  def dynamic_width_tput; end
  def exit_because_of_exception(ex); end
  def find_rakefile_location; end
  def handle_options(argv); end
  def has_cause?(ex); end
  def have_rakefile; end
  def init(app_name = T.unsafe(nil), argv = T.unsafe(nil)); end
  def invoke_task(task_string); end
  def load_imports; end
  def load_rakefile; end
  def name; end
  def options; end
  def orig_display_error_messsage(ex); end
  def original_dir; end
  def parse_task_string(string); end
  def print_rakefile_directory(location); end
  def rake_require(file_name, paths = T.unsafe(nil), loaded = T.unsafe(nil)); end
  def rakefile; end
  def rakefile_location(backtrace = T.unsafe(nil)); end
  def raw_load_rakefile; end
  def run(argv = T.unsafe(nil)); end
  def run_with_threads; end
  def set_default_options; end
  def standard_exception_handling; end
  def standard_rake_options; end
  def system_dir; end
  def terminal_columns; end
  def terminal_columns=(_arg0); end
  def terminal_width; end
  def thread_pool; end
  def top_level; end
  def top_level_tasks; end
  def trace(*strings); end
  def truncate(string, width); end
  def truncate_output?; end
  def tty_output=(_arg0); end
  def tty_output?; end
  def unix?; end
  def windows?; end

  private

  def glob(path, &block); end
  def has_chain?(exception); end
  def select_tasks_to_show(options, show_tasks, value); end
  def select_trace_output(options, trace_option, value); end
  def sort_options(options); end
  def standard_system_dir; end
end

Rake::Application::DEFAULT_RAKEFILES = T.let(T.unsafe(nil), Array)
class Rake::CommandLineOptionError < ::StandardError; end
Rake::EARLY = T.let(T.unsafe(nil), Rake::EarlyTime)
Rake::EMPTY_TASK_ARGS = T.let(T.unsafe(nil), Rake::TaskArguments)
Rake::LATE = T.let(T.unsafe(nil), Rake::LateTime)
Rake::VERSION = T.let(T.unsafe(nil), String)

module Raven
  class << self
    def annotate(*args, &block); end
    def annotateException(*args, &block); end
    def annotate_exception(*args, &block); end
    def breadcrumbs(*args, &block); end
    def capture(*args, &block); end
    def captureException(*args, &block); end
    def captureMessage(*args, &block); end
    def capture_exception(*args, &block); end
    def capture_message(*args, &block); end
    def capture_type(*args, &block); end
    def client(*args, &block); end
    def client=(*args, &block); end
    def configuration(*args, &block); end
    def configuration=(*args, &block); end
    def configure(*args, &block); end
    def context(*args, &block); end
    def extra_context(*args, &block); end
    def inject; end
    def inject_only(*only_integrations); end
    def inject_without(*exclude_integrations); end
    def instance; end
    def last_event_id(*args, &block); end
    def load_integration(integration); end
    def logger(*args, &block); end
    def rack_context(*args, &block); end
    def report_ready(*args, &block); end
    def report_status(*args, &block); end
    def safely_prepend(module_name, opts = T.unsafe(nil)); end
    def send_event(*args, &block); end
    def sys_command(command); end
    def tags_context(*args, &block); end
    def user_context(*args, &block); end
  end
end

Raven::AVAILABLE_INTEGRATIONS = T.let(T.unsafe(nil), Array)

class Raven::Backtrace
  def initialize(lines); end

  def ==(other); end
  def inspect; end
  def lines; end
  def to_s; end

  private

  def lines=(_arg0); end

  class << self
    def parse(backtrace, opts = T.unsafe(nil)); end
  end
end

Raven::Backtrace::APP_DIRS_PATTERN = T.let(T.unsafe(nil), Regexp)

class Raven::Backtrace::Line
  def initialize(file, number, method, module_name); end

  def ==(other); end
  def file; end
  def in_app; end
  def inspect; end
  def method; end
  def module_name; end
  def number; end
  def to_s; end

  private

  def file=(_arg0); end
  def method=(_arg0); end
  def module_name=(_arg0); end
  def number=(_arg0); end

  class << self
    def in_app_pattern; end
    def parse(unparsed_line); end
  end
end

Raven::Backtrace::Line::JAVA_INPUT_FORMAT = T.let(T.unsafe(nil), Regexp)
Raven::Backtrace::Line::RB_EXTENSION = T.let(T.unsafe(nil), String)
Raven::Backtrace::Line::RUBY_INPUT_FORMAT = T.let(T.unsafe(nil), Regexp)

class Raven::Breadcrumb
  def initialize; end

  def category; end
  def category=(_arg0); end
  def data; end
  def data=(_arg0); end
  def level; end
  def level=(_arg0); end
  def message; end
  def message=(_arg0); end
  def timestamp; end
  def timestamp=(_arg0); end
  def to_hash; end
  def type; end
  def type=(_arg0); end
end

class Raven::BreadcrumbBuffer
  include ::Enumerable

  def initialize(size = T.unsafe(nil)); end

  def buffer; end
  def buffer=(_arg0); end
  def each(&block); end
  def empty?; end
  def members; end
  def peek; end
  def record(crumb = T.unsafe(nil)); end
  def to_hash; end

  class << self
    def clear!; end
    def current; end
  end
end

class Raven::CLI
  class << self
    def test(dsn = T.unsafe(nil), silent = T.unsafe(nil), config = T.unsafe(nil)); end
  end
end

class Raven::Client
  def initialize(configuration); end

  def configuration; end
  def configuration=(_arg0); end
  def send_event(event, hint = T.unsafe(nil)); end
  def transport; end

  private

  def encode(event); end
  def failed_send(e, event); end
  def generate_auth_header; end
  def get_log_message(event); end
  def successful_send; end
end

Raven::Client::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Raven::Client::PROTOCOL_VERSION = T.let(T.unsafe(nil), String)
Raven::Client::USER_AGENT = T.let(T.unsafe(nil), String)

class Raven::ClientState
  def initialize; end

  def failed?; end
  def failure(retry_after = T.unsafe(nil)); end
  def reset; end
  def should_try?; end
  def success; end
end

class Raven::Configuration
  def initialize; end

  def [](option); end
  def app_dirs_pattern; end
  def app_dirs_pattern=(_arg0); end
  def async; end
  def async=(value); end
  def async?; end
  def before_send; end
  def before_send=(value); end
  def capture_allowed?(message_or_exc = T.unsafe(nil)); end
  def context_lines; end
  def context_lines=(_arg0); end
  def current_environment; end
  def current_environment=(environment); end
  def dsn=(value); end
  def encoding; end
  def encoding=(encoding); end
  def environments; end
  def environments=(_arg0); end
  def error_messages; end
  def errors; end
  def exception_class_allowed?(exc); end
  def exclude_loggers; end
  def exclude_loggers=(_arg0); end
  def excluded_exceptions; end
  def excluded_exceptions=(_arg0); end
  def faraday_builder; end
  def faraday_builder=(_arg0); end
  def host; end
  def host=(_arg0); end
  def http_adapter; end
  def http_adapter=(_arg0); end
  def inspect_exception_causes_for_exclusion; end
  def inspect_exception_causes_for_exclusion=(_arg0); end
  def inspect_exception_causes_for_exclusion?; end
  def linecache; end
  def linecache=(_arg0); end
  def logger; end
  def logger=(_arg0); end
  def open_timeout; end
  def open_timeout=(_arg0); end
  def path; end
  def path=(_arg0); end
  def port; end
  def port=(_arg0); end
  def processors; end
  def processors=(_arg0); end
  def project_id; end
  def project_id=(_arg0); end
  def project_root; end
  def project_root=(root_dir); end
  def proxy; end
  def proxy=(_arg0); end
  def public_key; end
  def public_key=(_arg0); end
  def rails_activesupport_breadcrumbs; end
  def rails_activesupport_breadcrumbs=(_arg0); end
  def rails_report_rescued_exceptions; end
  def rails_report_rescued_exceptions=(_arg0); end
  def release; end
  def release=(_arg0); end
  def sample_rate; end
  def sample_rate=(_arg0); end
  def sanitize_credit_cards; end
  def sanitize_credit_cards=(_arg0); end
  def sanitize_fields; end
  def sanitize_fields=(_arg0); end
  def sanitize_fields_excluded; end
  def sanitize_fields_excluded=(_arg0); end
  def sanitize_http_headers; end
  def sanitize_http_headers=(_arg0); end
  def scheme; end
  def scheme=(_arg0); end
  def secret_key; end
  def secret_key=(_arg0); end
  def send_modules; end
  def send_modules=(_arg0); end
  def sending_allowed?(message_or_exc = T.unsafe(nil)); end
  def server; end
  def server=(value); end
  def server_name; end
  def server_name=(_arg0); end
  def should_capture; end
  def should_capture=(value); end
  def silence_ready; end
  def silence_ready=(_arg0); end
  def ssl; end
  def ssl=(_arg0); end
  def ssl_ca_file; end
  def ssl_ca_file=(_arg0); end
  def ssl_verification; end
  def ssl_verification=(_arg0); end
  def tags; end
  def tags=(_arg0); end
  def timeout; end
  def timeout=(_arg0); end
  def transport_failure_callback; end
  def transport_failure_callback=(value); end

  private

  def capture_allowed_by_callback?(message_or_exc); end
  def capture_in_current_environment?; end
  def current_environment_from_env; end
  def detect_project_root; end
  def detect_release; end
  def detect_release_from_capistrano; end
  def detect_release_from_env; end
  def detect_release_from_git; end
  def detect_release_from_heroku; end
  def excluded_exception?(incoming_exception); end
  def get_exception_class(x); end
  def matches_exception?(excluded_exception_class, incoming_exception); end
  def qualified_const_get(x); end
  def resolve_hostname; end
  def running_on_heroku?; end
  def sample_allowed?; end
  def server_name_from_env; end
  def valid?; end
end

Raven::Configuration::DEFAULT_PROCESSORS = T.let(T.unsafe(nil), Array)
Raven::Configuration::HEROKU_DYNO_METADATA_MESSAGE = T.let(T.unsafe(nil), String)
Raven::Configuration::IGNORE_DEFAULT = T.let(T.unsafe(nil), Array)
Raven::Configuration::LOG_PREFIX = T.let(T.unsafe(nil), String)
Raven::Configuration::MODULE_SEPARATOR = T.let(T.unsafe(nil), String)

class Raven::Context
  def initialize; end

  def extra; end
  def extra=(_arg0); end
  def rack_env; end
  def rack_env=(_arg0); end
  def runtime; end
  def runtime=(_arg0); end
  def server_os; end
  def server_os=(_arg0); end
  def tags; end
  def tags=(_arg0); end
  def transaction; end
  def transaction=(_arg0); end
  def user; end
  def user=(_arg0); end

  class << self
    def clear!; end
    def current; end
    def os_context; end
    def runtime_context; end
  end
end

class Raven::Error < ::StandardError; end

class Raven::Event
  def initialize(init = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def add_exception_interface(exc); end
  def backtrace; end
  def backtrace=(_arg0); end
  def breadcrumbs; end
  def breadcrumbs=(_arg0); end
  def checksum; end
  def checksum=(_arg0); end
  def configuration; end
  def configuration=(_arg0); end
  def context; end
  def context=(_arg0); end
  def environment; end
  def environment=(_arg0); end
  def event_id; end
  def extra; end
  def extra=(_arg0); end
  def fingerprint; end
  def fingerprint=(_arg0); end
  def id; end
  def id=(_arg0); end
  def interface(name, value = T.unsafe(nil), &block); end
  def level; end
  def level=(new_level); end
  def logger; end
  def logger=(_arg0); end
  def message; end
  def message=(args); end
  def modules; end
  def modules=(_arg0); end
  def platform; end
  def platform=(_arg0); end
  def release; end
  def release=(_arg0); end
  def runtime; end
  def runtime=(_arg0); end
  def sdk; end
  def sdk=(_arg0); end
  def server_name; end
  def server_name=(_arg0); end
  def server_os; end
  def server_os=(_arg0); end
  def stacktrace_interface_from(backtrace); end
  def tags; end
  def tags=(_arg0); end
  def time_spent; end
  def time_spent=(time); end
  def timestamp; end
  def timestamp=(time); end
  def to_hash; end
  def to_json_compatible; end
  def transaction; end
  def transaction=(_arg0); end
  def user; end
  def user=(_arg0); end

  private

  def add_rack_context; end
  def async_json_processors; end
  def calculate_real_ip_from_rack; end
  def copy_initial_state; end
  def list_gem_specs; end
  def set_core_attributes_from_configuration; end
  def set_core_attributes_from_context; end

  class << self
    def captureException(exc, options = T.unsafe(nil), &block); end
    def captureMessage(message, options = T.unsafe(nil)); end
    def capture_exception(exc, options = T.unsafe(nil), &block); end
    def capture_message(message, options = T.unsafe(nil)); end
    def from_exception(exc, options = T.unsafe(nil), &block); end
    def from_message(message, options = T.unsafe(nil)); end
  end
end

Raven::Event::MAX_MESSAGE_SIZE_IN_BYTES = T.let(T.unsafe(nil), Integer)
Raven::Event::SDK = T.let(T.unsafe(nil), Hash)

class Raven::ExceptionInterface < ::Raven::Interface
  def to_hash(*args); end
  def values; end
  def values=(_arg0); end

  class << self
    def sentry_alias; end
  end
end

class Raven::HttpInterface < ::Raven::Interface
  include ::Raven::RackInterface

  def initialize(*arguments); end

  def cookies; end
  def cookies=(_arg0); end
  def data; end
  def data=(_arg0); end
  def env; end
  def env=(_arg0); end
  def headers; end
  def headers=(_arg0); end
  def method; end
  def method=(_arg0); end
  def query_string; end
  def query_string=(_arg0); end
  def url; end
  def url=(_arg0); end

  class << self
    def sentry_alias; end
  end
end

class Raven::Instance
  def initialize(context = T.unsafe(nil), config = T.unsafe(nil)); end

  def annotate_exception(exc, options = T.unsafe(nil)); end
  def breadcrumbs; end
  def capture(options = T.unsafe(nil)); end
  def capture_exception(obj, options = T.unsafe(nil)); end
  def capture_message(obj, options = T.unsafe(nil)); end
  def capture_type(obj, options = T.unsafe(nil)); end
  def client; end
  def client=(_arg0); end
  def configuration; end
  def configuration=(_arg0); end
  def configure; end
  def context; end
  def extra_context(options = T.unsafe(nil)); end
  def last_event_id; end
  def logger; end
  def rack_context(env); end
  def report_status; end
  def send_event(event, hint = T.unsafe(nil)); end
  def tags_context(options = T.unsafe(nil)); end
  def user_context(options = T.unsafe(nil)); end

  private

  def install_at_exit_hook(options); end
  def make_hint(obj); end
end

class Raven::Interface
  def initialize(attributes = T.unsafe(nil)); end

  def to_hash; end

  class << self
    def inherited(klass); end
    def registered; end
  end
end

class Raven::LineCache
  def initialize; end

  def get_file_context(filename, lineno, context); end

  private

  def getline(path, n); end
  def getlines(path); end
  def valid_path?(path); end
end

class Raven::Logger < ::Logger
  def initialize(*_arg0); end
end

Raven::Logger::LOG_PREFIX = T.let(T.unsafe(nil), String)
Raven::Logger::PROGNAME = T.let(T.unsafe(nil), String)

class Raven::MessageInterface < ::Raven::Interface
  def initialize(*arguments); end

  def message; end
  def message=(_arg0); end
  def params; end
  def params=(_arg0); end
  def unformatted_message; end

  class << self
    def sentry_alias; end
  end
end

class Raven::Processor
  def initialize(client = T.unsafe(nil)); end

  def process(_data); end
end

class Raven::Processor::Cookies < ::Raven::Processor
  def process(data); end

  private

  def process_if_string_keys(data); end
  def process_if_symbol_keys(data); end
end

class Raven::Processor::HTTPHeaders < ::Raven::Processor
  def initialize(client); end

  def process(data); end
  def sanitize_http_headers; end
  def sanitize_http_headers=(_arg0); end

  private

  def fields_re; end
  def matches_regexes?(k); end
  def process_if_string_keys(data); end
  def process_if_symbol_keys(data); end
  def special_characters?(string); end
  def use_boundary?(string); end
end

Raven::Processor::HTTPHeaders::DEFAULT_FIELDS = T.let(T.unsafe(nil), Array)
Raven::Processor::INT_MASK = T.let(T.unsafe(nil), Integer)

class Raven::Processor::PostData < ::Raven::Processor
  def process(data); end

  private

  def process_if_string_keys(data); end
  def process_if_symbol_keys(data); end
end

Raven::Processor::REGEX_SPECIAL_CHARACTERS = T.let(T.unsafe(nil), Array)

class Raven::Processor::RemoveCircularReferences < ::Raven::Processor
  def process(value, visited = T.unsafe(nil)); end
end

Raven::Processor::STRING_MASK = T.let(T.unsafe(nil), String)

class Raven::Processor::SanitizeData < ::Raven::Processor
  def initialize(client); end

  def process(value, key = T.unsafe(nil)); end
  def sanitize_credit_cards; end
  def sanitize_credit_cards=(_arg0); end
  def sanitize_fields; end
  def sanitize_fields=(_arg0); end
  def sanitize_fields_excluded; end
  def sanitize_fields_excluded=(_arg0); end

  private

  def fields_re; end
  def matches_regexes?(k, v); end
  def parse_json_or_nil(string); end
  def sanitize_query_string(query_string); end
  def special_characters?(string); end
  def use_boundary?(string); end
  def utf8_processor; end
end

Raven::Processor::SanitizeData::CREDIT_CARD_RE = T.let(T.unsafe(nil), Regexp)
Raven::Processor::SanitizeData::DEFAULT_FIELDS = T.let(T.unsafe(nil), Array)
Raven::Processor::SanitizeData::JSON_STARTS_WITH = T.let(T.unsafe(nil), Array)
Raven::Processor::SanitizeData::QUERY_STRING = T.let(T.unsafe(nil), Array)

class Raven::Processor::UTF8Conversion < ::Raven::Processor
  def process(value); end

  private

  def remove_invalid_bytes(string); end
end

Raven::Processor::UTF8Conversion::REPLACE = T.let(T.unsafe(nil), String)

class Raven::Rack
  def initialize(app); end

  def call(env); end

  class << self
    def capture_exception(exception, env, options = T.unsafe(nil)); end
    def capture_message(exception, env, options = T.unsafe(nil)); end
    def capture_type(exception, env, options = T.unsafe(nil)); end
  end
end

module Raven::RackInterface
  def from_rack(env_hash); end

  private

  def format_env_for_sentry(env_hash); end
  def format_headers_for_sentry(env_hash); end
  def read_data_from(request); end
end

class Raven::Rails < ::Rails::Railtie; end

module Raven::Rails::ControllerMethods
  def capture_exception(exception, options = T.unsafe(nil)); end
  def capture_message(message, options = T.unsafe(nil)); end
end

module Raven::Rails::ControllerTransaction
  class << self
    def included(base); end
  end
end

module Raven::Rails::Overrides; end

module Raven::Rails::Overrides::OldStreamingReporter
  def log_error_with_raven(exception); end

  class << self
    def included(base); end
  end
end

module Raven::Rails::Overrides::StreamingReporter
  def log_error(exception); end
end

class Raven::SidekiqCleanupMiddleware
  def call(_worker, job, queue); end
end

class Raven::SidekiqErrorHandler
  def call(ex, context); end

  private

  def filter_context(context); end
  def filter_context_hash(key, value); end
  def format_globalid(context); end
  def transaction_from_context(context); end
end

Raven::SidekiqErrorHandler::ACTIVEJOB_RESERVED_PREFIX = T.let(T.unsafe(nil), String)
Raven::SidekiqErrorHandler::HAS_GLOBALID = T.let(T.unsafe(nil), TrueClass)

class Raven::SingleExceptionInterface < ::Raven::Interface
  def module; end
  def module=(_arg0); end
  def stacktrace; end
  def stacktrace=(_arg0); end
  def to_hash(*args); end
  def type; end
  def type=(_arg0); end
  def value; end
  def value=(_arg0); end
end

class Raven::StacktraceInterface < ::Raven::Interface
  def initialize(*arguments); end

  def frames; end
  def frames=(_arg0); end
  def to_hash(*args); end

  class << self
    def sentry_alias; end
  end
end

class Raven::StacktraceInterface::Frame < ::Raven::Interface
  def initialize(*arguments); end

  def abs_path; end
  def abs_path=(_arg0); end
  def context_line; end
  def context_line=(_arg0); end
  def filename; end
  def function; end
  def function=(_arg0); end
  def in_app; end
  def in_app=(_arg0); end
  def lineno; end
  def lineno=(_arg0); end
  def module; end
  def module=(_arg0); end
  def post_context; end
  def post_context=(_arg0); end
  def pre_context; end
  def pre_context=(_arg0); end
  def to_hash(*args); end
  def vars; end
  def vars=(_arg0); end

  private

  def longest_load_path; end
  def project_root; end
  def under_project_root?; end
end

module Raven::Transports; end

class Raven::Transports::HTTP < ::Raven::Transports::Transport
  def initialize(*args); end

  def adapter; end
  def adapter=(_arg0); end
  def conn; end
  def conn=(_arg0); end
  def send_event(auth_header, data, options = T.unsafe(nil)); end

  private

  def faraday_opts; end
  def set_conn; end
  def ssl_configuration; end
end

class Raven::Transports::Transport
  def initialize(configuration); end

  def configuration; end
  def configuration=(_arg0); end
  def send_event; end
end

module Raven::Utils; end

module Raven::Utils::DeepMergeHash
  class << self
    def deep_merge(hash, other_hash, &block); end
    def deep_merge!(hash, other_hash, &block); end
  end
end

module Raven::Utils::ExceptionCauseChain
  class << self
    def exception_to_array(exception); end
  end
end

class Raven::Utils::RealIp
  def initialize(ip_addresses); end

  def calculate_ip; end
  def ip; end
  def ip=(_arg0); end
  def ip_addresses; end
  def ip_addresses=(_arg0); end

  protected

  def filter_local_addresses(ips); end
  def ips_from(header); end
end

Raven::Utils::RealIp::LOCAL_ADDRESSES = T.let(T.unsafe(nil), Array)
Raven::VERSION = T.let(T.unsafe(nil), String)
