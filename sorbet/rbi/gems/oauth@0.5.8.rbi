# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `oauth` gem.
# Please instead update this file by running `bin/tapioca gem oauth`.

class Net::HTTPGenericRequest
  include ::Seahorse::Client::NetHttp::Patches::PatchDefaultContentType
  include ::Net::HTTPHeader
  include ::OAuth::Helper

  def oauth!(http, consumer = T.unsafe(nil), token = T.unsafe(nil), options = T.unsafe(nil)); end
  def oauth_helper; end
  def signature_base_string(http, consumer = T.unsafe(nil), token = T.unsafe(nil), options = T.unsafe(nil)); end

  private

  def oauth_body_hash_required?; end
  def oauth_full_request_uri(http, options); end
  def oauth_helper_options(http, consumer, token, options); end
  def set_oauth_body; end
  def set_oauth_header; end
  def set_oauth_query_string; end
end

module OAuth; end

class OAuth::AccessToken < ::OAuth::ConsumerToken
  def delete(path, headers = T.unsafe(nil)); end
  def get(path, headers = T.unsafe(nil)); end
  def head(path, headers = T.unsafe(nil)); end
  def patch(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end
  def post(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end
  def put(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end
  def request(http_method, path, *arguments); end
end

module OAuth::Client; end

class OAuth::Client::Helper
  include ::OAuth::Helper

  def initialize(request, options = T.unsafe(nil)); end

  def amend_user_agent_header(headers); end
  def hash_body; end
  def header; end
  def nonce; end
  def oauth_parameters; end
  def options; end
  def parameters; end
  def parameters_with_oauth; end
  def signature(extra_options = T.unsafe(nil)); end
  def signature_base_string(extra_options = T.unsafe(nil)); end
  def timestamp; end
  def token_request?; end
end

class OAuth::Consumer
  def initialize(consumer_key, consumer_secret, options = T.unsafe(nil)); end

  def access_token_path; end
  def access_token_url; end
  def access_token_url?; end
  def authenticate_path; end
  def authenticate_url; end
  def authenticate_url?; end
  def authorize_path; end
  def authorize_url; end
  def authorize_url?; end
  def create_signed_request(http_method, path, token = T.unsafe(nil), request_options = T.unsafe(nil), *arguments); end
  def debug_output; end
  def get_access_token(request_token, request_options = T.unsafe(nil), *arguments, &block); end
  def get_request_token(request_options = T.unsafe(nil), *arguments, &block); end
  def http; end
  def http=(_arg0); end
  def http_method; end
  def key; end
  def key=(_arg0); end
  def options; end
  def options=(_arg0); end
  def proxy; end
  def request(http_method, path, token = T.unsafe(nil), request_options = T.unsafe(nil), *arguments); end
  def request_endpoint; end
  def request_token_path; end
  def request_token_url; end
  def request_token_url?; end
  def scheme; end
  def secret; end
  def secret=(_arg0); end
  def sign!(request, token = T.unsafe(nil), request_options = T.unsafe(nil)); end
  def signature_base_string(request, token = T.unsafe(nil), request_options = T.unsafe(nil)); end
  def site; end
  def site=(_arg0); end
  def token_request(http_method, path, token = T.unsafe(nil), request_options = T.unsafe(nil), *arguments); end
  def uri(custom_uri = T.unsafe(nil)); end

  protected

  def create_http(_url = T.unsafe(nil)); end
  def create_http_request(http_method, path, *arguments); end
  def marshal_dump(*args); end
  def marshal_load(data); end
end

OAuth::Consumer::CA_FILES = T.let(T.unsafe(nil), Array)

class OAuth::ConsumerToken < ::OAuth::Token
  def initialize(consumer, token = T.unsafe(nil), secret = T.unsafe(nil)); end

  def consumer; end
  def consumer=(_arg0); end
  def params; end
  def params=(_arg0); end
  def request(http_method, path, *arguments); end
  def response; end
  def sign!(request, options = T.unsafe(nil)); end

  class << self
    def from_hash(consumer, hash); end
  end
end

class OAuth::Error < ::StandardError; end

module OAuth::Helper
  extend ::OAuth::Helper

  def _escape(string); end
  def escape(value); end
  def generate_key(size = T.unsafe(nil)); end
  def generate_nonce(size = T.unsafe(nil)); end
  def generate_timestamp; end
  def normalize(params); end
  def normalize_nested_query(value, prefix = T.unsafe(nil)); end
  def parse_header(header); end
  def stringify_keys(hash); end
  def unescape(value); end
end

OAuth::OUT_OF_BAND = T.let(T.unsafe(nil), String)
OAuth::PARAMETERS = T.let(T.unsafe(nil), Array)

class OAuth::Problem < ::OAuth::Unauthorized
  def initialize(problem, request = T.unsafe(nil), params = T.unsafe(nil)); end

  def params; end
  def problem; end
  def to_s; end
end

OAuth::RESERVED_CHARACTERS = T.let(T.unsafe(nil), Regexp)

module OAuth::RequestProxy
  class << self
    def available_proxies; end
    def proxy(request, options = T.unsafe(nil)); end
  end
end

class OAuth::RequestProxy::Base
  include ::OAuth::Helper

  def initialize(request, options = T.unsafe(nil)); end

  def consumer_key; end
  def non_oauth_parameters; end
  def nonce; end
  def normalized_parameters; end
  def normalized_uri; end
  def oauth_callback; end
  def oauth_consumer_key; end
  def oauth_header(options = T.unsafe(nil)); end
  def oauth_nonce; end
  def oauth_parameters; end
  def oauth_signature; end
  def oauth_signature_method; end
  def oauth_timestamp; end
  def oauth_token; end
  def oauth_verifier; end
  def oauth_version; end
  def options; end
  def options=(_arg0); end
  def parameters; end
  def parameters_for_signature; end
  def query_string_blank?; end
  def request; end
  def request=(_arg0); end
  def sign(options = T.unsafe(nil)); end
  def sign!(options = T.unsafe(nil)); end
  def signature; end
  def signature_and_unsigned_parameters; end
  def signature_base_string; end
  def signature_method; end
  def signed?; end
  def signed_uri(with_oauth = T.unsafe(nil)); end
  def timestamp; end
  def token; end
  def unsigned_parameters; end
  def unsigned_parameters=(_arg0); end

  protected

  def header_params; end

  class << self
    def proxies(klass); end
  end
end

class OAuth::RequestProxy::MockRequest < ::OAuth::RequestProxy::Base
  def method; end
  def normalized_uri; end
  def parameters; end
  def uri; end
end

module OAuth::RequestProxy::Net; end
module OAuth::RequestProxy::Net::HTTP; end

class OAuth::RequestProxy::Net::HTTP::HTTPRequest < ::OAuth::RequestProxy::Base
  def body; end
  def method; end
  def parameters; end
  def uri; end

  private

  def all_parameters; end
  def auth_header_params; end
  def form_url_encoded?; end
  def post_params; end
  def query_params; end
  def query_string; end
end

class OAuth::RequestProxy::UnknownRequestType < ::Exception; end

class OAuth::RequestToken < ::OAuth::ConsumerToken
  def authenticate_url(params = T.unsafe(nil)); end
  def authorize_url(params = T.unsafe(nil)); end
  def callback_confirmed?; end
  def get_access_token(options = T.unsafe(nil), *arguments); end

  protected

  def build_url(base_url, params); end
end

class OAuth::ServerToken < ::OAuth::Token
  def initialize; end
end

module OAuth::Signature
  class << self
    def available_methods; end
    def body_hash(request, options = T.unsafe(nil), &block); end
    def build(request, options = T.unsafe(nil), &block); end
    def sign(request, options = T.unsafe(nil), &block); end
    def signature_base_string(request, options = T.unsafe(nil), &block); end
    def verify(request, options = T.unsafe(nil), &block); end
  end
end

class OAuth::Signature::Base
  include ::OAuth::Helper

  def initialize(request, options = T.unsafe(nil), &block); end

  def ==(cmp_signature); end
  def body_hash; end
  def consumer_secret; end
  def options; end
  def options=(_arg0); end
  def request; end
  def signature; end
  def signature_base_string; end
  def token_secret; end
  def verify; end

  private

  def consumer_key; end
  def digest; end
  def nonce; end
  def raise_instantiation_error; end
  def secret; end
  def token; end

  class << self
    def implements(signature_method = T.unsafe(nil)); end
  end
end

module OAuth::Signature::HMAC; end

class OAuth::Signature::HMAC::SHA1 < ::OAuth::Signature::Base
  def body_hash; end

  private

  def digest; end
end

class OAuth::Signature::HMAC::SHA256 < ::OAuth::Signature::Base
  def body_hash; end

  private

  def digest; end
end

class OAuth::Signature::PLAINTEXT < ::OAuth::Signature::Base
  def ==(cmp_signature); end
  def body_hash; end
  def signature; end
  def signature_base_string; end

  private

  def secret; end
end

module OAuth::Signature::RSA; end

class OAuth::Signature::RSA::SHA1 < ::OAuth::Signature::Base
  def ==(cmp_signature); end
  def body_hash; end
  def public_key; end

  private

  def decode_public_key; end
  def digest; end
end

class OAuth::Signature::UnknownSignatureMethod < ::Exception; end

class OAuth::Token
  include ::OAuth::Helper

  def initialize(token, secret); end

  def secret; end
  def secret=(_arg0); end
  def to_query; end
  def token; end
  def token=(_arg0); end
end

class OAuth::Unauthorized < ::OAuth::Error
  def initialize(request = T.unsafe(nil)); end

  def request; end
  def to_s; end
end

OAuth::VERSION = T.let(T.unsafe(nil), String)
