# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq-scheduler` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq-scheduler`.

Sidekiq::Scheduler = SidekiqScheduler::Scheduler
module SidekiqScheduler; end

class SidekiqScheduler::Manager
  include ::Sidekiq::ExceptionHandler
  include ::Sidekiq::Util

  def initialize(options); end

  def reset; end
  def start; end
  def stop; end

  private

  def load_scheduler_options(options); end
end

SidekiqScheduler::Manager::DEFAULT_SCHEDULER_OPTIONS = T.let(T.unsafe(nil), Hash)

module SidekiqScheduler::RedisManager
  class << self
    def add_schedule_change(name); end
    def clean_schedules_changed; end
    def get_all_schedules; end
    def get_job_last_time(name); end
    def get_job_next_time(name); end
    def get_job_schedule(name); end
    def get_job_state(name); end
    def get_schedule_changes(from, to); end
    def hdel(hash_key, field_key); end
    def hget(hash_key, field_key); end
    def hset(hash_key, field_key, value); end
    def last_times_key; end
    def next_times_key; end
    def pushed_job_key(job_name); end
    def register_job_instance(job_name, time); end
    def remove_elder_job_instances(job_name); end
    def remove_job_next_time(name); end
    def remove_job_schedule(name); end
    def schedule_exist?; end
    def schedules_state_key; end
    def set_job_last_time(name, last_time); end
    def set_job_next_time(name, next_time); end
    def set_job_schedule(name, config); end
    def set_job_state(name, state); end
  end
end

SidekiqScheduler::RedisManager::REGISTERED_JOBS_THRESHOLD_IN_SECONDS = T.let(T.unsafe(nil), Integer)

class SidekiqScheduler::RufusUtils
  class << self
    def normalize_schedule_options(options); end
  end
end

module SidekiqScheduler::Schedule
  def get_all_schedules; end
  def get_schedule(name = T.unsafe(nil)); end
  def reload_schedule!; end
  def remove_schedule(name); end
  def schedule; end
  def schedule!; end
  def schedule=(schedule_hash); end
  def set_schedule(name, config); end

  private

  def infer_queue(klass); end
  def prepare_schedule(schedule_hash); end
  def try_to_constantize(klass); end
end

class SidekiqScheduler::Scheduler
  extend ::Sidekiq::ExceptionHandler
  extend ::Sidekiq::Util

  def initialize(options = T.unsafe(nil)); end

  def clear_schedule!(stop_option = T.unsafe(nil)); end
  def dynamic; end
  def dynamic=(_arg0); end
  def dynamic_every; end
  def dynamic_every=(_arg0); end
  def enabled; end
  def enabled=(_arg0); end
  def enqueue_job(job_config, time = T.unsafe(nil)); end
  def idempotent_job_enqueue(job_name, time, config); end
  def job_enabled?(name); end
  def listened_queues_only; end
  def listened_queues_only=(_arg0); end
  def load_schedule!; end
  def load_schedule_job(name, config); end
  def print_schedule; end
  def reload_schedule!; end
  def rufus_scheduler; end
  def rufus_scheduler_options; end
  def rufus_scheduler_options=(options); end
  def scheduled_jobs; end
  def toggle_job_enabled(name); end
  def update_schedule; end

  private

  def active_job_enqueue?(klass); end
  def arguments_with_metadata(args, metadata); end
  def enabled_queue?(job_queue, queues); end
  def handle_errors; end
  def new_job(name, interval_type, config, schedule, options); end
  def prepare_arguments(config); end
  def rails_env_matches?(config); end
  def schedule_state(name); end
  def set_schedule_state(name, state); end
  def sidekiq_queues; end
  def unschedule_job(name); end

  class << self
    def instance; end
    def instance=(value); end
    def method_missing(method, *arguments, &block); end
  end
end

module SidekiqScheduler::Utils
  class << self
    def enqueue_with_active_job(config); end
    def enqueue_with_sidekiq(config); end
    def initialize_active_job(klass, args); end
    def new_rufus_scheduler(options = T.unsafe(nil)); end
    def sanitize_job_config(config); end
    def stringify_keys(object); end
    def symbolize_keys(object); end
    def try_to_constantize(klass); end
    def update_job_last_time(name, last_time); end
    def update_job_next_time(name, next_time); end
  end
end

SidekiqScheduler::Utils::RUFUS_METADATA_KEYS = T.let(T.unsafe(nil), Array)
SidekiqScheduler::VERSION = T.let(T.unsafe(nil), String)
