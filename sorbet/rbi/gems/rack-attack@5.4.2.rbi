# typed: ignore

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-attack` gem.
# Please instead update this file by running `bin/tapioca gem rack-attack`.

module Rack
  class << self
    def release; end
    def version; end
  end
end

class Rack::Attack
  extend ::Forwardable

  def initialize(app); end

  def blocklisted?(*args, &block); end
  def call(env); end
  def safelisted?(*args, &block); end
  def throttled?(*args, &block); end
  def tracked?(*args, &block); end

  class << self
    def blacklist(name, &block); end
    def blacklisted?(request); end
    def blacklisted_response; end
    def blacklisted_response=(res); end
    def blacklists; end
    def blocklist(name, &block); end
    def blocklist_ip(ip_address); end
    def blocklisted?(request); end
    def blocklisted_response; end
    def blocklisted_response=(_arg0); end
    def blocklists; end
    def cache; end
    def clear!; end
    def clear_configuration; end
    def instrument(request); end
    def notifier; end
    def notifier=(_arg0); end
    def safelist(name, &block); end
    def safelist_ip(ip_address); end
    def safelisted?(request); end
    def safelists; end
    def throttle(name, options, &block); end
    def throttled?(request); end
    def throttled_response; end
    def throttled_response=(_arg0); end
    def throttles; end
    def track(name, options = T.unsafe(nil), &block); end
    def tracked?(request); end
    def tracks; end
    def whitelist(name, &block); end
    def whitelisted?(request); end
    def whitelists; end

    private

    def ip_blocklists; end
    def ip_safelists; end
  end
end

class Rack::Attack::Allow2Ban < ::Rack::Attack::Fail2Ban
  class << self
    protected

    def fail!(discriminator, bantime, findtime, maxretry); end
    def key_prefix; end
  end
end

class Rack::Attack::Blocklist < ::Rack::Attack::Check
  def initialize(name, block); end
end

class Rack::Attack::Cache
  def initialize; end

  def count(unprefixed_key, period); end
  def delete(unprefixed_key); end
  def last_epoch_time; end
  def prefix; end
  def prefix=(_arg0); end
  def read(unprefixed_key); end
  def reset_count(unprefixed_key, period); end
  def store; end
  def store=(store); end
  def write(unprefixed_key, value, expires_in); end

  private

  def do_count(key, expires_in); end
  def enforce_store_method_presence!(method_name); end
  def enforce_store_presence!; end
  def key_and_expiry(unprefixed_key, period); end
end

class Rack::Attack::Check
  def initialize(name, options = T.unsafe(nil), block); end

  def block; end
  def matched_by?(request); end
  def name; end
  def type; end
end

class Rack::Attack::Fail2Ban
  class << self
    def banned?(discriminator); end
    def filter(discriminator, options); end
    def reset(discriminator, options); end

    protected

    def fail!(discriminator, bantime, findtime, maxretry); end
    def key_prefix; end

    private

    def ban!(discriminator, bantime); end
    def cache; end
  end
end

module Rack::Attack::FallbackPathNormalizer
  class << self
    def normalize_path(path); end
  end
end

class Rack::Attack::MisconfiguredStoreError < ::StandardError; end
class Rack::Attack::MissingStoreError < ::StandardError; end
Rack::Attack::PathNormalizer = ActionDispatch::Journey::Router::Utils
class Rack::Attack::Request < ::Rack::Request; end

class Rack::Attack::Safelist < ::Rack::Attack::Check
  def initialize(name, block); end
end

module Rack::Attack::StoreProxy
  class << self
    def build(store); end
    def unwrap_active_support_stores(store); end
  end
end

class Rack::Attack::StoreProxy::DalliProxy < ::SimpleDelegator
  def initialize(client); end

  def delete(key); end
  def increment(key, amount, options = T.unsafe(nil)); end
  def read(key); end
  def write(key, value, options = T.unsafe(nil)); end

  private

  def stub_with_if_missing; end

  class << self
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::MemCacheProxy < ::SimpleDelegator
  def initialize(store); end

  def delete(key, _options = T.unsafe(nil)); end
  def increment(key, amount, _options = T.unsafe(nil)); end
  def read(key); end
  def write(key, value, options = T.unsafe(nil)); end

  private

  def stub_with_if_missing; end

  class << self
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::MemCacheStoreProxy < ::SimpleDelegator
  def write(name, value, options = T.unsafe(nil)); end

  class << self
    def handle?(store); end
  end
end

Rack::Attack::StoreProxy::PROXIES = T.let(T.unsafe(nil), Array)

class Rack::Attack::StoreProxy::RedisCacheStoreProxy < ::SimpleDelegator
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def read(name, options = T.unsafe(nil)); end
  def write(name, value, options = T.unsafe(nil)); end

  class << self
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::RedisProxy < ::SimpleDelegator
  def initialize(*args); end

  def delete(key, _options = T.unsafe(nil)); end
  def increment(key, amount, options = T.unsafe(nil)); end
  def read(key); end
  def write(key, value, options = T.unsafe(nil)); end

  class << self
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::RedisStoreProxy < ::Rack::Attack::StoreProxy::RedisProxy
  def read(key); end
  def write(key, value, options = T.unsafe(nil)); end

  class << self
    def handle?(store); end
  end
end

class Rack::Attack::Throttle
  def initialize(name, options, block); end

  def block; end
  def cache; end
  def limit; end
  def matched_by?(request); end
  def name; end
  def period; end
  def type; end
end

Rack::Attack::Throttle::MANDATORY_OPTIONS = T.let(T.unsafe(nil), Array)

class Rack::Attack::Track
  def initialize(name, options = T.unsafe(nil), block); end

  def filter; end
  def matched_by?(request); end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files
Rack::GET = T.let(T.unsafe(nil), String)
Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)
Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)
Rack::VERSION = T.let(T.unsafe(nil), Array)
