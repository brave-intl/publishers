# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `shale` gem.
# Please instead update this file by running `bin/tapioca gem shale`.

module Shale
  class << self
    def csv_adapter; end
    def csv_adapter=(_arg0); end
    def json_adapter; end
    def json_adapter=(_arg0); end
    def toml_adapter; end
    def toml_adapter=(_arg0); end
    def xml_adapter; end
    def xml_adapter=(_arg0); end
    def yaml_adapter; end
    def yaml_adapter=(_arg0); end
  end
end

module Shale::Adapter; end

class Shale::Adapter::CSV
  class << self
    def dump(obj, headers:, **options); end
    def load(csv, headers:, **options); end
  end
end

class Shale::Adapter::JSON
  class << self
    def dump(obj, pretty: T.unsafe(nil)); end
    def load(json); end
  end
end

class Shale::AdapterError < ::StandardError; end

class Shale::Attribute
  def initialize(name, type, collection, default); end

  def collection?; end
  def default; end
  def name; end
  def setter; end
  def type; end
end

class Shale::DefaultNotCallableError < ::StandardError
  def initialize(record, attribute); end
end

class Shale::IncorrectMappingArgumentsError < ::StandardError; end
class Shale::IncorrectModelError < ::StandardError; end

class Shale::Mapper < ::Shale::Type::Complex
  def initialize(**props); end

  class << self
    def attribute(name, type, collection: T.unsafe(nil), default: T.unsafe(nil)); end
    def attributes; end
    def csv(&block); end
    def csv_mapping; end
    def hash_mapping; end
    def hsh(&block); end
    def inherited(subclass); end
    def json(&block); end
    def json_mapping; end
    def model(klass = T.unsafe(nil)); end
    def toml(&block); end
    def toml_mapping; end
    def xml(&block); end
    def xml_mapping; end
    def yaml(&block); end
    def yaml_mapping; end
  end
end

module Shale::Mapping; end
module Shale::Mapping::Descriptor; end

class Shale::Mapping::Descriptor::Dict
  def initialize(name:, attribute:, methods:, group:, render_nil:); end

  def attribute; end
  def group; end
  def method_from; end
  def method_to; end
  def name; end
  def render_nil?; end
end

class Shale::Mapping::Descriptor::Xml < ::Shale::Mapping::Descriptor::Dict
  def initialize(name:, attribute:, methods:, group:, namespace:, cdata:, render_nil:); end

  def cdata; end
  def namespace; end
  def namespaced_name; end
  def prefixed_name; end
end

class Shale::Mapping::Descriptor::XmlNamespace
  def initialize(name = T.unsafe(nil), prefix = T.unsafe(nil)); end

  def name; end
  def name=(_arg0); end
  def prefix; end
  def prefix=(_arg0); end
end

class Shale::Mapping::Dict < ::Shale::Mapping::DictBase
  def group(from:, to:, &block); end
  def map(key, to: T.unsafe(nil), using: T.unsafe(nil), render_nil: T.unsafe(nil)); end
end

class Shale::Mapping::DictBase
  def initialize(render_nil_default: T.unsafe(nil)); end

  def finalize!; end
  def finalized?; end
  def keys; end
  def map(key, to: T.unsafe(nil), using: T.unsafe(nil), group: T.unsafe(nil), render_nil: T.unsafe(nil)); end

  private

  def initialize_dup(other); end
end

class Shale::Mapping::DictGroup < ::Shale::Mapping::DictBase
  def initialize(from, to); end

  def map(key); end
  def name; end
end

module Shale::Mapping::Group; end

class Shale::Mapping::Group::Dict
  def initialize(method_from, method_to); end

  def add(key, value); end
  def dict; end
  def method_from; end
  def method_to; end
end

class Shale::Mapping::Group::DictGrouping
  def initialize; end

  def add(mapping, value); end
  def each(&block); end
end

class Shale::Mapping::Group::Xml < ::Shale::Mapping::Group::Dict
  def initialize(method_from, method_to); end

  def add(kind, key, value); end
end

class Shale::Mapping::Group::XmlGrouping < ::Shale::Mapping::Group::DictGrouping
  def add(mapping, kind, value); end
end

module Shale::Mapping::Validator
  class << self
    def validate_arguments(key, to, using); end
    def validate_namespace(key, namespace, prefix); end
  end
end

class Shale::Mapping::Xml < ::Shale::Mapping::XmlBase
  def group(from:, to:, &block); end
  def map_attribute(attribute, to: T.unsafe(nil), using: T.unsafe(nil), namespace: T.unsafe(nil), prefix: T.unsafe(nil), render_nil: T.unsafe(nil)); end
  def map_content(to: T.unsafe(nil), using: T.unsafe(nil), cdata: T.unsafe(nil)); end
  def map_element(element, to: T.unsafe(nil), using: T.unsafe(nil), namespace: T.unsafe(nil), prefix: T.unsafe(nil), cdata: T.unsafe(nil), render_nil: T.unsafe(nil)); end
end

class Shale::Mapping::XmlBase
  def initialize; end

  def attributes; end
  def content; end
  def default_namespace; end
  def elements; end
  def finalize!; end
  def finalized?; end
  def map_attribute(attribute, to: T.unsafe(nil), using: T.unsafe(nil), group: T.unsafe(nil), namespace: T.unsafe(nil), prefix: T.unsafe(nil), render_nil: T.unsafe(nil)); end
  def map_content(to: T.unsafe(nil), using: T.unsafe(nil), group: T.unsafe(nil), cdata: T.unsafe(nil)); end
  def map_element(element, to: T.unsafe(nil), using: T.unsafe(nil), group: T.unsafe(nil), namespace: T.unsafe(nil), prefix: T.unsafe(nil), cdata: T.unsafe(nil), render_nil: T.unsafe(nil)); end
  def namespace(name, prefix); end
  def prefixed_root; end
  def root(value); end
  def unprefixed_root; end

  private

  def initialize_dup(other); end
end

class Shale::Mapping::XmlGroup < ::Shale::Mapping::XmlBase
  def initialize(from, to); end

  def map_attribute(attribute, namespace: T.unsafe(nil), prefix: T.unsafe(nil)); end
  def map_content; end
  def map_element(element, namespace: T.unsafe(nil), prefix: T.unsafe(nil)); end
  def name; end
end

class Shale::NotAShaleMapperError < ::StandardError; end
class Shale::ParseError < ::StandardError; end
class Shale::SchemaError < ::StandardError; end
Shale::TOML_ADAPTER_NOT_SET_MESSAGE = T.let(T.unsafe(nil), String)
module Shale::Type; end

class Shale::Type::Boolean < ::Shale::Type::Value
  class << self
    def cast(value); end
  end
end

Shale::Type::Boolean::FALSE_VALUES = T.let(T.unsafe(nil), Array)

class Shale::Type::Complex < ::Shale::Type::Value
  def to_csv(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), headers: T.unsafe(nil), **csv_options); end
  def to_hash(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
  def to_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), pretty: T.unsafe(nil)); end
  def to_toml(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
  def to_xml(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), pretty: T.unsafe(nil), declaration: T.unsafe(nil), encoding: T.unsafe(nil)); end
  def to_yaml(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  class << self
    def as_csv(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def as_hash(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def as_json(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def as_toml(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def as_xml(instance, node_name = T.unsafe(nil), doc = T.unsafe(nil), _cdata = T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), version: T.unsafe(nil)); end
    def as_yaml(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def from_csv(csv, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), headers: T.unsafe(nil), **csv_options); end
    def from_hash(hash, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def from_json(json, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def from_toml(toml, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def from_xml(xml, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def from_yaml(yaml, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def of_csv(hash, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def of_hash(hash, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def of_json(hash, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def of_toml(hash, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def of_xml(element, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def of_yaml(hash, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def to_csv(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), headers: T.unsafe(nil), **csv_options); end
    def to_hash(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def to_json(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), pretty: T.unsafe(nil)); end
    def to_toml(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end
    def to_xml(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil), pretty: T.unsafe(nil), declaration: T.unsafe(nil), encoding: T.unsafe(nil)); end
    def to_yaml(instance, only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

    private

    def to_partial_render_attributes(ary); end
    def validate_toml_adapter; end
    def validate_xml_adapter; end
  end
end

class Shale::Type::Date < ::Shale::Type::Value
  class << self
    def as_csv(value, **_arg1); end
    def as_json(value, **_arg1); end
    def as_xml_value(value); end
    def as_yaml(value, **_arg1); end
    def cast(value); end
  end
end

class Shale::Type::Float < ::Shale::Type::Value
  class << self
    def cast(value); end
  end
end

class Shale::Type::Integer < ::Shale::Type::Value
  class << self
    def cast(value); end
  end
end

class Shale::Type::String < ::Shale::Type::Value
  class << self
    def cast(value); end
  end
end

class Shale::Type::Time < ::Shale::Type::Value
  class << self
    def as_csv(value, **_arg1); end
    def as_json(value, **_arg1); end
    def as_xml_value(value); end
    def as_yaml(value, **_arg1); end
    def cast(value); end
  end
end

class Shale::Type::Value
  class << self
    def as_csv(value, **_arg1); end
    def as_hash(value, **_arg1); end
    def as_json(value, **_arg1); end
    def as_toml(value, **_arg1); end
    def as_xml(value, name, doc, cdata = T.unsafe(nil), **_arg4); end
    def as_xml_value(value); end
    def as_yaml(value, **_arg1); end
    def cast(value); end
    def of_csv(value, **_arg1); end
    def of_hash(value, **_arg1); end
    def of_json(value, **_arg1); end
    def of_toml(value, **_arg1); end
    def of_xml(node, **_arg1); end
    def of_yaml(value, **_arg1); end
  end
end

class Shale::UnknownAttributeError < ::NoMethodError
  def initialize(record, attribute); end
end

module Shale::Utils
  class << self
    def classify(str); end
    def presence(value); end
    def snake_case(str); end
    def underscore(str); end
  end
end

Shale::VERSION = T.let(T.unsafe(nil), String)
Shale::XML_ADAPTER_NOT_SET_MESSAGE = T.let(T.unsafe(nil), String)
