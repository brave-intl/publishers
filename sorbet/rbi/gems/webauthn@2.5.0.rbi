# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `webauthn` gem.
# Please instead update this file by running `bin/tapioca gem webauthn`.

class RSAPKCS1Algorithm < ::COSE::Algorithm::SignatureAlgorithm
  def initialize(*args, hash_function:); end

  def hash_function; end

  private

  def signature_algorithm_class; end
  def to_pkey(key); end
  def valid_key?(key); end
end

module WebAuthn
  class << self
    def configuration; end
    def configure; end
    def credential_creation_options(rp_name: T.unsafe(nil), user_name: T.unsafe(nil), display_name: T.unsafe(nil), user_id: T.unsafe(nil)); end
    def credential_request_options; end
    def generate_user_id; end
    def standard_encoder; end
  end
end

class WebAuthn::AttestationObject
  extend ::Forwardable

  def initialize(authenticator_data:, attestation_statement:); end

  def aaguid(*args, &block); end
  def attestation_certificate_key_id(*args, &block); end
  def attestation_statement; end
  def authenticator_data; end
  def credential(*args, &block); end
  def valid_attestation_statement?(client_data_hash); end
  def valid_attested_credential?; end

  class << self
    def deserialize(attestation_object); end
    def from_map(map); end
  end
end

module WebAuthn::AttestationStatement
  class << self
    def from(format, statement); end
  end
end

WebAuthn::AttestationStatement::ATTESTATION_FORMAT_ANDROID_KEY = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_FORMAT_ANDROID_SAFETYNET = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_FORMAT_APPLE = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_FORMAT_FIDO_U2F = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_FORMAT_NONE = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_FORMAT_PACKED = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_FORMAT_TPM = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_TYPES_WITH_ROOT = T.let(T.unsafe(nil), Array)
WebAuthn::AttestationStatement::ATTESTATION_TYPE_ANONCA = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_TYPE_ATTCA = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_TYPE_BASIC = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_TYPE_BASIC_OR_ATTCA = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_TYPE_NONE = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::ATTESTATION_TYPE_SELF = T.let(T.unsafe(nil), String)

class WebAuthn::AttestationStatement::AndroidKey < ::WebAuthn::AttestationStatement::Base
  def valid?(authenticator_data, client_data_hash); end

  private

  def all_applications_fields_not_set?; end
  def android_key_attestation; end
  def attestation_type; end
  def default_root_certificates; end
  def software_enforced; end
  def tee_enforced; end
  def valid_attestation_challenge?(client_data_hash); end
  def valid_authorization_list_origin?; end
  def valid_authorization_list_purpose?; end
  def valid_certificate_chain?(aaguid: T.unsafe(nil), **_); end
end

class WebAuthn::AttestationStatement::AndroidSafetynet < ::WebAuthn::AttestationStatement::Base
  def valid?(authenticator_data, client_data_hash); end

  private

  def attestation_response; end
  def attestation_type; end
  def certificates; end
  def cts_profile_match?; end
  def default_root_certificates; end
  def time; end
  def valid_certificate_chain?(**_); end
  def valid_response?(authenticator_data, client_data_hash); end
  def valid_version?; end
end

class WebAuthn::AttestationStatement::Apple < ::WebAuthn::AttestationStatement::Base
  def valid?(authenticator_data, client_data_hash); end

  private

  def attestation_type; end
  def cred_cert; end
  def default_root_certificates; end
  def valid_nonce?(authenticator_data, client_data_hash); end
end

WebAuthn::AttestationStatement::Apple::NONCE_EXTENSION_OID = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::Apple::ROOT_CERTIFICATE = T.let(T.unsafe(nil), OpenSSL::X509::Certificate)

class WebAuthn::AttestationStatement::Base
  def initialize(statement); end

  def attestation_certificate; end
  def attestation_certificate_key_id; end
  def format; end
  def valid?(_authenticator_data, _client_data_hash); end

  private

  def algorithm; end
  def attestation_root_certificates_store(aaguid: T.unsafe(nil), attestation_certificate_key_id: T.unsafe(nil)); end
  def attestation_trust_path; end
  def certificates; end
  def configuration; end
  def cose_algorithm; end
  def matching_aaguid?(attested_credential_data_aaguid); end
  def matching_public_key?(authenticator_data); end
  def raw_certificates; end
  def raw_subject_key_identifier; end
  def root_certificates(aaguid: T.unsafe(nil), attestation_certificate_key_id: T.unsafe(nil)); end
  def signature; end
  def statement; end
  def trustworthy?(aaguid: T.unsafe(nil), attestation_certificate_key_id: T.unsafe(nil)); end
  def valid_certificate_chain?(aaguid: T.unsafe(nil), attestation_certificate_key_id: T.unsafe(nil)); end
  def valid_signature?(authenticator_data, client_data_hash, public_key = T.unsafe(nil)); end
  def verification_data(authenticator_data, client_data_hash); end
end

WebAuthn::AttestationStatement::Base::AAGUID_EXTENSION_OID = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::FORMAT_TO_CLASS = T.let(T.unsafe(nil), Hash)

class WebAuthn::AttestationStatement::FidoU2f < ::WebAuthn::AttestationStatement::Base
  def valid?(authenticator_data, client_data_hash); end

  private

  def algorithm; end
  def attestation_type; end
  def certificate_public_key; end
  def public_key_u2f(cose_key_data); end
  def valid_aaguid?(attested_credential_data_aaguid); end
  def valid_certificate_public_key?; end
  def valid_credential_public_key?(public_key_bytes); end
  def valid_format?; end
  def verification_data(authenticator_data, client_data_hash); end
end

class WebAuthn::AttestationStatement::FidoU2f::PublicKey
  def initialize(data); end

  def to_uncompressed_point; end
  def valid?; end

  private

  def cose_key; end
  def data; end

  class << self
    def uncompressed_point?(data); end
  end
end

WebAuthn::AttestationStatement::FidoU2f::PublicKey::COORDINATE_LENGTH = T.let(T.unsafe(nil), Integer)
WebAuthn::AttestationStatement::FidoU2f::PublicKey::UNCOMPRESSED_FORM_INDICATOR = T.let(T.unsafe(nil), String)
WebAuthn::AttestationStatement::FidoU2f::VALID_ATTESTATION_CERTIFICATE_ALGORITHM = T.let(T.unsafe(nil), COSE::Algorithm::ECDSA)
WebAuthn::AttestationStatement::FidoU2f::VALID_ATTESTATION_CERTIFICATE_COUNT = T.let(T.unsafe(nil), Integer)
WebAuthn::AttestationStatement::FidoU2f::VALID_ATTESTATION_CERTIFICATE_KEY_CURVE = T.let(T.unsafe(nil), COSE::Key::Curve)
class WebAuthn::AttestationStatement::FormatNotSupportedError < ::WebAuthn::Error; end

class WebAuthn::AttestationStatement::None < ::WebAuthn::AttestationStatement::Base
  def valid?(*_args); end

  private

  def attestation_type; end
end

class WebAuthn::AttestationStatement::Packed < ::WebAuthn::AttestationStatement::Base
  def valid?(authenticator_data, client_data_hash); end

  private

  def attestation_type; end
  def meet_certificate_requirement?; end
  def self_attestation?; end
  def valid_algorithm?(credential); end
  def valid_ec_public_keys?(credential); end
  def valid_format?; end
  def valid_signature?(authenticator_data, client_data_hash); end
end

class WebAuthn::AttestationStatement::TPM < ::WebAuthn::AttestationStatement::Base
  def valid?(authenticator_data, client_data_hash); end

  private

  def attestation_type; end
  def cose_algorithm; end
  def default_root_certificates; end
  def tpm_algorithm; end
  def valid_certificate_chain?(**_); end
  def valid_key_attestation?(certified_extra_data, key, aaguid); end
  def ver; end
end

WebAuthn::AttestationStatement::TPM::COSE_ALG_TO_TPM = T.let(T.unsafe(nil), Hash)
WebAuthn::AttestationStatement::TPM::TPM_V2 = T.let(T.unsafe(nil), String)
class WebAuthn::AttestationStatement::UnsupportedAlgorithm < ::WebAuthn::Error; end
class WebAuthn::AttestationStatementVerificationError < ::WebAuthn::VerificationError; end
class WebAuthn::AttestationTrustworthinessVerificationError < ::WebAuthn::VerificationError; end
class WebAuthn::AttestedCredentialDataFormatError < ::WebAuthn::Error; end
class WebAuthn::AttestedCredentialVerificationError < ::WebAuthn::VerificationError; end

class WebAuthn::AuthenticatorAssertionResponse < ::WebAuthn::AuthenticatorResponse
  def initialize(authenticator_data:, signature:, user_handle: T.unsafe(nil), **options); end

  def authenticator_data; end
  def user_handle; end
  def verify(expected_challenge, expected_origin = T.unsafe(nil), public_key:, sign_count:, user_verification: T.unsafe(nil), rp_id: T.unsafe(nil)); end

  private

  def authenticator_data_bytes; end
  def signature; end
  def type; end
  def valid_sign_count?(stored_sign_count); end
  def valid_signature?(webauthn_public_key); end

  class << self
    def from_client(response); end
  end
end

class WebAuthn::AuthenticatorAttestationResponse < ::WebAuthn::AuthenticatorResponse
  extend ::Forwardable

  def initialize(attestation_object:, **options); end

  def aaguid(*args, &block); end
  def attestation_certificate_key(*args, &block); end
  def attestation_certificate_key_id(*args, &block); end
  def attestation_object; end
  def attestation_statement(*args, &block); end
  def attestation_trust_path; end
  def attestation_type; end
  def authenticator_data(*args, &block); end
  def credential(*args, &block); end
  def verify(expected_challenge, expected_origin = T.unsafe(nil), user_verification: T.unsafe(nil), rp_id: T.unsafe(nil)); end

  private

  def attestation_object_bytes; end
  def type; end
  def valid_attestation_statement?; end
  def valid_attested_credential?; end

  class << self
    def from_client(response); end
  end
end

class WebAuthn::AuthenticatorData < ::BinData::Record
  def aaguid; end
  def attested_credential_data; end
  def attested_credential_data_included?; end
  def credential; end
  def data; end
  def extension_data; end
  def extension_data_included?; end
  def user_flagged?; end
  def user_present?; end
  def user_verified?; end
  def valid?; end

  private

  def attested_credential_data_length; end
  def base_length; end
  def extension_data_length; end
  def raw_extension_data; end
  def valid_length?; end

  class << self
    def deserialize(data); end
  end
end

class WebAuthn::AuthenticatorData::AttestedCredentialData < ::BinData::Record
  def aaguid; end
  def credential; end
  def length; end
  def valid?; end

  private

  def public_key; end
  def public_key_length; end
  def valid_credential_public_key?; end

  class << self
    def deserialize(data); end
  end
end

WebAuthn::AuthenticatorData::AttestedCredentialData::AAGUID_LENGTH = T.let(T.unsafe(nil), Integer)

class WebAuthn::AuthenticatorData::AttestedCredentialData::Credential < ::Struct
  def id; end
  def id=(_); end
  def public_key; end
  def public_key=(_); end
  def public_key_object; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

WebAuthn::AuthenticatorData::AttestedCredentialData::ID_LENGTH_LENGTH = T.let(T.unsafe(nil), Integer)
WebAuthn::AuthenticatorData::AttestedCredentialData::ZEROED_AAGUID = T.let(T.unsafe(nil), String)
WebAuthn::AuthenticatorData::FLAGS_LENGTH = T.let(T.unsafe(nil), Integer)
WebAuthn::AuthenticatorData::RP_ID_HASH_LENGTH = T.let(T.unsafe(nil), Integer)
WebAuthn::AuthenticatorData::SIGN_COUNT_LENGTH = T.let(T.unsafe(nil), Integer)
class WebAuthn::AuthenticatorDataFormatError < ::WebAuthn::Error; end
class WebAuthn::AuthenticatorDataVerificationError < ::WebAuthn::VerificationError; end

class WebAuthn::AuthenticatorResponse
  def initialize(client_data_json:); end

  def client_data; end
  def valid?(*args, **keyword_arguments); end
  def verify(expected_challenge, expected_origin = T.unsafe(nil), user_verification: T.unsafe(nil), rp_id: T.unsafe(nil)); end

  private

  def client_data_json; end
  def rp_id_from_origin(expected_origin); end
  def type; end
  def valid_authenticator_data?; end
  def valid_challenge?(expected_challenge); end
  def valid_origin?(expected_origin); end
  def valid_rp_id?(rp_id); end
  def valid_token_binding?; end
  def valid_type?; end
  def valid_user_presence?; end
  def valid_user_verified?; end
  def verify_item(item, *args); end
end

class WebAuthn::ChallengeVerificationError < ::WebAuthn::VerificationError; end

class WebAuthn::ClientData
  def initialize(client_data_json); end

  def challenge; end
  def hash; end
  def origin; end
  def token_binding; end
  def type; end
  def valid_token_binding_format?; end

  private

  def client_data_json; end
  def data; end
end

WebAuthn::ClientData::VALID_TOKEN_BINDING_STATUSES = T.let(T.unsafe(nil), Array)
class WebAuthn::ClientDataMissingError < ::WebAuthn::Error; end

class WebAuthn::Configuration
  def initialize; end

  def acceptable_attestation_types; end
  def acceptable_attestation_types=(_arg0); end
  def algorithms; end
  def algorithms=(_arg0); end
  def attestation_root_certificates_finders; end
  def attestation_root_certificates_finders=(finders); end
  def credential_options_timeout; end
  def credential_options_timeout=(_arg0); end
  def encoder; end
  def encoding; end
  def encoding=(_arg0); end
  def origin; end
  def origin=(_arg0); end
  def rp_id; end
  def rp_id=(_arg0); end
  def rp_name; end
  def rp_name=(_arg0); end
  def silent_authentication; end
  def silent_authentication=(_arg0); end
  def verify_attestation_statement; end
  def verify_attestation_statement=(_arg0); end
end

WebAuthn::Configuration::DEFAULT_ALGORITHMS = T.let(T.unsafe(nil), Array)

module WebAuthn::Credential
  class << self
    def from_create(credential); end
    def from_get(credential); end
    def options_for_create(**keyword_arguments); end
    def options_for_get(**keyword_arguments); end
  end
end

class WebAuthn::CredentialCreationOptions < ::WebAuthn::CredentialOptions
  def initialize(user_id:, user_name:, attestation: T.unsafe(nil), authenticator_selection: T.unsafe(nil), exclude_credentials: T.unsafe(nil), extensions: T.unsafe(nil), user_display_name: T.unsafe(nil), rp_name: T.unsafe(nil)); end

  def attestation; end
  def attestation=(_arg0); end
  def authenticator_selection; end
  def authenticator_selection=(_arg0); end
  def exclude_credentials; end
  def exclude_credentials=(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def pub_key_cred_params; end
  def rp; end
  def to_h; end
  def user; end

  private

  def configuration; end
  def rp_name; end
  def user_display_name; end
  def user_id; end
  def user_name; end
end

WebAuthn::CredentialCreationOptions::DEFAULT_RP_NAME = T.let(T.unsafe(nil), String)

class WebAuthn::CredentialEntity
  def initialize(name:); end

  def name; end
end

class WebAuthn::CredentialOptions
  def challenge; end
  def timeout; end
end

WebAuthn::CredentialOptions::CHALLENGE_LENGTH = T.let(T.unsafe(nil), Integer)
class WebAuthn::CredentialRPEntity < ::WebAuthn::CredentialEntity; end

class WebAuthn::CredentialRequestOptions < ::WebAuthn::CredentialOptions
  def initialize(allow_credentials: T.unsafe(nil), extensions: T.unsafe(nil), user_verification: T.unsafe(nil)); end

  def allow_credentials; end
  def allow_credentials=(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def to_h; end
  def user_verification; end
  def user_verification=(_arg0); end
end

class WebAuthn::CredentialUserEntity < ::WebAuthn::CredentialEntity
  def initialize(id:, display_name: T.unsafe(nil), **keyword_arguments); end

  def display_name; end
  def id; end
end

class WebAuthn::Encoder
  def initialize(encoding = T.unsafe(nil)); end

  def decode(data); end
  def encode(data); end
  def encoding; end
end

WebAuthn::Encoder::STANDARD_ENCODING = T.let(T.unsafe(nil), Symbol)
class WebAuthn::Error < ::StandardError; end
class WebAuthn::OriginVerificationError < ::WebAuthn::VerificationError; end

class WebAuthn::PublicKey
  def initialize(cose_key:); end

  def alg; end
  def cose_key; end
  def pkey; end
  def verify(signature, verification_data); end

  private

  def cose_algorithm; end

  class << self
    def deserialize(public_key); end
  end
end

class WebAuthn::PublicKey::UnsupportedAlgorithm < ::WebAuthn::Error; end

class WebAuthn::PublicKeyCredential
  def initialize(type:, id:, raw_id:, response:, client_extension_outputs: T.unsafe(nil)); end

  def authenticator_extension_outputs; end
  def client_extension_outputs; end
  def id; end
  def raw_id; end
  def response; end
  def sign_count; end
  def type; end
  def verify(*_args); end

  private

  def authenticator_data; end
  def encoder; end
  def valid_id?; end
  def valid_type?; end

  class << self
    def from_client(credential); end
  end
end

class WebAuthn::PublicKeyCredential::CreationOptions < ::WebAuthn::PublicKeyCredential::Options
  def initialize(user:, attestation: T.unsafe(nil), authenticator_selection: T.unsafe(nil), exclude_credentials: T.unsafe(nil), exclude: T.unsafe(nil), pub_key_cred_params: T.unsafe(nil), algs: T.unsafe(nil), rp: T.unsafe(nil), **keyword_arguments); end

  def algs; end
  def algs=(_arg0); end
  def attestation; end
  def attestation=(_arg0); end
  def authenticator_selection; end
  def authenticator_selection=(_arg0); end
  def exclude; end
  def exclude=(_arg0); end
  def exclude_credentials; end
  def pub_key_cred_params; end
  def rp; end
  def rp=(_arg0); end
  def user; end
  def user=(_arg0); end

  private

  def attributes; end
  def exclude_credentials_from_exclude; end
  def pub_key_cred_params_from_algs; end
end

class WebAuthn::PublicKeyCredential::Entity
  def initialize(name:); end

  def as_json; end
  def name; end

  private

  def attributes; end
  def to_hash; end
end

class WebAuthn::PublicKeyCredential::Options
  def initialize(timeout: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def as_json(*_arg0); end
  def challenge; end
  def extensions; end
  def timeout; end

  private

  def as_public_key_descriptors(ids); end
  def attributes; end
  def configuration; end
  def default_timeout; end
  def encoder; end
  def raw_challenge; end
  def to_hash; end
end

WebAuthn::PublicKeyCredential::Options::CHALLENGE_LENGTH = T.let(T.unsafe(nil), Integer)

class WebAuthn::PublicKeyCredential::RPEntity < ::WebAuthn::PublicKeyCredential::Entity
  def initialize(id: T.unsafe(nil), **keyword_arguments); end

  def id; end

  private

  def attributes; end
end

class WebAuthn::PublicKeyCredential::RequestOptions < ::WebAuthn::PublicKeyCredential::Options
  def initialize(rp_id: T.unsafe(nil), allow_credentials: T.unsafe(nil), allow: T.unsafe(nil), user_verification: T.unsafe(nil), **keyword_arguments); end

  def allow; end
  def allow=(_arg0); end
  def allow_credentials; end
  def rp_id; end
  def rp_id=(_arg0); end
  def user_verification; end
  def user_verification=(_arg0); end

  private

  def allow_credentials_from_allow; end
  def attributes; end
end

class WebAuthn::PublicKeyCredential::UserEntity < ::WebAuthn::PublicKeyCredential::Entity
  def initialize(id:, display_name: T.unsafe(nil), **keyword_arguments); end

  def display_name; end
  def id; end

  private

  def attributes; end
end

class WebAuthn::PublicKeyCredentialWithAssertion < ::WebAuthn::PublicKeyCredential
  def raw_user_handle; end
  def user_handle; end
  def verify(challenge, public_key:, sign_count:, user_verification: T.unsafe(nil)); end

  class << self
    def response_class; end
  end
end

class WebAuthn::PublicKeyCredentialWithAttestation < ::WebAuthn::PublicKeyCredential
  def public_key; end
  def raw_public_key; end
  def verify(challenge, user_verification: T.unsafe(nil)); end

  class << self
    def response_class; end
  end
end

class WebAuthn::RootCertificateFinderNotSupportedError < ::WebAuthn::Error; end
class WebAuthn::RpIdVerificationError < ::WebAuthn::VerificationError; end

module WebAuthn::SecurityUtils
  private

  def secure_compare(first_string, second_string); end

  class << self
    def secure_compare(first_string, second_string); end
  end
end

class WebAuthn::SignCountVerificationError < ::WebAuthn::VerificationError; end
class WebAuthn::SignatureVerificationError < ::WebAuthn::VerificationError; end
WebAuthn::TYPES = T.let(T.unsafe(nil), Hash)
WebAuthn::TYPE_PUBLIC_KEY = T.let(T.unsafe(nil), String)
class WebAuthn::TokenBindingVerificationError < ::WebAuthn::VerificationError; end
class WebAuthn::TypeVerificationError < ::WebAuthn::VerificationError; end
class WebAuthn::UserPresenceVerificationError < ::WebAuthn::VerificationError; end
class WebAuthn::UserVerifiedVerificationError < ::WebAuthn::VerificationError; end
WebAuthn::VERSION = T.let(T.unsafe(nil), String)
class WebAuthn::VerificationError < ::WebAuthn::Error; end
