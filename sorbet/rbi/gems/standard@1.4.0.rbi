# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `standard` gem.
# Please instead update this file by running `bin/tapioca gem standard`.

module RuboCop; end
module RuboCop::Cop; end

class RuboCop::Cop::Lint::AssignmentInCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment

  def message(_); end
  def on_if(node); end
  def on_until(node); end
  def on_while(node); end

  private

  def allowed_construct?(asgn_node); end
  def conditional_assignment?(asgn_node); end
  def skip_children?(asgn_node); end
  def traverse_node(node, &block); end
end

RuboCop::Cop::Lint::AssignmentInCondition::ASGN_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)
module RuboCop::Cop::Standard; end

class RuboCop::Cop::Standard::BlockSingleLineBraces < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def correction_would_break_code?(node); end
  def get_blocks(node, &block); end
  def message(node); end
  def proper_block_style?(node); end
  def replace_do_end_with_braces(corrector, loc); end
  def whitespace_after?(range, length = T.unsafe(nil)); end
end

class RuboCop::DirectiveComment
  def initialize(comment, cop_registry = T.unsafe(nil)); end

  def all_cops?; end
  def comment; end
  def cop_names; end
  def cop_registry; end
  def cops; end
  def department_names; end
  def directive_count; end
  def disabled?; end
  def disabled_all?; end
  def enabled?; end
  def enabled_all?; end
  def in_directive_department?(cop); end
  def line_number; end
  def match?(cop_names); end
  def match_captures; end
  def mode; end
  def overridden_by_department?(cop); end
  def range; end
  def single_line?; end

  private

  def all_cop_names; end
  def cop_names_for_department(department); end
  def department?(name); end
  def exclude_redundant_directive_cop(cops); end
  def parsed_cop_names; end
  def splitted_cops_string; end

  class << self
    def before_comment(line); end
  end
end

RuboCop::DirectiveComment::COPS_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::COP_NAMES_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::COP_NAME_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::DIRECTIVE_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP_DEPARTMENT = T.let(T.unsafe(nil), String)
RuboCop::NodePattern = RuboCop::AST::NodePattern
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource
RuboCop::Token = RuboCop::AST::Token
module Standard; end

class Standard::BuildsConfig
  def initialize; end

  def call(argv, search_path = T.unsafe(nil)); end

  private

  def determine_yaml_file(argv, search_path, option_name, default_file); end
end

class Standard::Cli
  def initialize(argv); end

  def run; end
end

class Standard::Config < ::Struct
  def paths; end
  def paths=(_); end
  def rubocop_config_store; end
  def rubocop_config_store=(_); end
  def rubocop_options; end
  def rubocop_options=(_); end
  def runner; end
  def runner=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Standard::CreatesConfigStore
  def initialize; end

  def call(standard_config); end
end

class Standard::CreatesConfigStore::AssignsRubocopYaml
  def call(config_store, standard_config); end

  private

  def rubocop_yaml_path(desired_version); end
end

class Standard::CreatesConfigStore::ConfiguresIgnoredPaths
  def call(options_config, standard_config); end

  private

  def absolute?(path); end
  def absolutify(config_root, path); end
  def ignored_patterns(standard_config); end
end

Standard::CreatesConfigStore::ConfiguresIgnoredPaths::DEFAULT_IGNORES = T.let(T.unsafe(nil), Array)

class Standard::CreatesConfigStore::SetsTargetRubyVersion
  def call(options_config, standard_config); end

  private

  def max_rubocop_supported_version(desired_version); end
  def normalize_version(version); end
end

class Standard::DetectsFixability
  def call(offenses); end

  private

  def cop_instance(cop_name); end
end

class Standard::FileFinder
  def call(name, search_path); end
end

class Standard::Formatter < ::RuboCop::Formatter::BaseFormatter
  def initialize(*args); end

  def file_finished(file, offenses); end
  def finished(inspected_files); end
  def started(_target_files); end

  private

  def auto_correct_option_provided?; end
  def path_to(file); end
  def print_fix_suggestion_once(offenses); end
  def print_header_once; end
  def print_todo_congratulations; end
  def print_todo_warning; end
  def should_suggest_fix?(offenses); end

  class << self
    def fixable_error_message(command); end
  end
end

Standard::Formatter::STANDARD_GREETING = T.let(T.unsafe(nil), String)

class Standard::LoadsRunner
  def call(command); end
end

class Standard::LoadsYamlConfig
  def call(standard_yaml_path, todo_yaml_path); end

  private

  def arrayify(object); end
  def construct_config(yaml_path, standard_yaml, todo_path, todo_yaml); end
  def expand_ignore_config(ignore_config); end
  def load_standard_yaml(yaml_path); end
  def normalized_ruby_version(version); end
end

class Standard::MergesSettings
  def call(argv, standard_yaml); end

  private

  def determine_command(argv); end
  def merge(standard_yaml, standard_cli_flags, rubocop_cli_flags); end
  def parse_standard_argv(argv); end
  def separate_argv(argv); end
  def without_banned(rubocop_cli_flags); end
end

class Standard::MergesSettings::Settings < ::Struct
  def options; end
  def options=(_); end
  def paths; end
  def paths=(_); end
  def runner; end
  def runner=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Standard::ParsesCliOption
  def argv_value_for(argv, option_name); end
  def call(argv, option_name); end
end

class Standard::Railtie < ::Rails::Railtie; end
Standard::VERSION = T.let(T.unsafe(nil), Gem::Version)
