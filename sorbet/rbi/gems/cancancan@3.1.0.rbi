# typed: strict

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cancancan` gem.
# Please instead update this file by running `bin/tapioca gem cancancan`.

module CanCan; end

module CanCan::Ability
  include ::CanCan::Ability::Rules
  include ::CanCan::Ability::Actions
  include ::CanCan::UnauthorizedMessageResolver
  include ::CanCan::Ability::StrongParameterSupport

  def attributes_for(action, subject); end
  def authorize!(action, subject, *args); end
  def can(action = T.unsafe(nil), subject = T.unsafe(nil), *attributes_and_conditions, &block); end
  def can?(action, subject, attribute = T.unsafe(nil), *extra_args); end
  def cannot(action = T.unsafe(nil), subject = T.unsafe(nil), *attributes_and_conditions, &block); end
  def cannot?(*args); end
  def extract_rule_in_permissions(permissions_list, rule); end
  def has_block?(action, subject); end
  def has_raw_sql?(action, subject); end
  def merge(ability); end
  def model_adapter(model_class, action); end
  def permissions; end
  def validate_target(target); end

  private

  def alternative_subjects(subject); end
  def extract_subjects(subject); end
  def unauthorized_message_keys(action, subject); end
end

module CanCan::Ability::Actions
  def alias_action(*args); end
  def aliased_actions; end
  def clear_aliased_actions; end

  private

  def aliases_for_action(action); end
  def default_alias_actions; end
  def expand_actions(actions); end
  def expanded_actions; end
end

module CanCan::Ability::Rules
  protected

  def rules; end

  private

  def add_rule(rule); end
  def add_rule_to_index(rule, position); end
  def optimize_order!(rules); end
  def possible_relevant_rules(subject); end
  def relevant_rules(action, subject); end
  def relevant_rules_for_match(action, subject); end
  def relevant_rules_for_query(action, subject); end
end

module CanCan::Ability::StrongParameterSupport
  def permitted_attributes(action, subject); end

  private

  def get_attributes(rule, subject); end
  def subject_class?(subject); end
end

class CanCan::AccessDenied < ::CanCan::Error
  def initialize(message = T.unsafe(nil), action = T.unsafe(nil), subject = T.unsafe(nil), conditions = T.unsafe(nil)); end

  def action; end
  def conditions; end
  def default_message=(_arg0); end
  def subject; end
  def to_s; end
end

class CanCan::AttributeArgumentError < ::CanCan::Error; end
class CanCan::AuthorizationNotPerformed < ::CanCan::Error; end
class CanCan::BlockAndConditionsError < ::CanCan::Error; end

module CanCan::ConditionsMatcher
  def matches_conditions?(action, subject, attribute = T.unsafe(nil), *extra_args); end

  private

  def call_block_with_all(action, subject, *extra_args); end
  def condition_match?(attribute, value); end
  def conditions_empty?; end
  def hash_condition_match?(attribute, value); end
  def matches_all_conditions?(adapter, conditions, subject); end
  def matches_block_conditions(subject, *extra_args); end
  def matches_conditions_hash?(subject, conditions = T.unsafe(nil)); end
  def matches_non_block_conditions(subject); end
  def model_adapter(subject); end
  def nested_subject_matches_conditions?(subject_hash); end
  def subject_class?(subject); end
end

module CanCan::ControllerAdditions
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CanCan::ControllerAdditions::ClassMethods

  def authorize!(*args); end
  def can?(*args); end
  def cannot?(*args); end
  def current_ability; end

  module GeneratedClassMethods
    def _cancan_skipper; end
    def _cancan_skipper=(value); end
    def _cancan_skipper?; end
  end

  module GeneratedInstanceMethods
    def _cancan_skipper; end
    def _cancan_skipper=(value); end
    def _cancan_skipper?; end
  end

  class << self
    def included(base); end
  end
end

module CanCan::ControllerAdditions::ClassMethods
  def authorize_resource(*args); end
  def cancan_resource_class; end
  def cancan_skipper; end
  def check_authorization(options = T.unsafe(nil)); end
  def load_and_authorize_resource(*args); end
  def load_resource(*args); end
  def skip_authorization_check(*args); end
  def skip_authorize_resource(*args); end
  def skip_load_and_authorize_resource(*args); end
  def skip_load_resource(*args); end
end

class CanCan::ControllerResource
  include ::CanCan::ControllerResourceNameFinder
  include ::CanCan::ControllerResourceFinder
  include ::CanCan::ControllerResourceBuilder
  include ::CanCan::ControllerResourceSanitizer
  include ::CanCan::ControllerResourceLoader

  def initialize(controller, *args); end

  def authorize_resource; end
  def load_and_authorize_resource; end
  def parent?; end
  def skip?(behavior); end

  protected

  def collection_actions; end
  def collection_instance; end
  def collection_instance=(instance); end
  def instance_name; end
  def load_collection?; end
  def load_instance?; end
  def member_action?; end
  def parameters_require_sanitizing?; end
  def resource_class; end
  def resource_class_with_parent; end
  def resource_instance; end
  def resource_instance=(instance); end
  def save_actions; end

  private

  def action_exists_in?(options); end
  def adapter; end
  def current_ability; end

  class << self
    def add_before_action(controller_class, method, *args); end
    def before_callback_name(options); end
  end
end

module CanCan::ControllerResourceBuilder
  protected

  def assign_attributes(resource); end
  def build_resource; end
  def initial_attributes; end
end

module CanCan::ControllerResourceFinder
  protected

  def find_by_dynamic_finder; end
  def find_by_find_by_finder; end
  def find_resource; end
  def find_resource_using_find_by; end
  def id_param; end
  def id_param_key; end
end

module CanCan::ControllerResourceLoader
  include ::CanCan::ControllerResourceNameFinder
  include ::CanCan::ControllerResourceFinder
  include ::CanCan::ControllerResourceBuilder
  include ::CanCan::ControllerResourceSanitizer

  def load_resource; end

  protected

  def authorization_action; end
  def fetch_parent(name); end
  def load_collection; end
  def load_resource_instance; end
  def new_actions; end
  def parent_authorization_action; end
  def parent_name; end
  def parent_resource; end
  def resource_base; end
  def resource_base_through; end
  def resource_base_through_parent_resource; end
  def resource_params; end
  def resource_params_by_key(key); end
  def resource_params_by_namespaced_name; end

  private

  def extract_key(value); end
end

module CanCan::ControllerResourceNameFinder
  protected

  def name; end
  def name_from_controller; end
  def namespace; end
  def namespaced_name; end
end

module CanCan::ControllerResourceSanitizer
  protected

  def params_method; end
  def params_methods; end
  def sanitize_parameters; end
end

class CanCan::Error < ::StandardError; end
class CanCan::ImplementationRemoved < ::CanCan::Error; end
module CanCan::ModelAdapters; end

class CanCan::ModelAdapters::AbstractAdapter
  def initialize(model_class, rules); end

  def database_records; end

  class << self
    def adapter_class(model_class); end
    def find(model_class, id); end
    def for_class?(_member_class); end
    def inherited(subclass); end
    def matches_condition?(_subject, _name, _value); end
    def matches_conditions_hash?(_subject, _conditions); end
    def override_condition_matching?(_subject, _name, _value); end
    def override_conditions_hash_matching?(_subject, _conditions); end
  end
end

class CanCan::ModelAdapters::ActiveRecord4Adapter < ::CanCan::ModelAdapters::ActiveRecordAdapter
  private

  def build_relation(*where_conditions); end
  def sanitize_sql(conditions); end
  def sanitize_sql_activerecord4(conditions); end

  class << self
    def for_class?(model_class); end
    def matches_condition?(subject, name, value); end
    def override_condition_matching?(subject, name, _value); end
  end
end

class CanCan::ModelAdapters::ActiveRecord5Adapter < ::CanCan::ModelAdapters::ActiveRecord4Adapter
  private

  def build_relation(*where_conditions); end
  def sanitize_sql(conditions); end
  def sanitize_sql_activerecord5(conditions); end
  def visit_nodes(node); end

  class << self
    def for_class?(model_class); end
    def matches_condition?(subject, name, value); end
  end
end

class CanCan::ModelAdapters::ActiveRecordAdapter < ::CanCan::ModelAdapters::AbstractAdapter
  def initialize(model_class, rules); end

  def conditions; end
  def database_records; end
  def extract_multiple_conditions(conditions_extractor, rules); end
  def joins; end

  private

  def deep_clean(joins_hash); end
  def deep_merge(base_hash, added_hash); end
  def false_sql; end
  def merge_conditions(sql, conditions_hash, behavior); end
  def merge_non_empty_conditions(behavior, conditions_hash, sql); end
  def override_scope; end
  def raise_override_scope_error; end
  def sanitize_sql(conditions); end
  def true_sql; end

  class << self
    def version_greater_or_equal?(version); end
    def version_lower?(version); end
  end
end

class CanCan::ModelAdapters::ConditionsExtractor
  def initialize(model_class); end

  def tableize_conditions(conditions, model_class = T.unsafe(nil), path_to_key = T.unsafe(nil)); end

  private

  def add_to_cache(table_alias, relation_name, path_to_key); end
  def alredy_used?(table_alias, relation_name, path_to_key); end
  def calculate_nested(model_class, result_hash, relation_name, value, path_to_key); end
  def calculate_result_hash(key, model_class, path_to_key, result_hash, value); end
  def generate_table_alias(model_class, relation_name, path_to_key); end
end

class CanCan::ModelAdapters::ConditionsNormalizer
  class << self
    def normalize(model_class, rules); end
    def normalize_conditions(model_class, conditions); end

    private

    def calculate_result_hash(model_class, key, value); end
    def normalizable_association?(reflection); end
  end
end

class CanCan::ModelAdapters::DefaultAdapter < ::CanCan::ModelAdapters::AbstractAdapter; end

module CanCan::ModelAdditions
  mixes_in_class_methods ::CanCan::ModelAdditions::ClassMethods

  class << self
    def included(base); end
  end
end

module CanCan::ModelAdditions::ClassMethods
  def accessible_by(ability, action = T.unsafe(nil)); end
end

class CanCan::NotImplemented < ::CanCan::Error; end

module CanCan::ParameterValidators
  def valid_attribute_param?(attribute); end
end

module CanCan::Relevant
  def relevant?(action, subject); end

  private

  def matches_action?(action); end
  def matches_subject?(subject); end
  def matches_subject_class?(subject); end
end

class CanCan::Rule
  include ::CanCan::ConditionsMatcher
  include ::CanCan::Relevant
  include ::CanCan::ParameterValidators

  def initialize(base_behavior, action, subject, *extra_args, &block); end

  def actions; end
  def associations_hash(conditions = T.unsafe(nil)); end
  def attributes; end
  def attributes_from_conditions; end
  def base_behavior; end
  def can_rule?; end
  def cannot_catch_all?; end
  def catch_all?; end
  def conditions; end
  def conditions=(_arg0); end
  def expanded_actions=(_arg0); end
  def inspect; end
  def matches_attributes?(attribute); end
  def only_block?; end
  def only_raw_sql?; end
  def subjects; end
  def with_scope?; end

  private

  def condition_and_block_check(conditions, block, action, subject); end
  def parse_attributes_from_extra_args(args); end
  def wrap(object); end
end

class CanCan::RulesCompressor
  def initialize(rules); end

  def compress(array); end
  def initial_rules; end
  def rules_collapsed; end
end

module CanCan::UnauthorizedMessageResolver
  def translate_subject(subject); end
  def unauthorized_message(action, subject); end
end

CanCan::VERSION = T.let(T.unsafe(nil), String)
class CanCan::WrongAssociationName < ::CanCan::Error; end
module CanCanCan; end
