# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aws-partitions` gem.
# Please instead update this file by running `bin/tapioca gem aws-partitions`.

module Aws
  class << self
    def config; end
    def config=(config); end
    def eager_autoload!(*args); end
    def empty_connection_pools!; end
    def partition(partition_name); end
    def partitions; end
    def shared_config; end
    def use_bundled_cert!; end
  end
end

Aws::CORE_GEM_VERSION = T.let(T.unsafe(nil), String)

module Aws::Partitions
  extend ::Enumerable

  class << self
    def add(new_partitions); end
    def clear; end
    def default_partition_list; end
    def defaults; end
    def each(&block); end
    def partition(name); end
    def partitions; end
    def service_ids; end
  end
end

class Aws::Partitions::EndpointProvider
  def initialize(rules); end

  def dns_suffix_for(region, service, variants); end
  def resolve(region, service, sts_regional_endpoints, variants); end
  def signing_region(region, service, sts_regional_endpoints); end
  def signing_service(region, service); end

  private

  def build_is_global_fn(sts_regional_endpoints = T.unsafe(nil)); end
  def configured_variants?(variants); end
  def credential_scope(region, service, is_global_fn); end
  def default_partition; end
  def endpoint_for(region, service, is_global_fn, variants); end
  def endpoint_no_variants_for(region, service, is_global_fn); end
  def endpoint_with_variants_for(region, service, variants); end
  def fetch_variant(cfg, tags); end
  def get_partition(region_or_partition); end
  def partition_containing_region(region); end
  def partition_matching_name(partition_name); end
  def partition_matching_region(region); end
  def resolve_variant(region, service, config_variants); end
  def validate_variant!(config_variants, resolved_variant); end
  def warn_deprecation(service, region); end

  class << self
    def dns_suffix_for(region, service = T.unsafe(nil), variants = T.unsafe(nil)); end
    def resolve(region, service, sts_endpoint = T.unsafe(nil), variants = T.unsafe(nil)); end
    def signing_region(region, service, sts_regional_endpoints = T.unsafe(nil)); end
    def signing_service(region, service); end

    private

    def default_provider; end
  end
end

Aws::Partitions::EndpointProvider::STS_LEGACY_REGIONS = T.let(T.unsafe(nil), Array)

class Aws::Partitions::Partition
  def initialize(options = T.unsafe(nil)); end

  def name; end
  def region(region_name); end
  def region?(region_name); end
  def regions; end
  def service(service_name); end
  def service?(service_name); end
  def services; end

  class << self
    def build(partition); end

    private

    def build_regions(partition); end
    def build_services(partition); end
  end
end

class Aws::Partitions::PartitionList
  include ::Enumerable

  def initialize; end

  def add_partition(partition); end
  def clear; end
  def each(&block); end
  def partition(partition_name); end
  def partitions; end

  class << self
    def build(partitions); end
  end
end

class Aws::Partitions::Region
  def initialize(options = T.unsafe(nil)); end

  def description; end
  def name; end
  def partition_name; end
  def services; end

  class << self
    def build(region_name, region, partition); end

    private

    def region_services(region_name, partition); end
    def service_in_region?(svc, region_name); end
  end
end

class Aws::Partitions::Service
  def initialize(options = T.unsafe(nil)); end

  def dualstack_regions; end
  def fips_regions; end
  def name; end
  def partition_name; end
  def partition_region; end
  def regionalized?; end
  def regions; end

  class << self
    def build(service_name, service, partition); end

    private

    def partition_region(service); end
    def regions(service, partition); end
    def variant_regions(variant_name, service, partition); end
  end
end
