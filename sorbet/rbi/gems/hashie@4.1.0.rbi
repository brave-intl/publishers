# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hashie` gem.
# Please instead update this file by running `bin/tapioca gem hashie`.

module Hashie
  extend ::Hashie::Extensions::StringifyKeys::ClassMethods
  extend ::Hashie::Extensions::SymbolizeKeys::ClassMethods

  class << self
    def logger; end
    def logger=(logger); end
  end
end

class Hashie::Array < ::Array
  include ::Hashie::Extensions::Array::PrettyInspect
  include ::Hashie::Extensions::RubyVersionCheck
  extend ::Hashie::Extensions::RubyVersionCheck::ClassMethods

  def array_inspect; end
  def dig(*indexes); end
  def inspect; end
end

class Hashie::Clash < ::Hash
  def initialize(other_hash = T.unsafe(nil), parent = T.unsafe(nil)); end

  def _end!; end
  def _parent; end
  def id(*args); end
  def merge_store(key, *args); end
  def method_missing(name, *args); end

  private

  def respond_to_missing?(method_name, _include_private = T.unsafe(nil)); end
end

class Hashie::Clash::ChainError < ::StandardError; end

class Hashie::CoercionError < ::StandardError
  def initialize(key, value, into, message); end
end

class Hashie::Dash < ::Hashie::Hash
  def initialize(attributes = T.unsafe(nil), &block); end

  def [](property); end
  def []=(property, value); end
  def hash_inspect; end
  def inspect; end
  def merge(other_hash); end
  def merge!(other_hash); end
  def replace(other_hash); end
  def to_s; end
  def update_attributes!(attributes); end

  private

  def _regular_reader(_arg0); end
  def _regular_writer(_arg0, _arg1); end
  def assert_property_exists!(property); end
  def assert_property_required!(property, value); end
  def assert_property_set!(property); end
  def assert_required_attributes_set!; end
  def fail_no_property_error!(property); end
  def fail_property_required_error!(property); end
  def initialize_attributes(attributes); end
  def required?(property); end
  def update_attributes(attributes); end

  class << self
    def defaults; end
    def getters; end
    def inherited(klass); end
    def properties; end
    def property(property_name, options = T.unsafe(nil)); end
    def property?(name); end
    def required?(name); end
    def required_properties; end

    private

    def define_getter_for(property_name); end
    def define_setter_for(property_name); end
  end
end

module Hashie::Extensions; end
module Hashie::Extensions::Array; end

module Hashie::Extensions::Array::PrettyInspect
  def hashie_inspect; end

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::Coercion
  include ::Hashie::Extensions::Coercion::InstanceMethods

  class << self
    def included(base); end
  end
end

Hashie::Extensions::Coercion::ABSTRACT_CORE_TYPES = T.let(T.unsafe(nil), Hash)
Hashie::Extensions::Coercion::CORE_TYPES = T.let(T.unsafe(nil), Hash)

module Hashie::Extensions::Coercion::ClassMethods
  def build_coercion(type); end
  def build_container_coercion(type, value_type); end
  def build_core_type_coercion(type); end
  def build_hash_coercion(type, key_type, value_type); end
  def coerce_key(*attrs); end
  def coerce_keys(*attrs); end
  def coerce_value(from, into, options = T.unsafe(nil)); end
  def coercion_cache; end
  def fetch_coercion(type); end
  def inherited(klass); end
  def key_coercion(key); end
  def key_coercions; end
  def lenient_value_coercions; end
  def strict_value_coercions; end
  def value_coercion(value); end

  protected

  def key_coercions=(_arg0); end
end

module Hashie::Extensions::Coercion::InstanceMethods
  def custom_writer(key, value, _convert = T.unsafe(nil)); end
  def replace(other_hash); end
  def set_value_with_coercion(key, value); end
end

module Hashie::Extensions::Dash; end

module Hashie::Extensions::Dash::Coercion
  include ::Hashie::Extensions::Coercion::InstanceMethods

  mixes_in_class_methods ::Hashie::Extensions::Coercion::ClassMethods
  mixes_in_class_methods ::Hashie::Extensions::Dash::Coercion::ClassMethods

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::Dash::Coercion::ClassMethods
  def property(property_name, options = T.unsafe(nil)); end
end

module Hashie::Extensions::Dash::IndifferentAccess
  mixes_in_class_methods ::Hashie::Extensions::Dash::IndifferentAccess::ClassMethods

  class << self
    def included(base); end
    def maybe_extend(base); end

    private

    def requires_class_methods?(klass); end
  end
end

module Hashie::Extensions::Dash::IndifferentAccess::ClassMethods
  def property?(name); end
  def transformation_exists?(name); end
  def transformed_property(property_name, value); end
  def translation_exists?(name); end

  private

  def translation_for?(name); end
end

module Hashie::Extensions::Dash::PropertyTranslation
  include ::Hashie::Extensions::Dash::PropertyTranslation::InstanceMethods

  mixes_in_class_methods ::Hashie::Extensions::Dash::PropertyTranslation::ClassMethods

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::Dash::PropertyTranslation::ClassMethods
  def inherited(klass); end
  def inverse_translations; end
  def permitted_input_keys; end
  def property(property_name, options = T.unsafe(nil)); end
  def transformation_exists?(name); end
  def transformed_property(property_name, value); end
  def transforms; end
  def translation_exists?(name); end
  def translations; end
  def translations_hash; end

  private

  def define_translation(from, property_name, translator); end
  def define_writer_for_source_property(property); end
  def fail_self_transformation_error!(property_name); end
  def valid_transformer?(transformer); end
end

module Hashie::Extensions::Dash::PropertyTranslation::InstanceMethods
  def []=(property, value); end
  def initialize_attributes(attributes); end
  def property_exists?(property); end

  private

  def __translations; end
end

module Hashie::Extensions::DeepFetch
  def deep_fetch(*args, &block); end
end

class Hashie::Extensions::DeepFetch::UndefinedPathError < ::StandardError; end

module Hashie::Extensions::DeepFind
  def deep_detect(key); end
  def deep_find(key); end
  def deep_find_all(key); end
  def deep_select(key); end

  private

  def _deep_find(key, object = T.unsafe(nil)); end
  def _deep_find_all(key, object = T.unsafe(nil), matches = T.unsafe(nil)); end
end

module Hashie::Extensions::DeepLocate
  def deep_locate(comparator); end

  class << self
    def deep_locate(comparator, object); end

    private

    def _construct_key_comparator(search_key, object); end
    def _deep_locate(comparator, object, result = T.unsafe(nil)); end
    def _match_comparator?(value, comparator, object); end
    def activesupport_indifferent?(object); end
  end
end

module Hashie::Extensions::DeepMerge
  def deep_merge(other_hash, &block); end
  def deep_merge!(other_hash, &block); end

  private

  def _deep_dup(hash); end
  def _recursive_merge(hash, other_hash, &block); end
end

module Hashie::Extensions::IgnoreUndeclared
  def initialize_attributes(attributes); end
  def property_exists?(property); end
end

module Hashie::Extensions::IndifferentAccess
  def convert!; end
  def convert_key(key); end
  def indifferent_access?; end
  def indifferent_default(key = T.unsafe(nil)); end
  def indifferent_delete(key); end
  def indifferent_fetch(key, *args, &block); end
  def indifferent_key?(key); end
  def indifferent_replace(other_hash); end
  def indifferent_update(other_hash); end
  def indifferent_value(value); end
  def indifferent_values_at(*indices); end
  def indifferent_writer(key, value); end
  def merge(*args); end
  def merge!(*_arg0); end

  protected

  def hash_lacking_indifference?(other); end
  def hash_with_indifference?(other); end

  class << self
    def included(base); end
    def inject(hash); end
    def inject!(hash); end
  end
end

module Hashie::Extensions::KeyConflictWarning
  def disable_warnings(*method_keys); end
  def disable_warnings?(method_key = T.unsafe(nil)); end
  def disabled_warnings; end
  def inherited(subclass); end
end

class Hashie::Extensions::KeyConflictWarning::CannotDisableMashWarnings < ::StandardError
  def initialize; end
end

module Hashie::Extensions::KeyConversion
  include ::Hashie::Extensions::SymbolizeKeys
  include ::Hashie::Extensions::StringifyKeys

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::Mash; end

module Hashie::Extensions::Mash::DefineAccessors
  class << self
    def extended(obj); end
    def included(klass); end
  end
end

class Hashie::Extensions::Mash::DefineAccessors::Ext < ::Module
  def initialize; end

  def define_initializing_reader(key, method_name); end
  def define_predicate(key, method_name); end
  def define_reader(key, method_name); end
  def define_underbang_reader(key, method_name); end
  def define_writer(key, method_name); end
end

module Hashie::Extensions::Mash::KeepOriginalKeys
  private

  def __convert(key); end
  def convert_key(key); end

  class << self
    def included(descendant); end
  end
end

module Hashie::Extensions::Mash::PermissiveRespondTo
  private

  def log_collision?(method_key); end
  def respond_to_missing?(_method_name, _include_private = T.unsafe(nil)); end

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::Mash::SafeAssignment
  def []=(*args); end
  def custom_writer(key, *args); end
end

module Hashie::Extensions::Mash::SymbolizeKeys
  private

  def convert_key(key); end

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::MergeInitializer
  def initialize(hash = T.unsafe(nil), default = T.unsafe(nil), &block); end
end

module Hashie::Extensions::MethodAccess
  include ::Hashie::Extensions::MethodReader
  include ::Hashie::Extensions::MethodWriter
  include ::Hashie::Extensions::MethodQuery

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::MethodAccessWithOverride
  include ::Hashie::Extensions::MethodReader
  include ::Hashie::Extensions::MethodOverridingWriter
  include ::Hashie::Extensions::MethodQuery
  include ::Hashie::Extensions::MethodOverridingInitializer

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::MethodOverridingInitializer
  include ::Hashie::Extensions::RedefineMethod

  def initialize(hash = T.unsafe(nil)); end
end

module Hashie::Extensions::MethodOverridingWriter
  include ::Hashie::Extensions::RedefineMethod

  def convert_key(key); end
  def method_missing(name, *args); end

  protected

  def already_overridden?(name); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module Hashie::Extensions::MethodQuery
  def method_missing(name, *args); end

  private

  def indifferent_key?(name); end
  def key_from_query_method(query_method); end
  def query_method?(name); end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module Hashie::Extensions::MethodReader
  def method_missing(name, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module Hashie::Extensions::MethodWriter
  def convert_key(key); end
  def method_missing(name, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module Hashie::Extensions::Parsers; end

class Hashie::Extensions::Parsers::YamlErbParser
  def initialize(file_path, options = T.unsafe(nil)); end

  def perform; end

  private

  def yaml_safe_load(template, permitted_classes, permitted_symbols, aliases); end

  class << self
    def perform(file_path, options = T.unsafe(nil)); end
  end
end

module Hashie::Extensions::PrettyInspect
  def hashie_inspect; end

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::RedefineMethod
  protected

  def method?(name); end
  def redefine_method(method_name); end
end

class Hashie::Extensions::RubyVersion
  include ::Comparable

  def initialize(version); end

  def <=>(other); end
  def segments; end
  def segments=(_arg0); end

  private

  def split_to_segments(version); end
end

module Hashie::Extensions::RubyVersionCheck
  mixes_in_class_methods ::Hashie::Extensions::RubyVersionCheck::ClassMethods

  class << self
    def included(base); end
  end
end

module Hashie::Extensions::RubyVersionCheck::ClassMethods
  def with_minimum_ruby(version); end
  def with_minimum_ruby?(version); end
end

module Hashie::Extensions::StrictKeyAccess
  def [](key); end
  def default(_ = T.unsafe(nil)); end
  def default=(_); end
  def default_proc; end
  def default_proc=(_); end
  def key(value); end
end

class Hashie::Extensions::StrictKeyAccess::DefaultError < ::StandardError
  def initialize; end
end

module Hashie::Extensions::StringifyKeys
  extend ::Hashie::Extensions::StringifyKeys::ClassMethods

  def stringify_keys; end
  def stringify_keys!; end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
  def stringify_keys(hash); end
  def stringify_keys!(hash); end
  def stringify_keys_recursively!(object); end
end

module Hashie::Extensions::SymbolizeKeys
  extend ::Hashie::Extensions::SymbolizeKeys::ClassMethods

  def symbolize_keys; end
  def symbolize_keys!; end
end

module Hashie::Extensions::SymbolizeKeys::ClassMethods
  def symbolize_keys(hash); end
  def symbolize_keys!(hash); end
  def symbolize_keys_recursively!(object); end
end

class Hashie::Hash < ::Hash
  include ::Hashie::Extensions::PrettyInspect
  include ::Hashie::Extensions::StringifyKeys

  def hash_inspect; end
  def inspect; end
  def to_hash(options = T.unsafe(nil)); end
  def to_json(*args); end
  def to_mash; end

  private

  def flexibly_convert_to_hash(object, options = T.unsafe(nil)); end
  def maybe_convert_to_hash(object, options); end
end

class Hashie::Mash < ::Hashie::Hash
  include ::Hashie::Extensions::RubyVersionCheck
  extend ::Hashie::Extensions::RubyVersionCheck::ClassMethods
  extend ::Hashie::Extensions::KeyConflictWarning

  def initialize(source_hash = T.unsafe(nil), default = T.unsafe(nil), &blk); end

  def [](key); end
  def []=(key, value, convert = T.unsafe(nil)); end
  def assign_property(name, value); end
  def compact; end
  def custom_reader(key); end
  def custom_writer(key, value, convert = T.unsafe(nil)); end
  def deep_merge(*other_hashes, &blk); end
  def deep_merge!(*other_hashes, &blk); end
  def deep_update(*other_hashes, &blk); end
  def delete(key); end
  def dig(*keys); end
  def dup; end
  def extractable_options?; end
  def fetch(key, *args); end
  def has_key?(key); end
  def hash_inspect; end
  def include?(key); end
  def initializing_reader(key); end
  def inspect; end
  def invert; end
  def key?(key); end
  def member?(key); end
  def merge(*other_hashes, &blk); end
  def merge!(*other_hashes, &blk); end
  def method_missing(method_name, *args, &blk); end
  def prefix_method?(method_name); end
  def regular_dup; end
  def regular_key?(_arg0); end
  def regular_reader(_arg0); end
  def regular_writer(_arg0, _arg1); end
  def reject(&blk); end
  def replace(other_hash); end
  def reverse_merge(other_hash); end
  def select(&blk); end
  def shallow_merge(other_hash); end
  def shallow_update(other_hash); end
  def slice(*keys); end
  def to_module(mash_method_name = T.unsafe(nil)); end
  def to_s; end
  def transform_keys(&blk); end
  def transform_values(&blk); end
  def underbang_reader(key); end
  def update(*other_hashes, &blk); end
  def values_at(*keys); end
  def with_accessors!; end

  protected

  def convert_key(key); end
  def convert_value(val, duping = T.unsafe(nil)); end
  def method_name_and_suffix(method_name); end
  def method_suffix(method_name); end

  private

  def _deep_update(other_hash, &blk); end
  def log_built_in_message(method_key); end
  def log_collision?(method_key); end
  def respond_to_missing?(method_name, *args); end

  class << self
    def [](*_arg0); end
    def load(path, options = T.unsafe(nil)); end
    def quiet(*method_keys); end
  end
end

Hashie::Mash::ALLOWED_SUFFIXES = T.let(T.unsafe(nil), Array)
class Hashie::Railtie < ::Rails::Railtie; end

class Hashie::Rash
  def initialize(initial = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def all(query); end
  def fetch(*args); end
  def method_missing(*args, &block); end
  def optimize_every; end
  def optimize_every=(_arg0); end
  def update(other); end

  private

  def optimize_if_necessary!; end
  def respond_to_missing?(method_name, _include_private = T.unsafe(nil)); end
end

class Hashie::Trash < ::Hashie::Dash
  include ::Hashie::Extensions::Dash::PropertyTranslation
  include ::Hashie::Extensions::Dash::PropertyTranslation::InstanceMethods
  extend ::Hashie::Extensions::Dash::PropertyTranslation::ClassMethods
end

module Hashie::Utils
  class << self
    def integer_classes; end
    def method_information(bound_method); end
    def safe_dup(value); end
  end
end

Hashie::VERSION = T.let(T.unsafe(nil), String)
