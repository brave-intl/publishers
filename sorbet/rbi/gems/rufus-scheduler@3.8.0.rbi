# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rufus-scheduler` gem.
# Please instead update this file by running `bin/tapioca gem rufus-scheduler`.

module Rufus; end

class Rufus::Scheduler
  def initialize(opts = T.unsafe(nil)); end

  def around_trigger(job); end
  def at(time, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def at_jobs(opts = T.unsafe(nil)); end
  def confirm_lock; end
  def cron(cronline, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def cron_jobs(opts = T.unsafe(nil)); end
  def discard_past; end
  def discard_past=(_arg0); end
  def down?; end
  def every(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def every_jobs(opts = T.unsafe(nil)); end
  def frequency; end
  def frequency=(_arg0); end
  def in(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def in_jobs(opts = T.unsafe(nil)); end
  def interval(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def interval_jobs(opts = T.unsafe(nil)); end
  def job(job_id); end
  def jobs(opts = T.unsafe(nil)); end
  def join(time_limit = T.unsafe(nil)); end
  def lock; end
  def max_work_threads; end
  def max_work_threads=(_arg0); end
  def mutexes; end
  def occurrences(time0, time1, format = T.unsafe(nil)); end
  def on_error(job, err); end
  def pause; end
  def paused?; end
  def paused_at; end
  def repeat(arg, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def resume(opts = T.unsafe(nil)); end
  def running_jobs(opts = T.unsafe(nil)); end
  def schedule(arg, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def schedule_at(time, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def schedule_cron(cronline, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def schedule_every(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def schedule_in(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def schedule_interval(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def scheduled?(job_or_job_id); end
  def shutdown(opt = T.unsafe(nil)); end
  def started_at; end
  def stderr; end
  def stderr=(_arg0); end
  def stop(opt = T.unsafe(nil)); end
  def thread; end
  def thread_key; end
  def threads; end
  def timeline(time0, time1); end
  def unlock; end
  def unschedule(job_or_job_id); end
  def up?; end
  def uptime; end
  def uptime_s; end
  def work_queue; end
  def work_threads(query = T.unsafe(nil)); end

  protected

  def do_schedule(job_type, t, callable, opts, return_job_instance, block); end
  def fetch(job_or_job_id); end
  def join_shutdown(opts); end
  def kill_shutdown(opts); end
  def ltstamp; end
  def monow; end
  def no_time_limit_join; end
  def regular_shutdown(opts); end
  def rejoin; end
  def start; end
  def terminate_all_jobs; end
  def time_limit_join(limit); end
  def timeout_jobs; end
  def trigger_jobs; end
  def unschedule_jobs; end

  class << self
    def h_to_s(t = T.unsafe(nil)); end
    def ltstamp; end
    def monow; end
    def parse(o, opts = T.unsafe(nil)); end
    def parse_at(o, opts = T.unsafe(nil)); end
    def parse_cron(o, opts = T.unsafe(nil)); end
    def parse_duration(str, opts = T.unsafe(nil)); end
    def parse_in(o, opts = T.unsafe(nil)); end
    def s(opts = T.unsafe(nil)); end
    def singleton(opts = T.unsafe(nil)); end
    def start_new; end
    def to_duration(seconds, options = T.unsafe(nil)); end
    def to_duration_hash(seconds, options = T.unsafe(nil)); end
    def to_fugit_duration(seconds, options = T.unsafe(nil)); end
    def utc_to_s(t = T.unsafe(nil)); end
  end
end

class Rufus::Scheduler::AtJob < ::Rufus::Scheduler::OneTimeJob
  def initialize(scheduler, time, opts, block); end
end

class Rufus::Scheduler::CronJob < ::Rufus::Scheduler::RepeatJob
  def initialize(scheduler, cronline, opts, block); end

  def brute_frequency; end
  def check_frequency; end
  def cron_line; end
  def next_time_from(time); end
  def rough_frequency; end

  protected

  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

class Rufus::Scheduler::D
  class << self
    def h_to_s(t = T.unsafe(nil)); end
  end
end

Rufus::Scheduler::EoTime = EtOrbi::EoTime
class Rufus::Scheduler::Error < ::StandardError; end

class Rufus::Scheduler::EvInJob < ::Rufus::Scheduler::RepeatJob
  def first_at=(first); end
end

class Rufus::Scheduler::EveryJob < ::Rufus::Scheduler::EvInJob
  def initialize(scheduler, duration, opts, block); end

  def check_frequency; end
  def frequency; end
  def next_time_from(time); end
  def resume_discard_past; end
  def resume_discard_past=(_arg0); end

  protected

  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

class Rufus::Scheduler::FileLock
  def initialize(path); end

  def lock; end
  def locked?; end
  def path; end
  def unlock; end
end

class Rufus::Scheduler::InJob < ::Rufus::Scheduler::OneTimeJob
  def initialize(scheduler, duration, opts, block); end
end

class Rufus::Scheduler::IntervalJob < ::Rufus::Scheduler::EvInJob
  def initialize(scheduler, interval, opts, block); end

  def interval; end
  def next_time_from(time); end

  protected

  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

class Rufus::Scheduler::Job
  def initialize(scheduler, original, opts, block); end

  def [](key); end
  def []=(key, value); end
  def call(do_rescue = T.unsafe(nil)); end
  def callable; end
  def check_frequency; end
  def count; end
  def entries; end
  def handler; end
  def has_key?(key); end
  def id; end
  def job_id; end
  def key?(key); end
  def keys; end
  def kill; end
  def last_time; end
  def last_work_time; end
  def locals; end
  def location; end
  def mean_work_time; end
  def name; end
  def name=(_arg0); end
  def next_time; end
  def next_time=(_arg0); end
  def next_times(count); end
  def opts; end
  def original; end
  def params; end
  def previous_time; end
  def previous_time=(_arg0); end
  def resume_discard_past=(v); end
  def running?; end
  def scheduled?; end
  def scheduled_at; end
  def source_location; end
  def tags; end
  def threads; end
  def trigger(time); end
  def trigger_off_schedule(time = T.unsafe(nil)); end
  def unschedule; end
  def unscheduled_at; end
  def values; end

  protected

  def callback(meth, time); end
  def compute_timeout; end
  def do_call(time, do_rescue); end
  def do_trigger(time); end
  def mutex(m); end
  def post_trigger(time); end
  def start_work_thread; end
  def trigger_now(time); end
  def trigger_queue(time); end
end

Rufus::Scheduler::Job::EoTime = EtOrbi::EoTime
class Rufus::Scheduler::Job::KillSignal < ::StandardError; end

class Rufus::Scheduler::JobArray
  def initialize; end

  def [](job_id); end
  def delete_unscheduled; end
  def each(now, &block); end
  def push(job); end
  def size; end
  def to_a; end
  def unschedule_all; end
end

Rufus::Scheduler::MAX_WORK_THREADS = T.let(T.unsafe(nil), Integer)
class Rufus::Scheduler::NotRunningError < ::Rufus::Scheduler::Error; end

class Rufus::Scheduler::NullLock
  def lock; end
  def locked?; end
  def unlock; end
end

class Rufus::Scheduler::OneTimeJob < ::Rufus::Scheduler::Job
  def occurrences(time0, time1); end
  def time; end

  protected

  def determine_id; end
  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

class Rufus::Scheduler::RepeatJob < ::Rufus::Scheduler::Job
  def initialize(scheduler, duration, opts, block); end

  def determine_id; end
  def first_at; end
  def first_at=(first); end
  def last_at; end
  def last_at=(last); end
  def next_times(count); end
  def occurrences(time0, time1); end
  def pause; end
  def paused?; end
  def paused_at; end
  def resume(opts = T.unsafe(nil)); end
  def times; end
  def times=(_arg0); end
  def trigger(time); end

  protected

  def discard_past?; end
end

Rufus::Scheduler::RepeatJob::FIRSTS = T.let(T.unsafe(nil), Array)
class Rufus::Scheduler::TimeoutError < ::Rufus::Scheduler::Error; end
Rufus::Scheduler::VERSION = T.let(T.unsafe(nil), String)
