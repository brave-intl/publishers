# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cose` gem.
# Please instead update this file by running `bin/tapioca gem cose`.

module COSE; end

module COSE::Algorithm
  class << self
    def by_id(id); end
    def by_name(name); end
    def find(id_or_name); end
    def register(algorithm); end
  end
end

class COSE::Algorithm::Base
  def initialize(id, name); end

  def id; end
  def name; end
end

class COSE::Algorithm::ECDSA < ::COSE::Algorithm::SignatureAlgorithm
  def initialize(*args, hash_function:, curve_name:); end

  def curve; end
  def hash_function; end

  private

  def signature_algorithm_class; end
  def signature_algorithm_parameters; end
  def to_pkey(key); end
  def valid_key?(key); end
end

class COSE::Algorithm::HMAC < ::COSE::Algorithm::Base
  def initialize(*args, hash_function:, tag_length:); end

  def hash_function; end
  def mac(key, to_be_signed); end
  def tag_length; end

  private

  def tag_bytesize; end
end

COSE::Algorithm::HMAC::BYTE_LENGTH = T.let(T.unsafe(nil), Integer)

class COSE::Algorithm::RSAPSS < ::COSE::Algorithm::SignatureAlgorithm
  def initialize(*args, hash_function:, salt_length:); end

  def hash_function; end
  def salt_length; end

  private

  def signature_algorithm_class; end
  def to_pkey(key); end
  def valid_key?(key); end
end

class COSE::Algorithm::SignatureAlgorithm < ::COSE::Algorithm::Base
  def compatible_key?(key); end
  def verify(key, signature, verification_data); end

  private

  def signature_algorithm_class; end
  def signature_algorithm_parameters; end
  def to_cose_key(key); end
  def to_pkey(_key); end
  def valid_key?(_key); end
  def valid_signature?(key, signature, verification_data); end
end

class COSE::Encrypt < ::COSE::SecurityMessage
  def initialize(ciphertext:, recipients:, **keyword_arguments); end

  def ciphertext; end
  def recipients; end

  class << self
    def keyword_arguments_for_initialize(decoded); end
  end
end

class COSE::Encrypt0 < ::COSE::SecurityMessage
  def initialize(ciphertext:, **keyword_arguments); end

  def ciphertext; end

  class << self
    def keyword_arguments_for_initialize(decoded); end
  end
end

class COSE::Error < ::StandardError; end

module COSE::Key
  class << self
    def cbor_decode(data); end
    def deserialize(data); end
    def from_pkey(pkey); end
    def serialize(pkey); end
  end
end

class COSE::Key::Base
  def initialize(kid: T.unsafe(nil), alg: T.unsafe(nil), key_ops: T.unsafe(nil), base_iv: T.unsafe(nil)); end

  def alg; end
  def alg=(_arg0); end
  def base_iv; end
  def base_iv=(_arg0); end
  def key_ops; end
  def key_ops=(_arg0); end
  def kid; end
  def kid=(_arg0); end
  def map; end
  def serialize; end

  class << self
    def deserialize(cbor); end
    def from_map(map); end
  end
end

COSE::Key::Base::LABEL_ALG = T.let(T.unsafe(nil), Integer)
COSE::Key::Base::LABEL_BASE_IV = T.let(T.unsafe(nil), Integer)
COSE::Key::Base::LABEL_KEY_OPS = T.let(T.unsafe(nil), Integer)
COSE::Key::Base::LABEL_KID = T.let(T.unsafe(nil), Integer)
COSE::Key::Base::LABEL_KTY = T.let(T.unsafe(nil), Integer)

class COSE::Key::Curve < ::Struct
  def id; end
  def id=(_); end
  def name; end
  def name=(_); end
  def pkey_name; end
  def pkey_name=(_); end
  def value; end

  class << self
    def [](*_arg0); end
    def by_name(name); end
    def by_pkey_name(pkey_name); end
    def find(id); end
    def inspect; end
    def members; end
    def new(*_arg0); end
    def register(id, name, pkey_name); end
  end
end

class COSE::Key::CurveKey < ::COSE::Key::Base
  def initialize(crv:, x: T.unsafe(nil), d: T.unsafe(nil), **keyword_arguments); end

  def crv; end
  def d; end
  def map; end
  def x; end

  class << self
    def keyword_arguments_for_initialize(map); end
  end
end

COSE::Key::CurveKey::LABEL_CRV = T.let(T.unsafe(nil), Integer)
COSE::Key::CurveKey::LABEL_D = T.let(T.unsafe(nil), Integer)
COSE::Key::CurveKey::LABEL_X = T.let(T.unsafe(nil), Integer)

class COSE::Key::EC2 < ::COSE::Key::CurveKey
  def initialize(y: T.unsafe(nil), **keyword_arguments); end

  def curve; end
  def map; end
  def to_pkey; end
  def y; end

  class << self
    def enforce_type(map); end
    def from_pkey(pkey); end
    def keyword_arguments_for_initialize(map); end
  end
end

COSE::Key::EC2::KTY_EC2 = T.let(T.unsafe(nil), Integer)
COSE::Key::EC2::LABEL_Y = T.let(T.unsafe(nil), Integer)

class COSE::Key::OKP < ::COSE::Key::CurveKey
  def map; end

  class << self
    def enforce_type(map); end
  end
end

COSE::Key::OKP::KTY_OKP = T.let(T.unsafe(nil), Integer)

class COSE::Key::RSA < ::COSE::Key::Base
  def initialize(n:, e:, d: T.unsafe(nil), p: T.unsafe(nil), q: T.unsafe(nil), dp: T.unsafe(nil), dq: T.unsafe(nil), qinv: T.unsafe(nil), **keyword_arguments); end

  def d; end
  def dp; end
  def dq; end
  def e; end
  def map; end
  def n; end
  def p; end
  def q; end
  def qinv; end
  def to_pkey; end

  private

  def bn(data); end
  def private?; end

  class << self
    def enforce_type(map); end
    def from_pkey(pkey); end
    def keyword_arguments_for_initialize(map); end
  end
end

COSE::Key::RSA::KTY_RSA = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_D = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_DP = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_DQ = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_E = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_N = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_P = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_Q = T.let(T.unsafe(nil), Integer)
COSE::Key::RSA::LABEL_QINV = T.let(T.unsafe(nil), Integer)

class COSE::Key::Symmetric < ::COSE::Key::Base
  def initialize(k:, **keyword_arguments); end

  def k; end
  def map; end

  class << self
    def enforce_type(map); end
    def keyword_arguments_for_initialize(map); end
  end
end

COSE::Key::Symmetric::KTY_SYMMETRIC = T.let(T.unsafe(nil), Integer)
COSE::Key::Symmetric::LABEL_K = T.let(T.unsafe(nil), Integer)
class COSE::KeyDeserializationError < ::COSE::Error; end

class COSE::Mac < ::COSE::Mac0
  def initialize(recipients:, **keyword_arguments); end

  def recipients; end
  def verify(key, external_aad = T.unsafe(nil)); end

  private

  def context; end

  class << self
    def keyword_arguments_for_initialize(decoded); end
    def tag; end
  end
end

class COSE::Mac0 < ::COSE::SecurityMessage
  def initialize(payload:, tag:, **keyword_arguments); end

  def payload; end
  def tag; end
  def verify(key, external_aad = T.unsafe(nil)); end

  private

  def context; end
  def data(external_aad = T.unsafe(nil)); end

  class << self
    def keyword_arguments_for_initialize(decoded); end
    def tag; end
  end
end

COSE::Mac0::CONTEXT = T.let(T.unsafe(nil), String)
COSE::Mac::CONTEXT = T.let(T.unsafe(nil), String)
class COSE::MalformedKeyError < ::COSE::KeyDeserializationError; end

class COSE::Recipient < ::COSE::SecurityMessage
  def initialize(ciphertext:, recipients: T.unsafe(nil), **keyword_arguments); end

  def ciphertext; end
  def recipients; end

  class << self
    def keyword_arguments_for_initialize(decoded); end
  end
end

class COSE::SecurityMessage
  def initialize(protected_headers:, unprotected_headers:); end

  def algorithm; end
  def headers; end
  def protected_headers; end
  def unprotected_headers; end

  private

  def serialized_map(map); end
  def zero_length_bin_string; end

  class << self
    def deserialize(cbor); end
    def deserialize_headers(data); end
    def from_array(array); end
  end
end

class COSE::SecurityMessage::Headers
  def initialize(protected_bucket, unprotected_bucket); end

  def alg; end
  def kid; end
  def protected_bucket; end
  def unprotected_bucket; end

  private

  def header(label); end
end

COSE::SecurityMessage::Headers::HEADER_LABEL_ALG = T.let(T.unsafe(nil), Integer)
COSE::SecurityMessage::Headers::HEADER_LABEL_KID = T.let(T.unsafe(nil), Integer)
COSE::SecurityMessage::ZERO_LENGTH_BIN_STRING = T.let(T.unsafe(nil), String)

class COSE::Sign < ::COSE::SecurityMessage
  def initialize(payload:, signatures:, **keyword_arguments); end

  def payload; end
  def signatures; end
  def verify(key, external_aad = T.unsafe(nil)); end

  private

  def verification_data(signature, external_aad = T.unsafe(nil)); end

  class << self
    def keyword_arguments_for_initialize(decoded); end
    def tag; end
  end
end

class COSE::Sign1 < ::COSE::SecurityMessage
  def initialize(payload:, signature:, **keyword_arguments); end

  def payload; end
  def signature; end
  def verify(key, external_aad = T.unsafe(nil)); end

  private

  def verification_data(external_aad = T.unsafe(nil)); end

  class << self
    def keyword_arguments_for_initialize(decoded); end
    def tag; end
  end
end

COSE::Sign1::CONTEXT = T.let(T.unsafe(nil), String)
COSE::Sign::CONTEXT = T.let(T.unsafe(nil), String)

class COSE::Signature < ::COSE::SecurityMessage
  def initialize(signature:, **keyword_arguments); end

  def signature; end

  class << self
    def keyword_arguments_for_initialize(decoded); end
  end
end

class COSE::UnknownKeyType < ::COSE::KeyDeserializationError; end
COSE::VERSION = T.let(T.unsafe(nil), String)
