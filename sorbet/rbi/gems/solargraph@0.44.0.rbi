# typed: ignore

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `solargraph` gem.
# Please instead update this file by running `bin/tapioca gem solargraph`.

module Solargraph
  class << self
    def logger; end
    def with_clean_env(&block); end
  end
end

class Solargraph::ApiMap
  include ::Solargraph::ApiMap::SourceToYard

  def initialize(pins: T.unsafe(nil)); end

  def bundled?(filename); end
  def catalog(bench); end
  def clip(cursor); end
  def clip_at(filename, position); end
  def cursor_at(filename, position); end
  def document(path); end
  def document_symbols(filename); end
  def get_class_variable_pins(namespace); end
  def get_complex_type_methods(type, context = T.unsafe(nil), internal = T.unsafe(nil)); end
  def get_constants(namespace, *contexts); end
  def get_global_variable_pins; end
  def get_instance_variable_pins(namespace, scope = T.unsafe(nil)); end
  def get_method_stack(fqns, name, scope: T.unsafe(nil)); end
  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil), deep: T.unsafe(nil)); end
  def get_path_pins(path); end
  def get_path_suggestions(path); end
  def get_symbols; end
  def implicit; end
  def index(pins); end
  def keyword_pins; end
  def locate_pins(location); end
  def map(source); end
  def named_macro(name); end
  def namespace_exists?(name, context = T.unsafe(nil)); end
  def namespaces; end
  def pins; end
  def qualify(namespace, context = T.unsafe(nil)); end
  def query_symbols(query); end
  def rebindable_method_names; end
  def required; end
  def search(query); end
  def source_map(filename); end
  def source_maps; end
  def super_and_sub?(sup, sub); end
  def type_include?(host, mod); end
  def unresolved_requires; end
  def yard_map; end

  private

  def cache; end
  def get_namespace_type(fqns); end
  def inner_get_constants(fqns, visibility, skip); end
  def inner_get_methods(fqns, scope, visibility, deep, skip, no_core = T.unsafe(nil)); end
  def inner_qualify(name, root, skip); end
  def path_macros; end
  def prefer_non_nil_variables(pins); end
  def qualify_lower(namespace, context); end
  def qualify_superclass(fqsub); end
  def resolve_method_alias(pin); end
  def resolve_method_aliases(pins, visibility = T.unsafe(nil)); end
  def source_map_hash; end
  def store; end

  class << self
    def load(directory); end
  end
end

module Solargraph::ApiMap::BundlerMethods
  private

  def require_from_bundle(directory); end

  class << self
    def require_from_bundle(directory); end
  end
end

class Solargraph::ApiMap::Cache
  def initialize; end

  def clear; end
  def empty?; end
  def get_constants(namespace, context); end
  def get_methods(fqns, scope, visibility, deep); end
  def get_qualified_namespace(name, context); end
  def get_receiver_definition(path); end
  def receiver_defined?(path); end
  def set_constants(namespace, context, value); end
  def set_methods(fqns, scope, visibility, deep, value); end
  def set_qualified_namespace(name, context, value); end
  def set_receiver_definition(path, pin); end
end

module Solargraph::ApiMap::SourceToYard
  def code_object_at(path); end
  def code_object_paths; end
  def rake_yard(store); end

  private

  def code_object_map; end
  def root_code_object; end
end

class Solargraph::ApiMap::Store
  def initialize(pins = T.unsafe(nil)); end

  def block_pins; end
  def domains(fqns); end
  def get_class_variables(fqns); end
  def get_constants(fqns, visibility = T.unsafe(nil)); end
  def get_extends(fqns); end
  def get_includes(fqns); end
  def get_instance_variables(fqns, scope = T.unsafe(nil)); end
  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil)); end
  def get_path_pins(path); end
  def get_prepends(fqns); end
  def get_superclass(fqns); end
  def get_symbols; end
  def inspect; end
  def method_pins; end
  def named_macros; end
  def namespace_exists?(fqns); end
  def namespace_pins; end
  def namespaces; end
  def pins; end
  def pins_by_class(klass); end

  private

  def all_instance_variables; end
  def extend_references; end
  def fqns_pins(fqns); end
  def fqns_pins_map; end
  def include_references; end
  def index; end
  def namespace_children(name); end
  def namespace_map; end
  def path_pin_hash; end
  def prepend_references; end
  def superclass_references; end
  def symbols; end
end

class Solargraph::Bench
  def initialize(source_maps: T.unsafe(nil), workspace: T.unsafe(nil), external_requires: T.unsafe(nil)); end

  def external_requires; end
  def source_maps; end
  def workspace; end
end

class Solargraph::BundleNotFoundError < ::StandardError; end

class Solargraph::ComplexType
  def initialize(types = T.unsafe(nil)); end

  def [](index); end
  def all?(&block); end
  def each(&block); end
  def first; end
  def length; end
  def map(&block); end
  def method_missing(name, *args, &block); end
  def namespace; end
  def qualify(api_map, context = T.unsafe(nil)); end
  def select(&block); end
  def self_to(dst); end
  def selfy?; end
  def to_s; end

  private

  def reduce_class(dst); end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def parse(*strings, partial: T.unsafe(nil)); end
    def try_parse(*strings); end
  end
end

Solargraph::ComplexType::BOOLEAN = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::NIL = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::ROOT = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::SELF = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::SYMBOL = T.let(T.unsafe(nil), Solargraph::ComplexType)

module Solargraph::ComplexType::TypeMethods
  def ==(other); end
  def defined?; end
  def duck_type?; end
  def fixed_parameters?; end
  def hash_parameters?; end
  def key_types; end
  def list_parameters?; end
  def name; end
  def namespace; end
  def nil_type?; end
  def parameters?; end
  def qualify(api_map, context = T.unsafe(nil)); end
  def rooted?; end
  def scope; end
  def substring; end
  def subtypes; end
  def tag; end
  def undefined?; end
  def value_types; end
  def void?; end
end

Solargraph::ComplexType::UNDEFINED = T.let(T.unsafe(nil), Solargraph::ComplexType)

class Solargraph::ComplexType::UniqueType
  include ::Solargraph::ComplexType::TypeMethods

  def initialize(name, substring = T.unsafe(nil)); end

  def self_to(dst); end
  def selfy?; end
  def to_s; end
end

Solargraph::ComplexType::UniqueType::BOOLEAN = T.let(T.unsafe(nil), Solargraph::ComplexType::UniqueType)
Solargraph::ComplexType::UniqueType::UNDEFINED = T.let(T.unsafe(nil), Solargraph::ComplexType::UniqueType)
Solargraph::ComplexType::VOID = T.let(T.unsafe(nil), Solargraph::ComplexType)
class Solargraph::ComplexTypeError < ::StandardError; end

module Solargraph::Convention
  class << self
    def for_global(yard_map); end
    def for_local(source_map); end
    def register(convention); end
  end
end

class Solargraph::Convention::Base
  def global(yard_map); end
  def local(source_map); end
end

Solargraph::Convention::Base::EMPTY_ENVIRON = T.let(T.unsafe(nil), Solargraph::Environ)

class Solargraph::Convention::Gemfile < ::Solargraph::Convention::Base
  def local(source_map); end
end

class Solargraph::Convention::Gemspec < ::Solargraph::Convention::Base
  def local(source_map); end
end

class Solargraph::Convention::Rspec < ::Solargraph::Convention::Base
  def local(source_map); end
end

module Solargraph::Diagnostics
  class << self
    def register(name, klass); end
    def reporter(name); end
    def reporters; end

    private

    def reporter_hash; end
  end
end

class Solargraph::Diagnostics::Base
  def initialize(*args); end

  def args; end
  def diagnose(source, api_map); end
end

class Solargraph::Diagnostics::RequireNotFound < ::Solargraph::Diagnostics::Base
  def diagnose(source, api_map); end

  private

  def require_error(path, location); end
end

class Solargraph::Diagnostics::Rubocop < ::Solargraph::Diagnostics::Base
  include ::Solargraph::Diagnostics::RubocopHelpers

  def diagnose(source, _api_map); end

  private

  def make_array(resp); end
  def offense_ending_position(off); end
  def offense_range(off); end
  def offense_start_position(off); end
  def offense_to_diagnostic(off); end
  def rubocop_version; end
end

Solargraph::Diagnostics::Rubocop::SEVERITIES = T.let(T.unsafe(nil), Hash)

module Solargraph::Diagnostics::RubocopHelpers
  private

  def fix_drive_letter(path); end
  def generate_options(filename, code); end
  def redirect_stdout; end
  def require_rubocop(version = T.unsafe(nil)); end

  class << self
    def fix_drive_letter(path); end
    def generate_options(filename, code); end
    def redirect_stdout; end
    def require_rubocop(version = T.unsafe(nil)); end
  end
end

module Solargraph::Diagnostics::Severities; end
Solargraph::Diagnostics::Severities::ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::Diagnostics::Severities::HINT = T.let(T.unsafe(nil), Integer)
Solargraph::Diagnostics::Severities::INFORMATION = T.let(T.unsafe(nil), Integer)
Solargraph::Diagnostics::Severities::WARNING = T.let(T.unsafe(nil), Integer)

class Solargraph::Diagnostics::TypeCheck < ::Solargraph::Diagnostics::Base
  def diagnose(source, api_map); end

  private

  def extract_first_line(location, source); end
  def last_character(position, source); end
end

class Solargraph::Diagnostics::UpdateErrors < ::Solargraph::Diagnostics::Base
  def diagnose(source, api_map); end

  private

  def combine_ranges(code, ranges); end
end

class Solargraph::DiagnosticsError < ::RuntimeError; end

class Solargraph::Documentor
  def initialize(directory, rebuild: T.unsafe(nil), out: T.unsafe(nil)); end

  def document; end

  class << self
    def specs_from_bundle(directory); end
  end
end

Solargraph::Documentor::RDOC_GEMS = T.let(T.unsafe(nil), Array)

class Solargraph::DomainDirective < ::YARD::Tags::Directive
  def call; end
end

class Solargraph::Environ
  def initialize(requires: T.unsafe(nil), domains: T.unsafe(nil), pins: T.unsafe(nil)); end

  def clear; end
  def domains; end
  def merge(other); end
  def pins; end
  def requires; end
end

class Solargraph::FileNotFoundError < ::RuntimeError; end
class Solargraph::InvalidOffsetError < ::RangeError; end
class Solargraph::InvalidRubocopVersionError < ::RuntimeError; end
module Solargraph::LanguageServer; end
module Solargraph::LanguageServer::CompletionItemKinds; end
Solargraph::LanguageServer::CompletionItemKinds::CLASS = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::COLOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::CONSTANT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::CONSTRUCTOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::ENUM = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::ENUM_MEMBER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::EVENT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FIELD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FILE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FOLDER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FUNCTION = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::INTERFACE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::KEYWORD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::METHOD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::MODULE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::OPERATOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::PROPERTY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::REFERENCE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::SNIPPET = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::STRUCT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::TEXT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::TYPE_PARAMETER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::UNIT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::VALUE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::VARIABLE = T.let(T.unsafe(nil), Integer)
module Solargraph::LanguageServer::ErrorCodes; end
Solargraph::LanguageServer::ErrorCodes::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::INVALID_PARAMS = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::INVALID_REQUEST = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::METHOD_NOT_FOUND = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::PARSE_ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::REQUEST_CANCELLED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::SERVER_ERROR_END = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::SERVER_ERROR_START = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::SERVER_NOT_INITIALIZED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::UNKNOWN_ERROR_CODE = T.let(T.unsafe(nil), Integer)

class Solargraph::LanguageServer::Host
  include ::Solargraph::LanguageServer::UriHelpers
  include ::Solargraph::Logging
  include ::Solargraph::LanguageServer::Host::Dispatch
  include ::Observable

  def initialize; end

  def allow_registration(method); end
  def can_register?(method); end
  def cancel(id); end
  def cancel?(id); end
  def catalog; end
  def change(params); end
  def clear(id); end
  def client_capabilities; end
  def client_capabilities=(_arg0); end
  def close(uri); end
  def completions_at(uri, line, column); end
  def configure(update); end
  def create(uri); end
  def default_configuration; end
  def definitions_at(uri, line, column); end
  def delete(uri); end
  def diagnose(uri); end
  def document(query); end
  def document_symbols(uri); end
  def flush; end
  def folders; end
  def folding_ranges(uri); end
  def formatter_config(uri); end
  def has_pending_completions?; end
  def locate_pins(params); end
  def open(uri, text, version); end
  def open?(uri); end
  def open_from_disk(uri); end
  def options; end
  def pending_requests; end
  def prepare(directory, name = T.unsafe(nil)); end
  def prepare_folders(array); end
  def process(request); end
  def query_symbols(query); end
  def queue(message); end
  def read_text(uri); end
  def receive(request); end
  def references_from(uri, line, column, strip: T.unsafe(nil), only: T.unsafe(nil)); end
  def register_capabilities(methods); end
  def registered?(method); end
  def remove(directory); end
  def remove_folders(array); end
  def search(query); end
  def send_notification(method, params); end
  def send_request(method, params, &block); end
  def show_message(text, type = T.unsafe(nil)); end
  def show_message_request(text, type, actions, &block); end
  def signatures_at(uri, line, column); end
  def start; end
  def stop; end
  def stopped?; end
  def synchronizing?; end
  def unregister_capabilities(methods); end

  private

  def async_library_map(library); end
  def cataloger; end
  def check_diff(uri, change); end
  def client_supports_progress?; end
  def diagnoser; end
  def do_async_library_map(library, uuid = T.unsafe(nil)); end
  def dynamic_capability_options; end
  def generate_updater(params); end
  def message_worker; end
  def normalize_separators(path); end
  def prepare_rename?; end
  def requests; end
end

class Solargraph::LanguageServer::Host::Cataloger
  def initialize(host); end

  def start; end
  def stop; end
  def stopped?; end
  def tick; end

  private

  def host; end
end

class Solargraph::LanguageServer::Host::Diagnoser
  def initialize(host); end

  def schedule(uri); end
  def start; end
  def stop; end
  def stopped?; end
  def tick; end

  private

  def host; end
  def mutex; end
  def queue; end
end

module Solargraph::LanguageServer::Host::Dispatch
  def explicit_library_for(uri); end
  def generic_library; end
  def generic_library_for(uri); end
  def implicit_library_for(uri); end
  def libraries; end
  def library_for(uri); end
  def sources; end
  def update_libraries(uri); end
end

class Solargraph::LanguageServer::Host::MessageWorker
  def initialize(host); end

  def messages; end
  def queue(message); end
  def start; end
  def stop; end
  def stopped?; end
  def tick; end
end

class Solargraph::LanguageServer::Host::Sources
  include ::Observable
  include ::Solargraph::LanguageServer::UriHelpers

  def initialize; end

  def add_uri(uri); end
  def async_update(uri, updater); end
  def clear; end
  def close(uri); end
  def find(uri); end
  def include?(uri); end
  def next_uri; end
  def open(uri, text, version); end
  def open_from_disk(uri); end
  def start; end
  def stop; end
  def stopped?; end
  def tick; end
  def update(uri, updater); end

  private

  def mutex; end
  def open_source_hash; end
  def queue; end
end

module Solargraph::LanguageServer::Message
  class << self
    def register(path, message_class); end
    def select(path); end

    private

    def method_map; end
  end
end

class Solargraph::LanguageServer::Message::Base
  def initialize(host, request); end

  def error; end
  def host; end
  def id; end
  def method; end
  def params; end
  def post_initialize; end
  def process; end
  def request; end
  def result; end
  def send_response; end
  def set_error(code, message); end
  def set_result(data); end
end

class Solargraph::LanguageServer::Message::CancelRequest < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

module Solargraph::LanguageServer::Message::CompletionItem; end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  def join_docs(pins); end
  def markup_content(text); end
  def merge(pins); end
end

class Solargraph::LanguageServer::Message::ExitNotification < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

module Solargraph::LanguageServer::Message::Extended; end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion < ::Solargraph::LanguageServer::Message::Base
  def initialize(host, request, current: T.unsafe(nil), available: T.unsafe(nil)); end

  def process; end

  private

  def available; end
  def current; end
  def error; end
  def fetched?; end

  class << self
    def fetcher; end
    def fetcher=(obj); end
  end
end

Solargraph::LanguageServer::Message::Extended::CheckGemVersion::GEM_ZERO = T.let(T.unsafe(nil), Gem::Version)

class Solargraph::LanguageServer::Message::Extended::Document < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Extended::Environment < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Extended::Search < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Initialize < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  def dynamic_registration_for?(section, capability); end
  def static_code_action; end
  def static_completion; end
  def static_definitions; end
  def static_document_formatting; end
  def static_document_symbols; end
  def static_folding_range; end
  def static_highlights; end
  def static_hover; end
  def static_on_type_formatting; end
  def static_references; end
  def static_rename; end
  def static_signature_help; end
  def static_workspace_symbols; end
  def support_workspace_folders?; end
end

class Solargraph::LanguageServer::Message::Initialized < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::MethodNotFound < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::MethodNotImplemented < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Shutdown < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

module Solargraph::LanguageServer::Message::TextDocument; end

class Solargraph::LanguageServer::Message::TextDocument::Base < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  def filename; end
  def post_initialize; end
end

class Solargraph::LanguageServer::Message::TextDocument::Completion < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def empty_result(incomplete = T.unsafe(nil)); end
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::Definition < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end

  private

  def code_location; end
  def require_location; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentHighlight < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting < ::Solargraph::LanguageServer::Message::TextDocument::Base
  include ::Solargraph::Diagnostics::RubocopHelpers

  def process; end

  private

  def cli_args(file_uri, config); end
  def config_for(file_uri); end
  def cop_list(value); end
  def format(original, result); end
  def formatter_class(config); end
  def log_corrections(corrections); end
end

class Solargraph::LanguageServer::Message::TextDocument::Hover < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::References < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::Rename < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

module Solargraph::LanguageServer::Message::Workspace; end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  def register_from_options; end
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  def process; end
end

Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles::CHANGED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles::CREATED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles::DELETED = T.let(T.unsafe(nil), Integer)

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  def add_folders; end
  def remove_folders; end
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  def process; end
end

module Solargraph::LanguageServer::MessageTypes; end
Solargraph::LanguageServer::MessageTypes::ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::MessageTypes::INFO = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::MessageTypes::LOG = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::MessageTypes::WARNING = T.let(T.unsafe(nil), Integer)

class Solargraph::LanguageServer::Request
  def initialize(id, &block); end

  def process(result); end
  def send_response; end
end

module Solargraph::LanguageServer::SymbolKinds; end
Solargraph::LanguageServer::SymbolKinds::ARRAY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::BOOLEAN = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::CLASS = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::CONSTANT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::CONSTRUCTOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::ENUM = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::ENUM_MEMBER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::EVENT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::FIELD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::FILE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::FUNCTION = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::INTERFACE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::KEY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::METHOD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::MODULE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::NAMESPACE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::NULL = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::NUMBER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::OBJECT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::OPERATOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::PACKAGE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::PROPERTY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::STRING = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::STRUCT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::TYPE_PARAMETER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::VARIABLE = T.let(T.unsafe(nil), Integer)
module Solargraph::LanguageServer::Transport; end

module Solargraph::LanguageServer::Transport::Adapter
  def closing; end
  def opening; end
  def receiving(data); end
  def update; end

  private

  def process(request); end
  def shutdown; end
end

class Solargraph::LanguageServer::Transport::DataReader
  def initialize; end

  def receive(data); end
  def set_message_handler(&block); end

  private

  def parse_message_from_buffer; end
  def prepare_to_parse_message; end
end

module Solargraph::LanguageServer::UriHelpers
  private

  def decode(text); end
  def encode(text); end
  def file_to_uri(file); end
  def uri_to_file(uri); end

  class << self
    def decode(text); end
    def encode(text); end
    def file_to_uri(file); end
    def uri_to_file(uri); end
  end
end

class Solargraph::Library
  include ::Solargraph::Logging

  def initialize(workspace = T.unsafe(nil), name = T.unsafe(nil)); end

  def attach(source); end
  def attached?(filename); end
  def bench; end
  def catalog; end
  def close(filename); end
  def completions_at(filename, line, column); end
  def contain?(filename); end
  def create(filename, text); end
  def create_from_disk(filename); end
  def current; end
  def definitions_at(filename, line, column); end
  def delete(filename); end
  def detach(filename); end
  def diagnose(filename); end
  def document(query); end
  def document_symbols(filename); end
  def external_requires; end
  def folding_ranges(filename); end
  def get_path_pins(path); end
  def inspect; end
  def locate_pins(location); end
  def locate_ref(location); end
  def map!; end
  def mapped?; end
  def merge(source); end
  def name; end
  def next_map; end
  def open?(filename); end
  def path_pins(path); end
  def pins; end
  def query_symbols(query); end
  def read_text(filename); end
  def references_from(filename, line, column, strip: T.unsafe(nil), only: T.unsafe(nil)); end
  def search(query); end
  def signatures_at(filename, line, column); end
  def source_map_hash; end
  def source_maps; end
  def synchronized?; end
  def workspace; end

  private

  def api_map; end
  def catalog_inlock; end
  def find_external_requires(source_map); end
  def handle_file_not_found(filename, error); end
  def maybe_map(source); end
  def mutex; end
  def read(filename); end
  def source_map_external_require_hash; end

  class << self
    def load(directory = T.unsafe(nil), name = T.unsafe(nil)); end
  end
end

class Solargraph::Location
  def initialize(filename, range); end

  def ==(other); end
  def filename; end
  def inspect; end
  def range; end
  def to_hash; end
end

module Solargraph::Logging
  private

  def logger; end

  class << self
    def logger; end
  end
end

Solargraph::Logging::DEFAULT_LOG_LEVEL = T.let(T.unsafe(nil), Integer)
Solargraph::Logging::LOG_LEVELS = T.let(T.unsafe(nil), Hash)

class Solargraph::Page
  def initialize(directory = T.unsafe(nil)); end

  def render(template, layout: T.unsafe(nil), locals: T.unsafe(nil)); end

  class << self
    def select_template(directories, name); end
  end
end

class Solargraph::Page::Binder < ::OpenStruct
  def initialize(locals, render_method); end

  def escape(text); end
  def htmlify(text); end
  def ruby_to_html(code); end
end

module Solargraph::Parser
  extend ::Solargraph::Parser::Rubyvm::ClassMethods

  class << self
    def rubyvm?; end
  end
end

class Solargraph::Parser::CommentRipper < ::Ripper::SexpBuilderPP
  def initialize(src, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end

  def on_comment(*args); end
  def on_embdoc(*args); end
  def on_embdoc_beg(*args); end
  def on_embdoc_end(*args); end
  def parse; end
end

module Solargraph::Parser::Legacy; end

module Solargraph::Parser::Legacy::ClassMethods
  def chain(*args); end
  def chain_string(*args); end
  def infer_literal_node_type(node); end
  def inner_node_references(name, top); end
  def is_ast_node?(node); end
  def map(source); end
  def node_range(node); end
  def parse(code, filename = T.unsafe(nil), line = T.unsafe(nil)); end
  def parse_with_comments(code, filename = T.unsafe(nil)); end
  def parser; end
  def process_node(*args); end
  def references(source, name); end
  def returns_from(node); end
  def string_ranges(node); end
  def version; end
end

class Solargraph::Parser::Legacy::FlawedBuilder < ::Parser::Builders::Default
  def string_value(token); end
end

class Solargraph::Parser::Legacy::NodeChainer
  include ::Solargraph::Parser::Legacy::NodeMethods

  def initialize(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end

  def chain; end

  private

  def block_passed?(node); end
  def generate_links(n); end
  def hash_is_splatted?(node); end

  class << self
    def chain(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end
    def load_string(code); end
  end
end

Solargraph::Parser::Legacy::NodeChainer::Chain = Solargraph::Source::Chain

module Solargraph::Parser::Legacy::NodeMethods
  private

  def any_splatted_call?(nodes); end
  def call_nodes_from(node); end
  def const_nodes_from(node); end
  def convert_hash(node); end
  def drill_signature(node, signature); end
  def find_recipient_node(cursor); end
  def get_node_end_position(node); end
  def get_node_start_position(node); end
  def infer_literal_node_type(node); end
  def pack_name(node); end
  def repaired_find_recipient_node(cursor); end
  def returns_from(node); end
  def splatted_call?(node); end
  def splatted_hash?(node); end
  def unpack_name(node); end

  class << self
    def any_splatted_call?(nodes); end
    def call_nodes_from(node); end
    def const_nodes_from(node); end
    def convert_hash(node); end
    def drill_signature(node, signature); end
    def find_recipient_node(cursor); end
    def get_node_end_position(node); end
    def get_node_start_position(node); end
    def infer_literal_node_type(node); end
    def pack_name(node); end
    def repaired_find_recipient_node(cursor); end
    def returns_from(node); end
    def splatted_call?(node); end
    def splatted_hash?(node); end
    def unpack_name(node); end
  end
end

module Solargraph::Parser::Legacy::NodeMethods::DeepInference
  class << self
    def get_return_nodes(node); end

    private

    def get_return_nodes_from_children(parent); end
    def get_return_nodes_only(parent); end
    def reduce_to_value_nodes(nodes); end
  end
end

Solargraph::Parser::Legacy::NodeMethods::NIL_NODE = T.let(T.unsafe(nil), Parser::AST::Node)
module Solargraph::Parser::Legacy::NodeProcessors; end

class Solargraph::Parser::Legacy::NodeProcessors::AliasNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::ArgsNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end

  private

  def get_decl(node); end
end

class Solargraph::Parser::Legacy::NodeProcessors::BeginNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::BlockNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::CasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::CvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::DefNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::DefsNode < ::Solargraph::Parser::Legacy::NodeProcessors::DefNode
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::GvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::IvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::LvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::NamespaceNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::OrasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::ResbodyNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::SclassNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::SendNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end

  private

  def process_alias_method; end
  def process_attribute; end
  def process_autoload; end
  def process_extend; end
  def process_include; end
  def process_module_function; end
  def process_prepend; end
  def process_private_class_method; end
  def process_private_constant; end
  def process_require; end
  def process_visibility; end
end

class Solargraph::Parser::Legacy::NodeProcessors::SymNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

Solargraph::Parser::NodeMethods = Solargraph::Parser::Rubyvm::NodeMethods

module Solargraph::Parser::NodeProcessor
  class << self
    def process(node, region = T.unsafe(nil), pins = T.unsafe(nil), locals = T.unsafe(nil)); end
    def register(type, cls); end
  end
end

class Solargraph::Parser::NodeProcessor::Base
  def initialize(node, region, pins, locals); end

  def locals; end
  def node; end
  def pins; end
  def process; end
  def region; end

  private

  def block_pin(position); end
  def closure_pin(position); end
  def comments_for(node); end
  def get_node_location(node); end
  def named_path_pin(position); end
  def process_children(subregion = T.unsafe(nil)); end
end

class Solargraph::Parser::Region
  def initialize(source: T.unsafe(nil), closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end

  def closure; end
  def code_for(node); end
  def filename; end
  def lvars; end
  def scope; end
  def source; end
  def update(closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end
  def visibility; end
end

module Solargraph::Parser::Rubyvm; end

module Solargraph::Parser::Rubyvm::ClassMethods
  def chain(*args); end
  def chain_string(*args); end
  def infer_literal_node_type(node); end
  def inner_node_references(name, top); end
  def is_ast_node?(node); end
  def map(source); end
  def match_rubyvm_node_to_ref(top, name); end
  def node_range(node); end
  def parse(code, filename = T.unsafe(nil), line = T.unsafe(nil)); end
  def parse_with_comments(code, filename = T.unsafe(nil)); end
  def process_node(*args); end
  def recipient_node(tree); end
  def references(source, name); end
  def string_ranges(node); end
  def version; end
end

class Solargraph::Parser::Rubyvm::NodeChainer
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def initialize(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end

  def chain; end

  private

  def block_passed?(node); end
  def generate_links(n); end
  def hash_is_splatted?(node); end
  def node_to_argchains(node); end

  class << self
    def chain(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end
    def load_string(code); end
  end
end

Solargraph::Parser::Rubyvm::NodeChainer::Chain = Solargraph::Source::Chain

module Solargraph::Parser::Rubyvm::NodeMethods
  private

  def any_splatted_call?(nodes); end
  def call_nodes_from(node); end
  def const_nodes_from(node); end
  def convert_hash(node); end
  def find_recipient_node(cursor); end
  def infer_literal_node_type(node); end
  def node?(node); end
  def pack_name(node); end
  def returns_from(node); end
  def splatted_call?(node); end
  def splatted_hash?(node); end
  def splatted_node?(node); end
  def unpack_name(node); end

  class << self
    def any_splatted_call?(nodes); end
    def call_nodes_from(node); end
    def const_nodes_from(node); end
    def convert_hash(node); end
    def find_recipient_node(cursor); end
    def infer_literal_node_type(node); end
    def node?(node); end
    def pack_name(node); end
    def returns_from(node); end
    def splatted_call?(node); end
    def splatted_hash?(node); end
    def splatted_node?(node); end
    def unpack_name(node); end

    protected

    def maybe_adjust_cursor(cursor); end
    def synchronized_find_recipient_node(cursor); end
    def unsynchronized_find_recipient_node(cursor); end
  end
end

module Solargraph::Parser::Rubyvm::NodeMethods::DeepInference
  class << self
    def get_return_nodes(node); end

    private

    def get_return_nodes_from_children(parent); end
    def get_return_nodes_only(parent); end
    def reduce_to_value_nodes(nodes); end
  end
end

module Solargraph::Parser::Rubyvm::NodeProcessors; end

class Solargraph::Parser::Rubyvm::NodeProcessors::AliasNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ArgsNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end

  private

  def extract_name(var); end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BeginNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BlockNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefsNode < ::Solargraph::Parser::Rubyvm::NodeProcessors::DefNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::GvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::IvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::KwArgNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end

  private

  def require_keyword?(node); end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LitNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::NamespaceNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OptArgNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OrasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ResbodyNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end

  private

  def exception_variable?; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SclassNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ScopeNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SendNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end

  private

  def process_alias_method; end
  def process_attribute; end
  def process_autoload; end
  def process_extend; end
  def process_include; end
  def process_module_function; end
  def process_prepend; end
  def process_private_class_method; end
  def process_private_constant; end
  def process_require; end
  def process_visibility; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SymNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Snippet
  def initialize(range, text); end

  def range; end
  def text; end
end

class Solargraph::Parser::SyntaxError < ::StandardError; end
module Solargraph::Pin; end

class Solargraph::Pin::Base
  include ::Solargraph::Pin::Common
  include ::Solargraph::Pin::Conversions
  include ::Solargraph::Pin::Documenting

  def initialize(location: T.unsafe(nil), closure: T.unsafe(nil), name: T.unsafe(nil), comments: T.unsafe(nil)); end

  def ==(other); end
  def code_object; end
  def comments; end
  def completion_item_kind; end
  def deprecated?; end
  def directives; end
  def docstring; end
  def filename; end
  def identity; end
  def infer(api_map); end
  def inspect; end
  def location; end
  def macros; end
  def maybe_directives?; end
  def name; end
  def nearly?(other); end
  def path; end
  def probe(api_map); end
  def probed?; end
  def proxied?; end
  def proxy(return_type); end
  def realize(api_map); end
  def return_type; end
  def symbol_kind; end
  def to_s; end
  def try_merge!(pin); end
  def typify(api_map); end
  def variable?; end

  protected

  def probed=(_arg0); end
  def proxied=(_arg0); end
  def return_type=(_arg0); end

  private

  def collect_macros; end
  def compare_directives(dir1, dir2); end
  def compare_docstring_tags(d1, d2); end
  def compare_tags(tag1, tag2); end
  def parse_comments; end
end

class Solargraph::Pin::BaseVariable < ::Solargraph::Pin::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def initialize(assignment: T.unsafe(nil), **splat); end

  def ==(other); end
  def assignment; end
  def completion_item_kind; end
  def nil_assignment?; end
  def probe(api_map); end
  def return_type; end
  def symbol_kind; end
  def try_merge!(pin); end
  def variable?; end

  private

  def generate_complex_type; end
end

class Solargraph::Pin::Block < ::Solargraph::Pin::Closure
  def initialize(receiver: T.unsafe(nil), args: T.unsafe(nil), **splat); end

  def binder; end
  def parameter_names; end
  def parameters; end
  def rebind(api_map); end
  def receiver; end

  private

  def binder_or_nil(api_map); end
end

class Solargraph::Pin::ClassVariable < ::Solargraph::Pin::BaseVariable; end

class Solargraph::Pin::Closure < ::Solargraph::Pin::Base
  def initialize(scope: T.unsafe(nil), **splat); end

  def binder; end
  def context; end
  def gates; end
  def scope; end
end

module Solargraph::Pin::Common
  def binder; end
  def closure; end
  def comments; end
  def context; end
  def full_context; end
  def location; end
  def name; end
  def namespace; end
  def path; end
  def return_type; end

  private

  def find_context; end
end

class Solargraph::Pin::Constant < ::Solargraph::Pin::BaseVariable
  def initialize(visibility: T.unsafe(nil), **splat); end

  def completion_item_kind; end
  def path; end
  def return_type; end
  def symbol_kind; end
  def visibility; end

  private

  def generate_complex_type; end
end

module Solargraph::Pin::Conversions
  def completion_item; end
  def detail; end
  def link_documentation; end
  def reset_conversions; end
  def resolve_completion_item; end
  def signature_help; end
  def text_documentation; end

  private

  def escape_brackets(text); end
  def generate_link; end
end

module Solargraph::Pin::Documenting
  def documentation; end

  private

  def normalize_indentation(text); end
  def remove_odd_spaces(line); end
end

class Solargraph::Pin::Documenting::DocSection
  def initialize(code); end

  def code?; end
  def concat(text); end
  def plaintext; end
  def to_s; end

  private

  def escape_brackets(text); end
  def unescape_brackets(text); end
end

class Solargraph::Pin::DuckMethod < ::Solargraph::Pin::Method; end
class Solargraph::Pin::GlobalVariable < ::Solargraph::Pin::BaseVariable; end

class Solargraph::Pin::InstanceVariable < ::Solargraph::Pin::BaseVariable
  def binder; end
  def context; end
  def nearly?(other); end
  def scope; end
end

class Solargraph::Pin::Keyword < ::Solargraph::Pin::Base
  def initialize(name); end

  def name; end
end

class Solargraph::Pin::KeywordParam < ::Solargraph::Pin::Symbol; end

class Solargraph::Pin::LocalVariable < ::Solargraph::Pin::BaseVariable
  def initialize(assignment: T.unsafe(nil), presence: T.unsafe(nil), **splat); end

  def presence; end
  def try_merge!(pin); end
  def visible_at?(other_closure, other_loc); end
  def visible_from?(other, position); end

  private

  def match_named_closure(needle, haystack); end
  def match_tags(tag1, tag2); end
end

class Solargraph::Pin::Method < ::Solargraph::Pin::Closure
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def initialize(visibility: T.unsafe(nil), explicit: T.unsafe(nil), parameters: T.unsafe(nil), node: T.unsafe(nil), attribute: T.unsafe(nil), **splat); end

  def attribute?; end
  def completion_item_kind; end
  def documentation; end
  def explicit?; end
  def nearly?(other); end
  def node; end
  def overloads; end
  def parameter_names; end
  def parameters; end
  def path; end
  def probe(api_map); end
  def return_type; end
  def symbol_kind; end
  def try_merge!(pin); end
  def typify(api_map); end
  def visibility; end

  private

  def generate_complex_type; end
  def infer_from_iv(api_map); end
  def infer_from_return_nodes(api_map); end
  def method_body_node; end
  def resolve_reference(ref, api_map); end
  def see_reference(api_map); end
  def typify_from_super(api_map); end
end

class Solargraph::Pin::MethodAlias < ::Solargraph::Pin::Method
  def initialize(scope: T.unsafe(nil), original: T.unsafe(nil), **splat); end

  def original; end
  def path; end
  def scope; end
  def visibility; end
end

class Solargraph::Pin::Namespace < ::Solargraph::Pin::Closure
  def initialize(type: T.unsafe(nil), visibility: T.unsafe(nil), gates: T.unsafe(nil), **splat); end

  def binder; end
  def completion_item_kind; end
  def domains; end
  def full_context; end
  def gates; end
  def namespace; end
  def path; end
  def return_type; end
  def scope; end
  def symbol_kind; end
  def type; end
  def typify(api_map); end
  def visibility; end
end

class Solargraph::Pin::Parameter < ::Solargraph::Pin::LocalVariable
  def initialize(decl: T.unsafe(nil), asgn_code: T.unsafe(nil), **splat); end

  def asgn_code; end
  def decl; end
  def documentation; end
  def full; end
  def index; end
  def keyword?; end
  def kwrestarg?; end
  def probe(api_map); end
  def rest?; end
  def restarg?; end
  def return_type; end
  def try_merge!(pin); end
  def typify(api_map); end

  private

  def param_tag; end
  def resolve_reference(ref, api_map, skip); end
  def see_reference(heredoc, api_map, skip = T.unsafe(nil)); end
  def typify_block_param(api_map); end
  def typify_method_param(api_map); end
end

class Solargraph::Pin::ProxyType < ::Solargraph::Pin::Base
  def initialize(return_type: T.unsafe(nil), **splat); end

  def context; end

  class << self
    def anonymous(return_type); end
  end
end

Solargraph::Pin::ROOT_PIN = T.let(T.unsafe(nil), Solargraph::Pin::Namespace)
class Solargraph::Pin::Reference < ::Solargraph::Pin::Base; end
class Solargraph::Pin::Reference::Extend < ::Solargraph::Pin::Reference; end
class Solargraph::Pin::Reference::Include < ::Solargraph::Pin::Reference; end

class Solargraph::Pin::Reference::Override < ::Solargraph::Pin::Reference
  def initialize(location, name, tags, delete = T.unsafe(nil)); end

  def delete; end
  def tags; end

  class << self
    def from_comment(name, comment); end
    def method_return(name, *tags, delete: T.unsafe(nil)); end
  end
end

class Solargraph::Pin::Reference::Prepend < ::Solargraph::Pin::Reference; end

class Solargraph::Pin::Reference::Require < ::Solargraph::Pin::Reference
  def initialize(location, name); end
end

class Solargraph::Pin::Reference::Superclass < ::Solargraph::Pin::Reference; end

class Solargraph::Pin::Singleton < ::Solargraph::Pin::Closure
  def initialize(name: T.unsafe(nil), location: T.unsafe(nil), closure: T.unsafe(nil)); end
end

class Solargraph::Pin::Symbol < ::Solargraph::Pin::Base
  def initialize(location, name); end

  def comments; end
  def completion_item_kind; end
  def deprecated?; end
  def directives; end
  def namespace; end
  def path; end
  def return_type; end
  def visibility; end
end

class Solargraph::Position
  def initialize(line, character); end

  def ==(other); end
  def character; end
  def column; end
  def inspect; end
  def line; end
  def to_hash; end

  class << self
    def from_offset(text, offset); end
    def line_char_to_offset(text, line, character); end
    def normalize(object); end
    def to_offset(text, position); end
  end
end

class Solargraph::Range
  def initialize(start, ending); end

  def ==(other); end
  def contain?(position); end
  def ending; end
  def include?(position); end
  def inspect; end
  def start; end
  def to_hash; end

  class << self
    def from_expr(expr); end
    def from_node(node); end
    def from_to(l1, c1, l2, c2); end
  end
end

module Solargraph::ServerMethods
  def available_port; end
end

class Solargraph::Shell < ::Thor
  include ::Solargraph::ServerMethods

  def available_cores; end
  def bundle; end
  def clear; end
  def config(directory = T.unsafe(nil)); end
  def download_core(version = T.unsafe(nil)); end
  def list_cores; end
  def rdoc(gem, version = T.unsafe(nil)); end
  def reporters; end
  def scan; end
  def socket; end
  def stdio; end
  def typecheck(*files); end
  def uncache(*gems); end
  def version; end

  private

  def pin_description(pin); end
end

class Solargraph::Source
  include ::Solargraph::Source::EncodingFixes

  def initialize(code, filename = T.unsafe(nil), version = T.unsafe(nil)); end

  def associated_comments; end
  def at(range); end
  def code; end
  def code_for(node); end
  def comment_at?(position); end
  def comments; end
  def comments_for(node); end
  def cursor_at(position); end
  def error_ranges; end
  def filename; end
  def finish_synchronize; end
  def folding_ranges; end
  def from_to(l1, c1, l2, c2); end
  def location; end
  def node; end
  def node_at(line, column); end
  def parsed?; end
  def references(name); end
  def repaired?; end
  def start_synchronize(updater); end
  def string_at?(position); end
  def string_ranges; end
  def synchronize(updater); end
  def synchronized?; end
  def tree_at(line, column); end
  def version; end

  protected

  def code=(val); end
  def comments=(_arg0); end
  def error_ranges=(_arg0); end
  def filename=(_arg0); end
  def last_updater; end
  def last_updater=(_arg0); end
  def node=(_arg0); end
  def parsed=(_arg0); end
  def repaired; end
  def repaired=(_arg0); end
  def synchronized=(_arg0); end
  def version=(_arg0); end

  private

  def code_lines; end
  def colonized(range, position, node); end
  def comment_ranges; end
  def first_not_empty_from(line); end
  def foldable_comment_block_ranges; end
  def inner_folding_ranges(top, result = T.unsafe(nil), parent = T.unsafe(nil)); end
  def inner_tree_at(node, position, stack); end
  def string_nodes; end
  def string_nodes_in(n); end
  def stringified_comments; end
  def stringify_comment_array(comments); end

  class << self
    def load(filename); end
    def load_string(code, filename = T.unsafe(nil), version = T.unsafe(nil)); end
    def parse_docstring(comments); end
  end
end

class Solargraph::Source::Chain
  def initialize(links, node = T.unsafe(nil), splat = T.unsafe(nil)); end

  def base; end
  def constant?; end
  def define(api_map, name_pin, locals); end
  def defined?; end
  def infer(api_map, name_pin, locals); end
  def links; end
  def literal?; end
  def node; end
  def splat?; end
  def undefined?; end

  private

  def infer_first_defined(pins, context, api_map); end
end

class Solargraph::Source::Chain::BlockVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Call < ::Solargraph::Source::Chain::Link
  def initialize(word, arguments = T.unsafe(nil), with_block = T.unsafe(nil)); end

  def arguments; end
  def resolve(api_map, name_pin, locals); end
  def with_block?; end
  def word; end

  private

  def arguments_match(arguments, parameters); end
  def extra_return_type(docstring, context); end
  def inferred_pins(pins, api_map, context, locals); end
  def inner_process_macro(pin, macro, api_map, context, locals); end
  def process_directive(pin, api_map, context, locals); end
  def process_macro(pin, api_map, context, locals); end
  def super_pins(api_map, name_pin); end
end

class Solargraph::Source::Chain::ClassVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Constant < ::Solargraph::Source::Chain::Link
  def initialize(word); end

  def resolve(api_map, name_pin, locals); end

  private

  def crawl_gates(pin); end
  def deep_constant_type(gate, api_map); end
  def first_pin_type(pins, api_map); end
end

class Solargraph::Source::Chain::GlobalVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Hash < ::Solargraph::Source::Chain::Literal
  def initialize(type, splatted = T.unsafe(nil)); end

  def resolve(api_map, name_pin, locals); end
  def splatted?; end
  def word; end
end

class Solargraph::Source::Chain::Head < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::InstanceVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Link
  def initialize(word = T.unsafe(nil)); end

  def ==(other); end
  def clone_body; end
  def clone_head; end
  def constant?; end
  def head?; end
  def last_context; end
  def last_context=(_arg0); end
  def resolve(api_map, name_pin, locals); end
  def undefined?; end
  def word; end

  protected

  def mark_head(bool); end
end

class Solargraph::Source::Chain::Literal < ::Solargraph::Source::Chain::Link
  def initialize(type); end

  def resolve(api_map, name_pin, locals); end
  def word; end
end

class Solargraph::Source::Chain::Or < ::Solargraph::Source::Chain::Link
  def initialize(links); end

  def resolve(api_map, name_pin, locals); end
  def word; end
end

Solargraph::Source::Chain::UNDEFINED_CALL = T.let(T.unsafe(nil), Solargraph::Source::Chain::Call)
Solargraph::Source::Chain::UNDEFINED_CONSTANT = T.let(T.unsafe(nil), Solargraph::Source::Chain::Constant)

class Solargraph::Source::Chain::Variable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::ZSuper < ::Solargraph::Source::Chain::Call
  def initialize(word, with_block = T.unsafe(nil)); end

  def arguments; end
  def resolve(api_map, name_pin, locals); end
  def word; end
end

class Solargraph::Source::Change
  include ::Solargraph::Source::EncodingFixes

  def initialize(range, new_text); end

  def new_text; end
  def range; end
  def repair(text); end
  def write(text, nullable = T.unsafe(nil)); end

  private

  def commit(text, insert); end
end

class Solargraph::Source::Cursor
  def initialize(source, position); end

  def argument?; end
  def chain; end
  def comment?; end
  def end_of_word; end
  def filename; end
  def node; end
  def node_position; end
  def offset; end
  def position; end
  def range; end
  def receiver; end
  def recipient; end
  def recipient_node; end
  def source; end
  def start_of_constant?; end
  def start_of_word; end
  def string?; end
  def word; end

  private

  def end_word_pattern; end
  def start_word_pattern; end
end

module Solargraph::Source::EncodingFixes
  private

  def normalize(string); end

  class << self
    def normalize(string); end
  end
end

Solargraph::Source::FOLDING_NODE_TYPES = T.let(T.unsafe(nil), Array)

class Solargraph::Source::SourceChainer
  def initialize(source, position); end

  def chain; end

  private

  def end_of_phrase; end
  def fixed_phrase; end
  def fixed_position; end
  def get_offset(line, column); end
  def get_signature_data_at(index); end
  def offset; end
  def phrase; end
  def position; end
  def signature_data; end
  def source; end
  def string?; end

  class << self
    def chain(source, position); end
  end
end

class Solargraph::Source::Updater
  def initialize(filename, version, changes); end

  def changes; end
  def filename; end
  def repair(text); end
  def version; end
  def write(text, nullable = T.unsafe(nil)); end
end

class Solargraph::SourceMap
  def initialize(source, pins, locals); end

  def code; end
  def cursor_at(position); end
  def document_symbols; end
  def environ; end
  def filename; end
  def first_pin(path); end
  def locals; end
  def locals_at(location); end
  def locate_block_pin(line, character); end
  def locate_named_path_pin(line, character); end
  def locate_pins(location); end
  def pins; end
  def pins_by_class(klass); end
  def query_symbols(query); end
  def rebindable_method_names; end
  def references(name); end
  def requires; end
  def source; end
  def try_merge!(other_map); end

  private

  def _locate_pin(line, character, *klasses); end
  def fuzzy_string_match(str1, str2); end

  class << self
    def load(filename); end
    def load_string(code, filename = T.unsafe(nil)); end
    def map(source); end
  end
end

class Solargraph::SourceMap::Clip
  def initialize(api_map, cursor); end

  def complete; end
  def define; end
  def gates; end
  def in_block?; end
  def infer; end
  def locals; end
  def signify; end
  def translate(phrase); end

  private

  def api_map; end
  def block; end
  def code_complete; end
  def complete_keyword_parameters; end
  def context_pin; end
  def cursor; end
  def package_completions(result); end
  def source_map; end
  def tag_complete; end
  def yielded_self_pins; end
end

class Solargraph::SourceMap::Completion
  def initialize(pins, range); end

  def pins; end
  def range; end
end

class Solargraph::SourceMap::Mapper
  def closure_at(position); end
  def find_directive_line_number(comment, tag, start); end
  def map(source); end
  def pins; end
  def process_comment(source_position, comment_position, comment); end
  def process_comment_directives; end
  def process_directive(source_position, comment_position, directive); end
  def remove_inline_comment_hashes(comment); end
  def unmap(filename, code); end

  class << self
    def map(source); end
  end
end

Solargraph::SourceMap::Mapper::MACRO_REGEXP = T.let(T.unsafe(nil), Regexp)
class Solargraph::SourceNotAvailableError < ::StandardError; end

class Solargraph::TypeChecker
  include ::Solargraph::TypeChecker::Checks
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def initialize(filename, api_map: T.unsafe(nil), level: T.unsafe(nil)); end

  def api_map; end
  def filename; end
  def problems; end
  def rules; end
  def source_map; end

  private

  def abstract?(pin); end
  def all_variables; end
  def argument_problems_for(chain, api_map, block_pin, locals, location); end
  def arity_problems_for(pin, arguments, location); end
  def call_problems; end
  def const_problems; end
  def declared_externally?(pin); end
  def external?(pin); end
  def fake_args_for(pin); end
  def first_param_hash(pins); end
  def ignored_pins; end
  def internal?(pin); end
  def internal_or_core?(pin); end
  def kwarg_problems_for(argchain, api_map, block_pin, locals, location, pin, params, first); end
  def kwrestarg_problems_for(api_map, block_pin, locals, location, pin, params, kwargs); end
  def method_param_type_problems_for(pin); end
  def method_return_type_problems_for(pin); end
  def method_tag_problems; end
  def optional_param_count(pin); end
  def param_hash(pin); end
  def required_param_count(pin); end
  def variable_type_tag_problems; end
  def virtual_pin?(pin); end

  class << self
    def load(filename, level = T.unsafe(nil)); end
    def load_string(code, filename = T.unsafe(nil), level = T.unsafe(nil)); end
  end
end

module Solargraph::TypeChecker::Checks
  private

  def any_types_match?(api_map, expected, inferred); end
  def duck_types_match?(api_map, expected, inferred); end
  def either_way?(api_map, cls1, cls2); end
  def fuzz(type); end
  def types_match?(api_map, expected, inferred); end

  class << self
    def any_types_match?(api_map, expected, inferred); end
    def duck_types_match?(api_map, expected, inferred); end
    def either_way?(api_map, cls1, cls2); end
    def fuzz(type); end
    def types_match?(api_map, expected, inferred); end
  end
end

class Solargraph::TypeChecker::ParamDef
  def initialize(name, type); end

  def name; end
  def type; end

  class << self
    def from(pin); end
  end
end

class Solargraph::TypeChecker::Problem
  def initialize(location, message, pin: T.unsafe(nil), suggestion: T.unsafe(nil)); end

  def location; end
  def message; end
  def pin; end
  def suggestion; end
end

class Solargraph::TypeChecker::Rules
  def initialize(level); end

  def ignore_all_undefined?; end
  def level; end
  def must_tag_or_infer?; end
  def rank; end
  def require_type_tags?; end
  def validate_calls?; end
  def validate_consts?; end
  def validate_tags?; end
end

Solargraph::TypeChecker::Rules::LEVELS = T.let(T.unsafe(nil), Hash)
Solargraph::VERSION = T.let(T.unsafe(nil), String)
Solargraph::VIEWS_PATH = T.let(T.unsafe(nil), String)

class Solargraph::Workspace
  def initialize(directory = T.unsafe(nil), config = T.unsafe(nil)); end

  def config; end
  def directory; end
  def filenames; end
  def gemnames; end
  def gemspec?; end
  def gemspecs; end
  def has_file?(filename); end
  def merge(source); end
  def remove(filename); end
  def require_paths; end
  def source(filename); end
  def source_gems; end
  def sources; end
  def synchronize!(updater); end
  def would_merge?(filename); end
  def would_require?(path); end

  private

  def configured_require_paths; end
  def generate_require_paths; end
  def load_sources; end
  def require_plugins; end
  def source_hash; end
end

class Solargraph::Workspace::Config
  def initialize(directory = T.unsafe(nil)); end

  def allow?(filename); end
  def calculated; end
  def directory; end
  def domains; end
  def excluded; end
  def formatter; end
  def included; end
  def max_files; end
  def plugins; end
  def raw_data; end
  def reporters; end
  def require_paths; end
  def required; end

  private

  def config_data; end
  def default_config; end
  def excluded_directories; end
  def glob_is_directory?(glob); end
  def glob_to_directory(glob); end
  def global_config_path; end
  def process_exclusions(globs); end
  def process_globs(globs); end
  def read_config(config_path = T.unsafe(nil)); end
  def workspace_config_path; end
end

Solargraph::Workspace::Config::MAX_FILES = T.let(T.unsafe(nil), Integer)
class Solargraph::WorkspaceTooLargeError < ::RuntimeError; end
Solargraph::YARDOC_PATH = T.let(T.unsafe(nil), String)
Solargraph::YARD_EXTENSION_FILE = T.let(T.unsafe(nil), String)

class Solargraph::YardMap
  include ::Solargraph::ApiMap::BundlerMethods

  def initialize(required: T.unsafe(nil), directory: T.unsafe(nil), source_gems: T.unsafe(nil), with_dependencies: T.unsafe(nil)); end

  def base_required; end
  def change(new_requires, new_directory, new_source_gems); end
  def core_pins; end
  def directory; end
  def load_yardoc(y); end
  def path_pin(path); end
  def pins; end
  def rebindable_method_names; end
  def require_reference(path); end
  def required; end
  def stdlib_paths; end
  def stdlib_pins; end
  def unresolved_requires; end
  def with_dependencies=(_arg0); end
  def with_dependencies?; end
  def yardocs; end

  private

  def add_gem_dependencies(spec); end
  def cache; end
  def load_core_pins; end
  def load_stdlib_pins(base); end
  def pin_class_hash; end
  def pins_by_class(klass); end
  def process_gemsets; end
  def process_requires; end
  def process_yardoc(y, spec = T.unsafe(nil)); end
  def read_core_and_save_cache(yd, ser); end
  def read_stdlib_and_save_cache(base, ser); end
  def recurse_namespace_object(ns); end
  def spec_for_require(path); end
  def yardoc_file_for_spec(spec); end
end

class Solargraph::YardMap::Cache
  def initialize; end

  def get_path_pins(path); end
  def set_path_pins(path, pins); end
end

module Solargraph::YardMap::CoreDocs
  class << self
    def available; end
    def best_download(current = T.unsafe(nil)); end
    def best_match; end
    def cache_dir; end
    def clear; end
    def download(version); end
    def require_minimum; end
    def valid?(ver); end
    def versions; end
    def yardoc_file(ver = T.unsafe(nil)); end
    def yardoc_stdlib_file(ver = T.unsafe(nil)); end

    private

    def install_archive(filename); end
  end
end

Solargraph::YardMap::CoreDocs::DEFAULT = T.let(T.unsafe(nil), String)
Solargraph::YardMap::CoreDocs::SOURCE = T.let(T.unsafe(nil), String)
module Solargraph::YardMap::CoreFills; end
Solargraph::YardMap::CoreFills::ALL = T.let(T.unsafe(nil), Array)
Solargraph::YardMap::CoreFills::KEYWORDS = T.let(T.unsafe(nil), Array)
Solargraph::YardMap::CoreFills::OVERRIDES = T.let(T.unsafe(nil), Array)
Solargraph::YardMap::CoreFills::Override = Solargraph::Pin::Reference::Override
Solargraph::YardMap::CoreFills::PINS = T.let(T.unsafe(nil), Array)

module Solargraph::YardMap::CoreGen
  class << self
    def generate_docs(ruby_dir, dest_dir); end
    def generate_gzip(ruby_dir, ver_name = T.unsafe(nil), dest_dir = T.unsafe(nil)); end

    private

    def gzip(dir, dst); end
  end
end

module Solargraph::YardMap::Helpers
  private

  def object_location(code_object, spec); end

  class << self
    def object_location(code_object, spec); end
  end
end

class Solargraph::YardMap::Mapper
  def initialize(code_objects, spec = T.unsafe(nil)); end

  def map; end

  private

  def generate_pins(code_object); end
end

module Solargraph::YardMap::Mapper::ToConstant
  extend ::Solargraph::YardMap::Helpers

  class << self
    def make(code_object, closure = T.unsafe(nil), spec = T.unsafe(nil)); end
  end
end

module Solargraph::YardMap::Mapper::ToMethod
  extend ::Solargraph::YardMap::Helpers

  class << self
    def make(code_object, name = T.unsafe(nil), scope = T.unsafe(nil), visibility = T.unsafe(nil), closure = T.unsafe(nil), spec = T.unsafe(nil)); end

    private

    def arg_name(a); end
    def arg_type(a); end
    def get_parameters(code_object, location, comments); end
  end
end

module Solargraph::YardMap::Mapper::ToNamespace
  extend ::Solargraph::YardMap::Helpers

  class << self
    def make(code_object, spec, closure = T.unsafe(nil)); end
  end
end

class Solargraph::YardMap::NoYardocError < ::StandardError; end

module Solargraph::YardMap::RdocToYard
  extend ::Solargraph::ApiMap::SourceToYard

  class << self
    def base_name(mod); end
    def commentary(cmnt); end
    def find_file(obj); end
    def locate(obj); end
    def run(spec, cache_dir: T.unsafe(nil)); end
  end
end

module Solargraph::YardMap::StdlibFills
  class << self
    def get(path); end
  end
end

Solargraph::YardMap::StdlibFills::LIBS = T.let(T.unsafe(nil), Hash)
Solargraph::YardMap::StdlibFills::Override = Solargraph::Pin::Reference::Override

class Solargraph::YardMap::ToMethod
  extend ::Solargraph::YardMap::Helpers

  def make(code_object, name = T.unsafe(nil), scope = T.unsafe(nil), visibility = T.unsafe(nil), closure = T.unsafe(nil), spec = T.unsafe(nil)); end
end

module Solargraph::YardMap::ToMethod::InnerMethods
  private

  def arg_name(a); end
  def arg_type(a); end
  def get_parameters(code_object, location, comments); end

  class << self
    def arg_name(a); end
    def arg_type(a); end
    def get_parameters(code_object, location, comments); end
  end
end
