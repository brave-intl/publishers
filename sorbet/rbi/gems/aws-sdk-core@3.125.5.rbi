# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aws-sdk-core` gem.
# Please instead update this file by running `bin/tapioca gem aws-sdk-core`.

module Aws
  class << self
    def config; end
    def config=(config); end
    def eager_autoload!(*args); end
    def empty_connection_pools!; end
    def partition(partition_name); end
    def partitions; end
    def shared_config; end
    def use_bundled_cert!; end
  end
end

class Aws::ARN
  def initialize(options = T.unsafe(nil)); end

  def account_id; end
  def partition; end
  def region; end
  def resource; end
  def service; end
  def to_h; end
  def to_s; end
  def valid?; end
end

module Aws::ARNParser
  class << self
    def arn?(str); end
    def parse(arn_str); end
  end
end

class Aws::AssumeRoleCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials

  def initialize(options = T.unsafe(nil)); end

  def client; end

  private

  def refresh; end

  class << self
    def assume_role_options; end
  end
end

class Aws::AssumeRoleWebIdentityCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials

  def initialize(options = T.unsafe(nil)); end

  def client; end

  private

  def _session_name; end
  def _token_from_file(path); end
  def refresh; end

  class << self
    def assume_role_web_identity_options; end
  end
end

module Aws::AsyncClientStubs
  include ::Aws::ClientStubs

  def send_events; end
  def setup_stubbing; end
end

class Aws::AsyncClientStubs::StubStream
  def initialize; end

  def close; end
  def closed?; end
  def data(bytes, options = T.unsafe(nil)); end
  def send_events; end
  def send_events=(_arg0); end
  def state; end
end

module Aws::Binary; end

class Aws::Binary::DecodeHandler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def attach_eventstream_listeners(context, rules); end
  def eventstream?(ctx); end
end

class Aws::Binary::EncodeHandler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def eventstream_input?(ctx); end
end

class Aws::Binary::EventBuilder
  include ::Seahorse::Model::Shapes

  def initialize(serializer_class, rules); end

  def apply(event_type, params); end

  private

  def _build_payload(streaming, ref, value); end
  def _content_type(shape); end
  def _event_stream_message(event_ref, params); end
  def _header_value_type(shape, value); end
end

class Aws::Binary::EventParser
  include ::Seahorse::Model::Shapes

  def initialize(parser_class, rules, error_refs, output_ref); end

  def apply(raw_event); end

  private

  def eventpayload_streaming?(ref); end
  def parse(raw_event); end
  def parse_error_event(raw_event); end
  def parse_event(raw_event); end
  def parse_exception(raw_event); end
  def parse_payload(body, rules); end
end

class Aws::Binary::EventStreamDecoder
  def initialize(protocol, rules, output_ref, error_refs, io, event_stream_handler = T.unsafe(nil)); end

  def events; end
  def write(chunk); end

  private

  def emit_event(raw_event); end
  def extract_stream_class(type_class); end
  def parser_class(protocol); end
end

class Aws::Binary::EventStreamEncoder
  def initialize(protocol, rules, input_ref, signer); end

  def encode(event_type, params); end
  def prior_signature; end
  def prior_signature=(_arg0); end
  def rules; end

  private

  def serializer_class(protocol); end
end

Aws::CORE_GEM_VERSION = T.let(T.unsafe(nil), String)
module Aws::ClientSideMonitoring; end

class Aws::ClientSideMonitoring::Publisher
  def initialize(opts = T.unsafe(nil)); end

  def agent_host; end
  def agent_host=(value); end
  def agent_port; end
  def agent_port=(value); end
  def publish(request_metrics); end
  def send_datagram(msg); end
end

class Aws::ClientSideMonitoring::RequestMetrics
  def initialize(opts = T.unsafe(nil)); end

  def add_call_attempt(attempt); end
  def api_call; end
  def api_call_attempts; end
  def build_call_attempt(opts = T.unsafe(nil)); end
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCall
  def initialize(service, api, client_id, version, timestamp, region); end

  def api; end
  def attempt_count; end
  def client_id; end
  def complete(opts = T.unsafe(nil)); end
  def final_aws_exception; end
  def final_aws_exception_message; end
  def final_http_status_code; end
  def final_sdk_exception; end
  def final_sdk_exception_message; end
  def latency; end
  def max_retries_exceeded; end
  def region; end
  def service; end
  def timestamp; end
  def to_json(*a); end
  def user_agent; end
  def version; end

  private

  def _truncate(document); end
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCallAttempt
  def initialize(service, api, client_id, version, timestamp, fqdn, region, user_agent, access_key, session_token); end

  def access_key; end
  def api; end
  def aws_exception; end
  def aws_exception=(_arg0); end
  def aws_exception_msg; end
  def aws_exception_msg=(_arg0); end
  def client_id; end
  def fqdn; end
  def fqdn=(_arg0); end
  def http_status_code; end
  def http_status_code=(_arg0); end
  def region; end
  def region=(_arg0); end
  def request_latency; end
  def request_latency=(_arg0); end
  def sdk_exception; end
  def sdk_exception=(_arg0); end
  def sdk_exception_msg; end
  def sdk_exception_msg=(_arg0); end
  def service; end
  def session_token; end
  def timestamp; end
  def to_json(*a); end
  def user_agent; end
  def version; end
  def x_amz_id_2; end
  def x_amz_id_2=(_arg0); end
  def x_amz_request_id; end
  def x_amz_request_id=(_arg0); end
  def x_amzn_request_id; end
  def x_amzn_request_id=(_arg0); end

  private

  def _truncate(document); end
end

Aws::ClientSideMonitoring::RequestMetrics::FIELD_MAX_LENGTH = T.let(T.unsafe(nil), Hash)

module Aws::ClientStubs
  def api_requests(options = T.unsafe(nil)); end
  def next_stub(context); end
  def setup_stubbing; end
  def stub_data(operation_name, data = T.unsafe(nil)); end
  def stub_responses(operation_name, *stubs); end

  private

  def apply_stubs(operation_name, stubs); end
  def convert_stub(operation_name, stub); end
  def data_to_http_resp(operation_name, data); end
  def default_stub(operation_name); end
  def hash_to_http_resp(data); end
  def http_response_stub(operation_name, data); end
  def protocol_helper; end
  def service_error_stub(error_code); end
end

module Aws::CredentialProvider
  def credentials; end
  def set?; end
end

class Aws::CredentialProviderChain
  def initialize(config = T.unsafe(nil)); end

  def resolve; end

  private

  def assume_role_credentials(options); end
  def assume_role_web_identity_credentials(options); end
  def assume_role_with_profile(options, profile_name); end
  def determine_profile_name(options); end
  def env_credentials(_options); end
  def envar(keys); end
  def instance_profile_credentials(options); end
  def process_credentials(options); end
  def providers; end
  def shared_credentials(options); end
  def sso_credentials(options); end
  def static_credentials(options); end
  def static_profile_assume_role_credentials(options); end
  def static_profile_assume_role_web_identity_credentials(options); end
  def static_profile_credentials(options); end
  def static_profile_process_credentials(options); end
  def static_profile_sso_credentials(options); end
end

class Aws::Credentials
  def initialize(access_key_id, secret_access_key, session_token = T.unsafe(nil)); end

  def access_key_id; end
  def credentials; end
  def inspect; end
  def secret_access_key; end
  def session_token; end
  def set?; end
end

class Aws::DefaultsModeConfigResolver
  def initialize(sdk_defaults, cfg); end

  def resolve(option_name); end

  private

  def application_current_region; end
  def env_mobile?; end
  def resolve_auto_mode; end
  def resolve_for_mode(name, mode); end
  def resolved_mode; end
end

Aws::DefaultsModeConfigResolver::CFG_OPTIONS = T.let(T.unsafe(nil), Hash)
module Aws::DefaultsModeConfiguration; end
Aws::DefaultsModeConfiguration::SDK_DEFAULT_CONFIGURATION = T.let(T.unsafe(nil), Hash)

module Aws::Deprecations
  def deprecated(method, options = T.unsafe(nil)); end
end

class Aws::EC2Metadata
  def initialize(options = T.unsafe(nil)); end

  def get(path); end

  private

  def backoff(backoff); end
  def fetch_token; end
  def http_get(connection, path, token); end
  def http_put(connection, ttl); end
  def open_connection; end
  def resolve_endpoint(endpoint, endpoint_mode); end
  def retry_errors(options = T.unsafe(nil), &_block); end
end

Aws::EC2Metadata::METADATA_TOKEN_PATH = T.let(T.unsafe(nil), String)
class Aws::EC2Metadata::MetadataNotFoundError < ::RuntimeError; end
class Aws::EC2Metadata::RequestForbiddenError < ::RuntimeError; end

class Aws::EC2Metadata::Token
  def initialize(options = T.unsafe(nil)); end

  def expired?; end
  def value; end
end

class Aws::EC2Metadata::TokenExpiredError < ::RuntimeError; end
class Aws::EC2Metadata::TokenRetrievalError < ::RuntimeError; end

class Aws::ECSCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials

  def initialize(options = T.unsafe(nil)); end

  def retries; end

  private

  def backoff(backoff); end
  def get_credentials; end
  def http_get(connection, path); end
  def open_connection; end
  def refresh; end
  def retry_errors(error_classes, options = T.unsafe(nil), &block); end
end

Aws::ECSCredentials::NETWORK_ERRORS = T.let(T.unsafe(nil), Array)
class Aws::ECSCredentials::Non200Response < ::RuntimeError; end

class Aws::EagerLoader
  def initialize; end

  def load(klass_or_module); end
  def loaded; end
end

class Aws::EmptyStructure < ::Struct
  include ::Aws::Structure
end

class Aws::EndpointCache
  def initialize(options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def delete_polling_thread(key); end
  def extract_key(ctx); end
  def key?(key); end
  def max_entries; end
  def max_threads; end
  def pool; end
  def stop_polling!; end
  def threads_key?(key); end
  def update(key, ctx); end
  def update_polling_pool(key, thread); end

  private

  def _endpoint_operation_identifier(ctx); end
  def _request_endpoint(ctx); end
end

class Aws::EndpointCache::Endpoint
  def initialize(options); end

  def address; end
  def expired?; end
end

Aws::EndpointCache::Endpoint::CACHE_PERIOD = T.let(T.unsafe(nil), Integer)
Aws::EndpointCache::MAX_ENTRIES = T.let(T.unsafe(nil), Integer)
Aws::EndpointCache::MAX_THREADS = T.let(T.unsafe(nil), Integer)
module Aws::Errors; end
class Aws::Errors::ChecksumError < ::RuntimeError; end
class Aws::Errors::CredentialSourceConflictError < ::RuntimeError; end

module Aws::Errors::DynamicErrors
  def const_missing(constant); end
  def error_class(error_code); end

  private

  def error_class_constant(error_code); end
  def error_const_set?(constant); end
  def set_error_constant(constant); end

  class << self
    def extended(submodule); end
  end
end

class Aws::Errors::EndpointDiscoveryError < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::EventError < ::RuntimeError
  def initialize(event_type, code, message); end

  def error_code; end
  def error_message; end
  def event_type; end
end

class Aws::Errors::EventStreamBuilderError < ::RuntimeError; end
class Aws::Errors::EventStreamParserError < ::RuntimeError; end
class Aws::Errors::InvalidARNError < ::RuntimeError; end

class Aws::Errors::InvalidARNPartitionError < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::InvalidARNRegionError < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::InvalidCredentialSourceError < ::RuntimeError; end
class Aws::Errors::InvalidProcessCredentialsPayload < ::RuntimeError; end

class Aws::Errors::InvalidRegionError < ::ArgumentError
  def initialize(*args); end

  private

  def possible_regions; end
end

class Aws::Errors::InvalidSSOCredentials < ::RuntimeError; end

class Aws::Errors::MetadataParserError < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::MissingContentLength < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::MissingCredentialsError < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::MissingEndpointHostLabelValue < ::RuntimeError
  def initialize(name); end
end

class Aws::Errors::MissingRegionError < ::ArgumentError
  def initialize(*args); end
end

class Aws::Errors::MissingWebIdentityTokenFile < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::NoSourceCredentialsError < ::RuntimeError; end
class Aws::Errors::NoSourceProfileError < ::RuntimeError; end

class Aws::Errors::NoSuchEndpointError < ::RuntimeError
  def initialize(options = T.unsafe(nil)); end

  def context; end
  def endpoint; end
  def original_error; end

  private

  def possible_regions; end
end

class Aws::Errors::NoSuchProfileError < ::RuntimeError; end
class Aws::Errors::NonSupportedRubyVersionError < ::RuntimeError; end

class Aws::Errors::RetryCapacityNotAvailableError < ::RuntimeError
  def initialize(*args); end
end

class Aws::Errors::ServiceError < ::RuntimeError
  def initialize(context, message, data = T.unsafe(nil)); end

  def code; end
  def context; end
  def data; end
  def retryable?; end
  def throttling?; end

  class << self
    def code; end
    def code=(_arg0); end
  end
end

class Aws::Errors::SignalEventError < ::RuntimeError; end
class Aws::Errors::SourceProfileCircularReferenceError < ::RuntimeError; end

class Aws::EventEmitter
  def initialize; end

  def emit(type, params); end
  def encoder; end
  def encoder=(_arg0); end
  def on(type, callback); end
  def signal(type, event); end
  def signal_queue; end
  def signal_queue=(_arg0); end
  def stream; end
  def stream=(_arg0); end
  def validate_event; end
  def validate_event=(_arg0); end

  private

  def _ready_for_events?; end
end

class Aws::IniParser
  class << self
    def ini_parse(raw); end
  end
end

class Aws::InstanceProfileCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials

  def initialize(options = T.unsafe(nil)); end

  def retries; end

  private

  def _metadata_disabled?; end
  def backoff(backoff); end
  def get_credentials; end
  def http_get(connection, path, token = T.unsafe(nil)); end
  def http_put(connection, path, ttl); end
  def open_connection; end
  def refresh; end
  def resolve_endpoint(options, endpoint_mode); end
  def resolve_endpoint_mode(options); end
  def retry_errors(error_classes, options = T.unsafe(nil), &_block); end
  def token_set?; end
end

Aws::InstanceProfileCredentials::METADATA_PATH_BASE = T.let(T.unsafe(nil), String)
Aws::InstanceProfileCredentials::METADATA_TOKEN_PATH = T.let(T.unsafe(nil), String)
Aws::InstanceProfileCredentials::NETWORK_ERRORS = T.let(T.unsafe(nil), Array)
class Aws::InstanceProfileCredentials::Non200Response < ::RuntimeError; end

class Aws::InstanceProfileCredentials::Token
  def initialize(value, ttl); end

  def expired?; end
  def value; end
end

class Aws::InstanceProfileCredentials::TokenExpiredError < ::RuntimeError; end
class Aws::InstanceProfileCredentials::TokenRetrivalError < ::RuntimeError; end

module Aws::Json
  class << self
    def dump(value); end
    def load(json); end
    def load_file(path); end

    private

    def select_engine; end
  end
end

class Aws::Json::Builder
  include ::Seahorse::Model::Shapes

  def initialize(rules); end

  def serialize(params); end
  def to_json(params); end

  private

  def encode(blob); end
  def format(ref, value); end
  def list(ref, values); end
  def map(ref, values); end
  def structure(ref, values); end
  def timestamp(ref, value); end
end

Aws::Json::ENGINE = Aws::Json::JSONEngine

class Aws::Json::ErrorHandler < ::Aws::Xml::ErrorHandler
  def call(context); end

  private

  def error_code(json, context); end
  def error_message(code, json); end
  def extract_error(body, context); end
  def parse_error_data(context, code); end
end

class Aws::Json::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def apply_request_id(context); end
  def build_body(context); end
  def build_request(context); end
  def content_type(context); end
  def parse_body(context); end
  def parse_response(response); end
  def simple_json?(context); end
  def target(context); end
end

Aws::Json::Handler::CONTENT_TYPE = T.let(T.unsafe(nil), String)

module Aws::Json::JSONEngine
  class << self
    def dump(value); end
    def load(json); end
  end
end

module Aws::Json::OjEngine
  class << self
    def dump(value); end
    def load(json); end

    private

    def detect_oj_parse_errors; end
  end
end

Aws::Json::OjEngine::DUMP_OPTIONS = T.let(T.unsafe(nil), Hash)
Aws::Json::OjEngine::LOAD_OPTIONS = T.let(T.unsafe(nil), Hash)

class Aws::Json::ParseError < ::StandardError
  def initialize(error); end

  def error; end
end

class Aws::Json::Parser
  include ::Seahorse::Model::Shapes

  def initialize(rules); end

  def parse(json, target = T.unsafe(nil)); end

  private

  def list(ref, values, target = T.unsafe(nil)); end
  def map(ref, values, target = T.unsafe(nil)); end
  def parse_ref(ref, value, target = T.unsafe(nil)); end
  def structure(ref, values, target = T.unsafe(nil)); end
  def time(value); end
end

module Aws::Log; end

class Aws::Log::Formatter
  def initialize(pattern, options = T.unsafe(nil)); end

  def format(response); end
  def method_missing(method_name, *args); end
  def pattern; end

  private

  def _client_class(response); end
  def _error_class(response); end
  def _error_message(response); end
  def _http_request_body(response); end
  def _http_request_endpoint(response); end
  def _http_request_headers(response); end
  def _http_request_host(response); end
  def _http_request_method(response); end
  def _http_request_port(response); end
  def _http_request_scheme(response); end
  def _http_response_body(response); end
  def _http_response_headers(response); end
  def _http_response_status_code(response); end
  def _operation(response); end
  def _request_params(response); end
  def _retries(response); end
  def _time(response); end

  class << self
    def colored(options = T.unsafe(nil)); end
    def default(options = T.unsafe(nil)); end
    def short(options = T.unsafe(nil)); end
  end
end

class Aws::Log::ParamFilter
  def initialize(options = T.unsafe(nil)); end

  def filter(values, type); end

  private

  def filter_array(values, type); end
  def filter_hash(values, type); end
  def filter_struct(values, type); end
end

Aws::Log::ParamFilter::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::Log::ParamFormatter
  def initialize(options = T.unsafe(nil)); end

  def summarize(value); end

  private

  def summarize_array(array); end
  def summarize_file(path); end
  def summarize_hash(hash); end
  def summarize_string(str); end
  def summarize_string_hash(hash); end
  def summarize_symbol_hash(hash); end
  def summarize_value(value); end
end

Aws::Log::ParamFormatter::MAX_STRING_SIZE = T.let(T.unsafe(nil), Integer)

module Aws::PageableResponse
  def each(&block); end
  def each_page(&block); end
  def last_page?; end
  def next_page(params = T.unsafe(nil)); end
  def next_page?; end
  def pager; end
  def pager=(_arg0); end

  private

  def next_page_params(params); end
  def next_response(params); end

  class << self
    def extended(base); end
  end
end

class Aws::PageableResponse::LastPageError < ::RuntimeError
  def initialize(response); end

  def response; end
end

module Aws::PageableResponse::UnsafeEnumerableMethods
  def count; end
  def respond_to?(method_name, *args); end
  def to_h; end
end

class Aws::Pager
  def initialize(options); end

  def limit_key; end
  def next_tokens(response); end
  def prev_tokens(response); end
  def tokens; end
  def truncated?(response); end

  private

  def empty_value?(value); end
end

class Aws::Pager::NullPager
  def limit_key; end
  def next_tokens; end
  def prev_tokens; end
  def truncated?(response); end
end

class Aws::ParamConverter
  include ::Seahorse::Model::Shapes

  def initialize(rules); end

  def close_opened_files; end
  def convert(params); end
  def opened_files; end

  private

  def c(ref, value); end
  def list(ref, values); end
  def map(ref, values); end
  def member(ref, value); end
  def structure(ref, values); end

  class << self
    def add(shape_class, value_class, converter = T.unsafe(nil), &block); end
    def c(shape, value, instance = T.unsafe(nil)); end
    def convert(shape, params); end
    def ensure_open(file, converter); end

    private

    def converter_for(shape_class, value); end
    def each_base_class(shape_class, &block); end
    def find(shape_class, value); end
  end
end

class Aws::ParamValidator
  include ::Seahorse::Model::Shapes

  def initialize(rules, options = T.unsafe(nil)); end

  def validate!(params); end

  private

  def correct_type?(ref, value, errors, context); end
  def document(ref, value, errors, context); end
  def error_messages(errors); end
  def expected_got(context, expected, got); end
  def io_like?(value, require_size = T.unsafe(nil)); end
  def list(ref, values, errors, context); end
  def map(ref, values, errors, context); end
  def shape(ref, value, errors, context); end
  def streaming_input?(ref); end
  def structure(ref, values, errors, context); end

  class << self
    def validate!(rules, params); end
  end
end

Aws::ParamValidator::EXPECTED_GOT = T.let(T.unsafe(nil), String)
module Aws::Plugins; end

class Aws::Plugins::ClientMetricsPlugin < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end

  class << self
    def resolve_client_id(cfg); end
    def resolve_client_side_monitoring(cfg); end
    def resolve_client_side_monitoring_host(cfg); end
    def resolve_client_side_monitoring_port(cfg); end
    def resolve_publisher(cfg); end
  end
end

class Aws::Plugins::ClientMetricsPlugin::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def _calculate_service_id(context); end
  def _fallback_service_id(id); end
end

class Aws::Plugins::ClientMetricsSendPlugin < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

class Aws::Plugins::ClientMetricsSendPlugin::AttemptHandler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def _extract_error_name(error); end
end

class Aws::Plugins::ClientMetricsSendPlugin::LatencyHandler < ::Seahorse::Client::Handler
  def call(context); end
end

class Aws::Plugins::CredentialsConfiguration < ::Seahorse::Client::Plugin; end

class Aws::Plugins::DefaultsMode < ::Seahorse::Client::Plugin
  class << self
    private

    def resolve_defaults_mode(cfg); end
  end
end

class Aws::Plugins::EndpointDiscovery < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end

  class << self
    def resolve_endpoint_discovery(cfg); end
  end
end

class Aws::Plugins::EndpointDiscovery::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def _apply_endpoint_discovery_user_agent(ctx); end
  def _discover_endpoint(ctx, required); end
  def _valid_uri(address); end
end

class Aws::Plugins::EndpointPattern < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

class Aws::Plugins::EndpointPattern::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def _apply_endpoint_trait(context, trait); end
  def _replace_label_value(ori, label, input_ref, params); end
end

class Aws::Plugins::EventStreamConfiguration < ::Seahorse::Client::Plugin; end

class Aws::Plugins::GlobalConfiguration < ::Seahorse::Client::Plugin
  def before_initialize(client_class, options); end

  private

  def apply_aws_defaults(client_class, options); end
  def apply_service_defaults(client_class, options); end

  class << self
    def add_identifier(identifier); end
    def identifiers; end
  end
end

class Aws::Plugins::HelpfulSocketErrors < ::Seahorse::Client::Plugin; end

class Aws::Plugins::HelpfulSocketErrors::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def no_such_endpoint_error(context, error); end
  def socket_endpoint_error?(error); end
end

class Aws::Plugins::HttpChecksum < ::Seahorse::Client::Plugin
  def add_handlers(handlers, _config); end
end

class Aws::Plugins::HttpChecksum::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def md5(value); end
  def update_in_chunks(digest, io); end
end

Aws::Plugins::HttpChecksum::Handler::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)
class Aws::Plugins::IdempotencyToken < ::Seahorse::Client::Plugin; end

class Aws::Plugins::IdempotencyToken::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def auto_fill(params, ref); end
end

class Aws::Plugins::JsonvalueConverter < ::Seahorse::Client::Plugin; end

class Aws::Plugins::JsonvalueConverter::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

class Aws::Plugins::Logging < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

class Aws::Plugins::Logging::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def format(config, response); end
  def log(config, response); end
end

class Aws::Plugins::ParamConverter < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

class Aws::Plugins::ParamConverter::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

class Aws::Plugins::ParamValidator < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

class Aws::Plugins::ParamValidator::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

module Aws::Plugins::Protocols; end
class Aws::Plugins::Protocols::JsonRpc < ::Seahorse::Client::Plugin; end
class Aws::Plugins::Protocols::Query < ::Seahorse::Client::Plugin; end
class Aws::Plugins::Protocols::RestJson < ::Seahorse::Client::Plugin; end

class Aws::Plugins::Protocols::RestJson::ContentTypeHandler < ::Seahorse::Client::Handler
  def call(context); end
end

class Aws::Plugins::Protocols::RestXml < ::Seahorse::Client::Plugin; end

class Aws::Plugins::RegionalEndpoint < ::Seahorse::Client::Plugin
  def after_initialize(client); end

  class << self
    private

    def resolve_region(cfg); end
    def resolve_use_dualstack_endpoint(cfg); end
    def resolve_use_fips_endpoint(cfg); end
  end
end

class Aws::Plugins::ResponsePaging < ::Seahorse::Client::Plugin; end

class Aws::Plugins::ResponsePaging::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

module Aws::Plugins::Retries; end

class Aws::Plugins::Retries::ClientRateLimiter
  def initialize; end

  def token_bucket_acquire(amount, wait_to_fill = T.unsafe(nil)); end
  def update_sending_rate(is_throttling_error); end

  private

  def calculate_time_window; end
  def cubic_success(timestamp); end
  def cubic_throttle(rate_to_use); end
  def enable_token_bucket; end
  def token_bucket_refill; end
  def token_bucket_update_rate(new_rps); end
  def update_measured_rate; end
end

Aws::Plugins::Retries::ClientRateLimiter::BETA = T.let(T.unsafe(nil), Float)
Aws::Plugins::Retries::ClientRateLimiter::MIN_CAPACITY = T.let(T.unsafe(nil), Integer)
Aws::Plugins::Retries::ClientRateLimiter::MIN_FILL_RATE = T.let(T.unsafe(nil), Float)
Aws::Plugins::Retries::ClientRateLimiter::SCALE_CONSTANT = T.let(T.unsafe(nil), Float)
Aws::Plugins::Retries::ClientRateLimiter::SMOOTH = T.let(T.unsafe(nil), Float)

class Aws::Plugins::Retries::ClockSkew
  def initialize; end

  def clock_correction(endpoint); end
  def clock_skewed?(context); end
  def estimated_skew(endpoint); end
  def update_clock_correction(context); end
  def update_estimated_skew(context); end

  private

  def server_time(response); end
  def set_clock_correction(endpoint, correction); end
end

Aws::Plugins::Retries::ClockSkew::CLOCK_SKEW_THRESHOLD = T.let(T.unsafe(nil), Integer)

class Aws::Plugins::Retries::ErrorInspector
  def initialize(error, http_status_code); end

  def checksum?; end
  def clock_skew?(context); end
  def endpoint_discovery?(context); end
  def expired_credentials?; end
  def modeled_retryable?; end
  def modeled_throttling?; end
  def networking?; end
  def retryable?(context); end
  def server?; end
  def throttling_error?; end

  private

  def extract_name(error); end
  def refreshable_credentials?(context); end
end

Aws::Plugins::Retries::ErrorInspector::CHECKSUM_ERRORS = T.let(T.unsafe(nil), Set)
Aws::Plugins::Retries::ErrorInspector::CLOCK_SKEW_ERRORS = T.let(T.unsafe(nil), Set)
Aws::Plugins::Retries::ErrorInspector::EXPIRED_CREDS = T.let(T.unsafe(nil), Set)
Aws::Plugins::Retries::ErrorInspector::NETWORKING_ERRORS = T.let(T.unsafe(nil), Set)
Aws::Plugins::Retries::ErrorInspector::THROTTLING_ERRORS = T.let(T.unsafe(nil), Set)

class Aws::Plugins::Retries::RetryQuota
  def initialize(opts = T.unsafe(nil)); end

  def checkout_capacity(error_inspector); end
  def release(capacity_amount); end
end

Aws::Plugins::Retries::RetryQuota::INITIAL_RETRY_TOKENS = T.let(T.unsafe(nil), Integer)
Aws::Plugins::Retries::RetryQuota::NO_RETRY_INCREMENT = T.let(T.unsafe(nil), Integer)
Aws::Plugins::Retries::RetryQuota::RETRY_COST = T.let(T.unsafe(nil), Integer)
Aws::Plugins::Retries::RetryQuota::TIMEOUT_RETRY_COST = T.let(T.unsafe(nil), Integer)

class Aws::Plugins::RetryErrors < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end

  class << self
    def resolve_adaptive_retry_wait_to_fill(cfg); end
    def resolve_correct_clock_skew(cfg); end
    def resolve_max_attempts(cfg); end
    def resolve_retry_mode(cfg); end
  end
end

Aws::Plugins::RetryErrors::DEFAULT_BACKOFF = T.let(T.unsafe(nil), Proc)
Aws::Plugins::RetryErrors::EQUAL_JITTER = T.let(T.unsafe(nil), Proc)
Aws::Plugins::RetryErrors::FULL_JITTER = T.let(T.unsafe(nil), Proc)

class Aws::Plugins::RetryErrors::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def add_retry_headers(context); end
  def compute_request_ttl(context); end
  def exponential_backoff(retries); end
  def get_send_token(config); end
  def request_bookkeeping(context, response, error_inspector); end
  def retry_request(context, error); end
  def retryable?(context, response, error_inspector); end
end

Aws::Plugins::RetryErrors::Handler::MAX_BACKOFF = T.let(T.unsafe(nil), Integer)
Aws::Plugins::RetryErrors::JITTERS = T.let(T.unsafe(nil), Hash)

class Aws::Plugins::RetryErrors::LegacyHandler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def delay_retry(context); end
  def response_truncatable?(context); end
  def retry_if_possible(response, error_inspector); end
  def retry_limit(context); end
  def retry_request(context, error); end
  def should_retry?(context, error); end
end

Aws::Plugins::RetryErrors::NO_JITTER = T.let(T.unsafe(nil), Proc)

class Aws::Plugins::SignatureV4 < ::Seahorse::Client::Plugin
  def add_handlers(handlers, cfg); end

  class << self
    def apply_authtype(context); end
    def apply_signature(options = T.unsafe(nil)); end
    def build_signer(cfg); end
  end
end

class Aws::Plugins::SignatureV4::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

class Aws::Plugins::SignatureV4::MissingCredentialsSigner
  def sign_request(*args); end
end

class Aws::Plugins::StubResponses < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def after_initialize(client); end
end

class Aws::Plugins::StubResponses::Handler < ::Seahorse::Client::Handler
  def apply_stub(stub, response, async_mode = T.unsafe(nil)); end
  def call(context); end
  def signal_error(error, http_resp); end
  def signal_http(stub, http_resp, async_mode = T.unsafe(nil)); end
end

class Aws::Plugins::TransferEncoding < ::Seahorse::Client::Plugin; end

class Aws::Plugins::TransferEncoding::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def requires_length?(ref); end
  def streaming?(ref); end
end

class Aws::Plugins::UserAgent < ::Seahorse::Client::Plugin; end

class Aws::Plugins::UserAgent::Handler < ::Seahorse::Client::Handler
  def call(context); end
  def set_user_agent(context); end
end

class Aws::ProcessCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials

  def initialize(process); end

  private

  def _parse_payload_format_v1(creds_json); end
  def credentials_from_process(proc_invocation); end
  def near_expiration?; end
  def refresh; end
end

module Aws::Query; end

class Aws::Query::EC2ParamBuilder
  include ::Seahorse::Model::Shapes

  def initialize(param_list); end

  def apply(ref, params); end
  def params; end

  private

  def blob(value); end
  def format(ref, value, prefix); end
  def list(ref, values, prefix); end
  def query_name(ref); end
  def set(name, value); end
  def structure(ref, values, prefix); end
  def timestamp(ref, value); end
  def ucfirst(str); end
end

class Aws::Query::Handler < ::Seahorse::Client::Handler
  include ::Seahorse::Model::Shapes

  def call(context); end

  private

  def apply_params(param_list, params, rules); end
  def build_request(context); end
  def parse_xml(context); end
  def remove_wrapper(data, context); end
  def rules(context); end
  def xml(context); end
end

Aws::Query::Handler::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Aws::Query::Handler::METADATA_REF = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ShapeRef)

class Aws::Query::Handler::METADATA_STRUCT < ::Struct
  def request_id; end
  def request_id=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Aws::Query::Handler::WRAPPER_STRUCT < ::Struct
  def response_metadata; end
  def response_metadata=(_); end
  def result; end
  def result=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Aws::Query::Param
  def initialize(name, value = T.unsafe(nil)); end

  def <=>(other); end
  def ==(other); end
  def name; end
  def to_s; end
  def value; end

  private

  def escape(str); end
end

class Aws::Query::ParamBuilder
  include ::Seahorse::Model::Shapes

  def initialize(param_list); end

  def apply(ref, params); end
  def params; end

  private

  def blob(value); end
  def flat?(ref); end
  def format(ref, value, prefix); end
  def list(ref, values, prefix); end
  def map(ref, values, prefix); end
  def query_name(ref, default = T.unsafe(nil)); end
  def set(name, value); end
  def structure(ref, values, prefix); end
  def timestamp(ref, value); end
end

class Aws::Query::ParamList
  include ::Enumerable

  def initialize; end

  def [](param_name); end
  def []=(param_name, param_value = T.unsafe(nil)); end
  def delete(param_name); end
  def each(&block); end
  def empty?; end
  def set(param_name, param_value = T.unsafe(nil)); end
  def to_a; end
  def to_io; end
  def to_s; end
end

class Aws::Query::ParamList::IoWrapper
  def initialize(param_list); end

  def param_list; end
  def read(bytes = T.unsafe(nil), output_buffer = T.unsafe(nil)); end
  def rewind; end
  def size; end
end

module Aws::RefreshingCredentials
  def initialize(options = T.unsafe(nil)); end

  def credentials; end
  def expiration; end
  def refresh!; end

  private

  def near_expiration?; end
  def refresh_if_near_expiration; end
end

module Aws::Resources; end

class Aws::Resources::Collection
  include ::Enumerable
  extend ::Aws::Deprecations

  def initialize(batches, options = T.unsafe(nil)); end

  def [](*args, &block); end
  def batches; end
  def each(&block); end
  def first(count = T.unsafe(nil)); end
  def length; end
  def limit(limit); end
  def size; end

  private

  def batch_enum; end
  def limited_batches; end
  def non_empty_batches; end
end

module Aws::Rest; end

class Aws::Rest::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def apply_request_id(context); end
end

module Aws::Rest::Request; end

class Aws::Rest::Request::Body
  include ::Seahorse::Model::Shapes

  def initialize(serializer_class, rules); end

  def apply(http_req, params); end

  private

  def body_params(params); end
  def build_body(params); end
  def modeled_body?; end
  def serialize(rules, params); end
  def streaming?; end
end

class Aws::Rest::Request::Builder
  def apply(context); end

  private

  def populate_body(context); end
  def populate_endpoint(context); end
  def populate_headers(context); end
  def populate_http_method(context); end
  def serializer_class(context); end
end

class Aws::Rest::Request::Endpoint
  def initialize(rules, request_uri_pattern); end

  def uri(base_uri, params); end

  private

  def apply_path_params(uri, params); end
  def apply_querystring_params(uri, params); end
  def escape(string); end
  def param_name(placeholder); end
  def param_value_for_placeholder(placeholder, params); end
end

class Aws::Rest::Request::Headers
  include ::Seahorse::Model::Shapes

  def initialize(rules); end

  def apply(http_req, params); end

  private

  def apply_header_map(headers, ref, values); end
  def apply_header_value(headers, ref, value); end
  def apply_json_trait(value); end
  def escape_header_list_string(s); end
  def list(headers, ref, value); end
  def timestamp(ref, value); end
end

class Aws::Rest::Request::QuerystringBuilder
  include ::Seahorse::Model::Shapes

  def build(params); end

  private

  def build_part(shape_ref, param_value); end
  def escape(string); end
  def list_of_strings(name, values); end
  def query_map_of_string(hash); end
  def query_map_of_string_list(hash); end
  def timestamp(ref, value); end
end

module Aws::Rest::Response; end

class Aws::Rest::Response::Body
  include ::Seahorse::Model::Shapes

  def initialize(parser_class, rules); end

  def apply(body, data); end

  private

  def event_stream?; end
  def parse(body, rules, target = T.unsafe(nil)); end
  def parse_eventstream(body); end
  def streaming?; end
end

class Aws::Rest::Response::Headers
  include ::Seahorse::Model::Shapes

  def initialize(rules); end

  def apply(http_resp, target); end
  def cast_value(ref, value); end
  def extract_header_map(headers, name, ref, data); end
  def extract_header_value(headers, name, ref, data); end
  def extract_json_trait(value); end
end

class Aws::Rest::Response::Parser
  def apply(response); end

  private

  def extract_body(rules, response); end
  def extract_headers(rules, response); end
  def extract_status_code(rules, response); end
  def parser_class(response); end
end

class Aws::Rest::Response::StatusCode
  def initialize(rules); end

  def apply(http_resp, data); end
end

module Aws::SSO; end

class Aws::SSO::Client < ::Seahorse::Client::Base
  include ::Aws::ClientStubs

  def initialize(*args); end

  def build_request(operation_name, params = T.unsafe(nil)); end
  def get_role_credentials(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def list_account_roles(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def list_accounts(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def logout(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def waiter_names; end

  class << self
    def errors_module; end
    def identifier; end
  end
end

module Aws::SSO::ClientApi
  include ::Seahorse::Model
end

Aws::SSO::ClientApi::API = T.let(T.unsafe(nil), Seahorse::Model::Api)
Aws::SSO::ClientApi::AccessKeyType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::AccessTokenType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::AccountIdType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::AccountInfo = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::AccountListType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)
Aws::SSO::ClientApi::AccountNameType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::EmailAddressType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::ErrorDescription = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::ExpirationTimestampType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::IntegerShape)
Aws::SSO::ClientApi::GetRoleCredentialsRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::GetRoleCredentialsResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::InvalidRequestException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::ListAccountRolesRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::ListAccountRolesResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::ListAccountsRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::ListAccountsResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::LogoutRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::MaxResultType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::IntegerShape)
Aws::SSO::ClientApi::NextTokenType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::ResourceNotFoundException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::RoleCredentials = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::RoleInfo = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::RoleListType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)
Aws::SSO::ClientApi::RoleNameType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::SecretAccessKeyType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::SessionTokenType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::SSO::ClientApi::TooManyRequestsException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::SSO::ClientApi::UnauthorizedException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

module Aws::SSO::Errors
  extend ::Aws::Errors::DynamicErrors
end

class Aws::SSO::Errors::InvalidRequestException < ::Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::SSO::Errors::ResourceNotFoundException < ::Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::SSO::Errors::ServiceError < ::Aws::Errors::ServiceError; end

class Aws::SSO::Errors::TooManyRequestsException < ::Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::SSO::Errors::UnauthorizedException < ::Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

Aws::SSO::GEM_VERSION = T.let(T.unsafe(nil), String)

class Aws::SSO::Resource
  def initialize(options = T.unsafe(nil)); end

  def client; end
end

module Aws::SSO::Types; end

class Aws::SSO::Types::AccountInfo < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::AccountInfo::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::GetRoleCredentialsRequest < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::GetRoleCredentialsRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::GetRoleCredentialsResponse < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::GetRoleCredentialsResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::InvalidRequestException < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::InvalidRequestException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::ListAccountRolesRequest < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::ListAccountRolesRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::ListAccountRolesResponse < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::ListAccountRolesResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::ListAccountsRequest < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::ListAccountsRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::ListAccountsResponse < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::ListAccountsResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::LogoutRequest < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::LogoutRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::ResourceNotFoundException < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::ResourceNotFoundException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::RoleCredentials < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::RoleCredentials::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::RoleInfo < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::RoleInfo::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::TooManyRequestsException < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::TooManyRequestsException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSO::Types::UnauthorizedException < ::Struct
  include ::Aws::Structure
end

Aws::SSO::Types::UnauthorizedException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SSOCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials

  def initialize(options = T.unsafe(nil)); end

  def client; end

  private

  def read_cached_token; end
  def refresh; end
  def sso_cache_file; end
end

Aws::SSOCredentials::SSO_LOGIN_GUIDANCE = T.let(T.unsafe(nil), String)
Aws::SSOCredentials::SSO_REQUIRED_OPTS = T.let(T.unsafe(nil), Array)
module Aws::STS; end

class Aws::STS::Client < ::Seahorse::Client::Base
  include ::Aws::ClientStubs

  def initialize(*args); end

  def assume_role(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def assume_role_with_saml(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def assume_role_with_web_identity(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def build_request(operation_name, params = T.unsafe(nil)); end
  def decode_authorization_message(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def get_access_key_info(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def get_caller_identity(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def get_federation_token(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def get_session_token(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def waiter_names; end

  class << self
    def errors_module; end
    def identifier; end
  end
end

module Aws::STS::ClientApi
  include ::Seahorse::Model
end

Aws::STS::ClientApi::API = T.let(T.unsafe(nil), Seahorse::Model::Api)
Aws::STS::ClientApi::AssumeRoleRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::AssumeRoleResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::AssumeRoleWithSAMLRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::AssumeRoleWithSAMLResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::AssumeRoleWithWebIdentityRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::AssumeRoleWithWebIdentityResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::AssumedRoleUser = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::Audience = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::STS::ClientApi::Credentials = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::DecodeAuthorizationMessageRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::DecodeAuthorizationMessageResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::ExpiredTokenException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::FederatedUser = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetAccessKeyInfoRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetAccessKeyInfoResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetCallerIdentityRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetCallerIdentityResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetFederationTokenRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetFederationTokenResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetSessionTokenRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::GetSessionTokenResponse = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::IDPCommunicationErrorException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::IDPRejectedClaimException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::InvalidAuthorizationMessageException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::InvalidIdentityTokenException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::Issuer = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::STS::ClientApi::MalformedPolicyDocumentException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::NameQualifier = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::STS::ClientApi::PackedPolicyTooLargeException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::PolicyDescriptorType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::RegionDisabledException = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)
Aws::STS::ClientApi::SAMLAssertionType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::STS::ClientApi::Subject = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::STS::ClientApi::SubjectType = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)
Aws::STS::ClientApi::Tag = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

module Aws::STS::Errors
  extend ::Aws::Errors::DynamicErrors
end

class Aws::STS::Errors::ExpiredTokenException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::IDPCommunicationErrorException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::IDPRejectedClaimException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::InvalidAuthorizationMessageException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::InvalidIdentityTokenException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::MalformedPolicyDocumentException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::PackedPolicyTooLargeException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::RegionDisabledException < ::Aws::STS::Errors::ServiceError
  def initialize(context, message, data = T.unsafe(nil)); end

  def message; end
end

class Aws::STS::Errors::ServiceError < ::Aws::Errors::ServiceError; end
Aws::STS::GEM_VERSION = T.let(T.unsafe(nil), String)
module Aws::STS::Plugins; end

class Aws::STS::Plugins::STSRegionalEndpoints < ::Seahorse::Client::Plugin
  class << self
    def resolve_sts_regional_endpoints(cfg); end
  end
end

class Aws::STS::Presigner
  def initialize(options = T.unsafe(nil)); end

  def get_caller_identity_presigned_url(options = T.unsafe(nil)); end
end

class Aws::STS::Resource
  def initialize(options = T.unsafe(nil)); end

  def client; end
end

module Aws::STS::Types; end

class Aws::STS::Types::AssumeRoleRequest < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::AssumeRoleRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::AssumeRoleResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::AssumeRoleResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::AssumeRoleWithSAMLRequest < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::AssumeRoleWithSAMLRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::AssumeRoleWithSAMLResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::AssumeRoleWithSAMLResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::AssumeRoleWithWebIdentityRequest < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::AssumeRoleWithWebIdentityRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::AssumeRoleWithWebIdentityResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::AssumeRoleWithWebIdentityResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::AssumedRoleUser < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::AssumedRoleUser::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::Credentials < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::Credentials::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::DecodeAuthorizationMessageRequest < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::DecodeAuthorizationMessageRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::DecodeAuthorizationMessageResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::DecodeAuthorizationMessageResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::ExpiredTokenException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::ExpiredTokenException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::FederatedUser < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::FederatedUser::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::GetAccessKeyInfoRequest < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::GetAccessKeyInfoRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::GetAccessKeyInfoResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::GetAccessKeyInfoResponse::SENSITIVE = T.let(T.unsafe(nil), Array)
class Aws::STS::Types::GetCallerIdentityRequest < ::Aws::EmptyStructure; end

class Aws::STS::Types::GetCallerIdentityResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::GetCallerIdentityResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::GetFederationTokenRequest < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::GetFederationTokenRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::GetFederationTokenResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::GetFederationTokenResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::GetSessionTokenRequest < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::GetSessionTokenRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::GetSessionTokenResponse < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::GetSessionTokenResponse::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::IDPCommunicationErrorException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::IDPCommunicationErrorException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::IDPRejectedClaimException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::IDPRejectedClaimException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::InvalidAuthorizationMessageException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::InvalidAuthorizationMessageException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::InvalidIdentityTokenException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::InvalidIdentityTokenException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::MalformedPolicyDocumentException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::MalformedPolicyDocumentException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::PackedPolicyTooLargeException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::PackedPolicyTooLargeException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::PolicyDescriptorType < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::PolicyDescriptorType::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::RegionDisabledException < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::RegionDisabledException::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::STS::Types::Tag < ::Struct
  include ::Aws::Structure
end

Aws::STS::Types::Tag::SENSITIVE = T.let(T.unsafe(nil), Array)

class Aws::SharedConfig
  def initialize(options = T.unsafe(nil)); end

  def adaptive_retry_wait_to_fill(opts = T.unsafe(nil)); end
  def assume_role_credentials_from_config(opts = T.unsafe(nil)); end
  def assume_role_web_identity_credentials_from_config(opts = T.unsafe(nil)); end
  def ca_bundle(opts = T.unsafe(nil)); end
  def config_enabled?; end
  def config_path; end
  def correct_clock_skew(opts = T.unsafe(nil)); end
  def credential_process(opts = T.unsafe(nil)); end
  def credentials(opts = T.unsafe(nil)); end
  def credentials_path; end
  def csm_client_id(opts = T.unsafe(nil)); end
  def csm_enabled(opts = T.unsafe(nil)); end
  def csm_host(opts = T.unsafe(nil)); end
  def csm_port(opts = T.unsafe(nil)); end
  def defaults_mode(opts = T.unsafe(nil)); end
  def ec2_metadata_service_endpoint(opts = T.unsafe(nil)); end
  def ec2_metadata_service_endpoint_mode(opts = T.unsafe(nil)); end
  def endpoint_discovery_enabled(opts = T.unsafe(nil)); end
  def fresh(options = T.unsafe(nil)); end
  def loadable?(path); end
  def max_attempts(opts = T.unsafe(nil)); end
  def profile_name; end
  def region(opts = T.unsafe(nil)); end
  def retry_mode(opts = T.unsafe(nil)); end
  def s3_disable_multiregion_access_points(opts = T.unsafe(nil)); end
  def s3_us_east_1_regional_endpoint(opts = T.unsafe(nil)); end
  def s3_use_arn_region(opts = T.unsafe(nil)); end
  def sso_credentials_from_config(opts = T.unsafe(nil)); end
  def sts_regional_endpoints(opts = T.unsafe(nil)); end
  def use_dualstack_endpoint(opts = T.unsafe(nil)); end
  def use_fips_endpoint(opts = T.unsafe(nil)); end

  private

  def assume_role_from_profile(cfg, profile, opts, chain_config); end
  def assume_role_process_credentials_from_config(profile); end
  def credentials_from_config(profile, _opts); end
  def credentials_from_profile(prof_config); end
  def credentials_from_shared(profile, _opts); end
  def credentials_from_source(credential_source, config); end
  def credentials_present?; end
  def default_shared_config_path(file); end
  def determine_config_path; end
  def determine_credentials_path; end
  def determine_profile(options); end
  def get_config_value(key, opts); end
  def load_config_file; end
  def load_credentials_file; end
  def resolve_source_profile(profile, opts = T.unsafe(nil)); end
  def sso_credentials_from_profile(cfg, profile); end
  def validate_profile_exists(profile); end

  class << self
    def config_reader(*attrs); end
  end
end

Aws::SharedConfig::SSO_PROFILE_KEYS = T.let(T.unsafe(nil), Array)

class Aws::SharedCredentials
  include ::Aws::CredentialProvider

  def initialize(options = T.unsafe(nil)); end

  def credentials; end
  def inspect; end
  def loadable?; end
  def path; end
  def profile_name; end
end

Aws::SharedCredentials::KEY_MAP = T.let(T.unsafe(nil), Hash)

module Aws::Structure
  def initialize(values = T.unsafe(nil)); end

  def empty?; end
  def key?(member_name); end
  def to_h(obj = T.unsafe(nil)); end
  def to_hash(obj = T.unsafe(nil)); end
  def to_s(obj = T.unsafe(nil)); end

  class << self
    def new(*args); end
  end
end

module Aws::Structure::Union
  def member; end
  def value; end
end

module Aws::Stubbing; end

class Aws::Stubbing::DataApplicator
  include ::Seahorse::Model::Shapes

  def initialize(rules); end

  def apply_data(data, stub); end

  private

  def apply_data_to_struct(ref, data, struct); end
  def member_value(ref, value); end
end

class Aws::Stubbing::EmptyStub
  include ::Seahorse::Model::Shapes

  def initialize(rules); end

  def stub; end

  private

  def stub_ref(ref, visited = T.unsafe(nil)); end
  def stub_scalar(ref); end
  def stub_structure(ref, visited); end
end

module Aws::Stubbing::Protocols; end
class Aws::Stubbing::Protocols::ApiGateway < ::Aws::Stubbing::Protocols::RestJson; end

class Aws::Stubbing::Protocols::EC2
  def stub_data(api, operation, data); end
  def stub_error(error_code); end

  private

  def build_body(api, operation, data); end
end

class Aws::Stubbing::Protocols::Json
  def stub_data(api, operation, data); end
  def stub_error(error_code); end

  private

  def build_body(operation, data); end
  def content_type(api); end
end

class Aws::Stubbing::Protocols::Query
  def stub_data(api, operation, data); end
  def stub_error(error_code); end

  private

  def build_body(api, operation, data); end
  def xmlns(api); end
end

class Aws::Stubbing::Protocols::Rest
  include ::Seahorse::Model::Shapes

  def stub_data(api, operation, data); end

  private

  def apply_body(api, operation, resp, data); end
  def apply_headers(operation, resp, data); end
  def apply_status_code(operation, resp, data); end
  def build_body(api, operation, data); end
  def encode_error(opts, event_data); end
  def encode_event(opts, rules, event_data, builder); end
  def encode_eventstream_response(rules, data, builder); end
  def encode_modeled_event(opts, rules, event_type, event_data, builder); end
  def encode_unknown_event(opts, event_type, event_data); end
  def eventstream?(rules); end
  def head_operation(operation); end
  def new_http_response; end
  def streaming?(ref); end
end

class Aws::Stubbing::Protocols::RestJson < ::Aws::Stubbing::Protocols::Rest
  def body_for(_a, _b, rules, data); end
  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::RestXml < ::Aws::Stubbing::Protocols::Rest
  def body_for(api, operation, rules, data); end
  def stub_error(error_code); end
  def xmlns(api); end
end

class Aws::Stubbing::StubData
  def initialize(operation); end

  def stub(data = T.unsafe(nil)); end

  private

  def apply_data(data, stub); end
  def remove_paging_tokens(stub); end
end

class Aws::Stubbing::XmlError
  def initialize(error_code); end

  def to_xml; end
end

class Aws::TypeBuilder
  def initialize(svc_module); end

  def build_type(shape, shapes); end
end

module Aws::Util
  class << self
    def copy_hash(hash); end
    def deep_copy(obj); end
    def deep_merge(left, right); end
    def monotonic_milliseconds; end
    def monotonic_seconds; end
    def str_2_bool(str); end
  end
end

module Aws::Waiters; end
module Aws::Waiters::Errors; end

class Aws::Waiters::Errors::FailureStateError < ::Aws::Waiters::Errors::WaiterFailed
  def initialize(response); end

  def response; end
end

Aws::Waiters::Errors::FailureStateError::MSG = T.let(T.unsafe(nil), String)

class Aws::Waiters::Errors::NoSuchWaiterError < ::ArgumentError
  def initialize(waiter_name, waiter_names); end
end

Aws::Waiters::Errors::NoSuchWaiterError::MSG = T.let(T.unsafe(nil), String)

class Aws::Waiters::Errors::TooManyAttemptsError < ::Aws::Waiters::Errors::WaiterFailed
  def initialize(attempts); end

  def attempts; end
end

Aws::Waiters::Errors::TooManyAttemptsError::MSG = T.let(T.unsafe(nil), String)

class Aws::Waiters::Errors::UnexpectedError < ::Aws::Waiters::Errors::WaiterFailed
  def initialize(error); end

  def error; end
end

Aws::Waiters::Errors::UnexpectedError::MSG = T.let(T.unsafe(nil), String)
class Aws::Waiters::Errors::WaiterFailed < ::StandardError; end

class Aws::Waiters::Poller
  def initialize(options = T.unsafe(nil)); end

  def call(options = T.unsafe(nil)); end
  def operation_name; end

  private

  def acceptor_matches?(acceptor, response); end
  def matches_error?(acceptor, response); end
  def matches_path?(acceptor, response); end
  def matches_pathAll?(acceptor, response); end
  def matches_pathAny?(acceptor, response); end
  def matches_status?(acceptor, response); end
  def non_empty_array(acceptor, response, &block); end
  def path(acceptor); end
  def send_request(options); end
end

Aws::Waiters::Poller::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler

class Aws::Waiters::Waiter
  def initialize(options = T.unsafe(nil)); end

  def before_attempt(&block); end
  def before_wait(&block); end
  def delay; end
  def delay=(_arg0); end
  def interval; end
  def interval=(_arg0); end
  def max_attempts; end
  def max_attempts=(_arg0); end
  def poller; end
  def wait(options); end

  private

  def poll(options); end
  def trigger_before_attempt(attempts); end
  def trigger_before_wait(attempts, response); end
end

Aws::Waiters::Waiter::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler
module Aws::Xml; end

class Aws::Xml::Builder
  include ::Seahorse::Model::Shapes

  def initialize(rules, options = T.unsafe(nil)); end

  def serialize(params); end
  def to_xml(params); end

  private

  def blob(value); end
  def list(name, ref, values); end
  def map(name, ref, hash); end
  def member(name, ref, value); end
  def node(name, ref, *args, &block); end
  def shape_attrs(ref); end
  def structure(name, ref, values); end
  def structure_attrs(ref, values); end
  def timestamp(ref, value); end
  def xml_attribute?(ref); end
end

class Aws::Xml::DefaultList < ::Array
  def nil?; end
end

class Aws::Xml::DefaultMap < ::Hash
  def nil?; end
end

class Aws::Xml::DocBuilder
  def initialize(options = T.unsafe(nil)); end

  def node(name, *args, &block); end
  def target; end

  private

  def attributes(attr); end
  def close_el(name); end
  def empty_element(name, attrs); end
  def escape(string, text_or_attr); end
  def increase_pad(&block); end
  def inline_element(name, value, attrs); end
  def open_el(name, attrs); end
end

class Aws::Xml::ErrorHandler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def error(context); end
  def error_code(body, context); end
  def error_data(context, code); end
  def error_message(body); end
  def extract_error(body, context); end
  def http_status_error_code(context); end
  def remove_prefix(error_code, context); end
  def unescape(str); end
end

class Aws::Xml::Parser
  include ::Seahorse::Model::Shapes

  def initialize(rules, options = T.unsafe(nil)); end

  def parse(xml, target = T.unsafe(nil), &unhandled_callback); end

  class << self
    def engine; end
    def engine=(engine); end
    def set_default_engine; end

    private

    def load_engine(name); end
    def try_load_engine(name); end
  end
end

class Aws::Xml::Parser::BlobFrame < ::Aws::Xml::Parser::Frame
  def result; end
end

class Aws::Xml::Parser::BooleanFrame < ::Aws::Xml::Parser::Frame
  def result; end
end

Aws::Xml::Parser::FRAME_CLASSES = T.let(T.unsafe(nil), Hash)

class Aws::Xml::Parser::FlatListFrame < ::Aws::Xml::Parser::Frame
  def initialize(xml_name, *args); end

  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def result; end
  def set_text(value); end
end

class Aws::Xml::Parser::FloatFrame < ::Aws::Xml::Parser::Frame
  def result; end
end

class Aws::Xml::Parser::Frame
  include ::Seahorse::Model::Shapes

  def initialize(path, parent, ref, result); end

  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def parent; end
  def path; end
  def ref; end
  def result; end
  def set_text(value); end
  def yield_unhandled_value(path, value); end

  class << self
    def new(path, parent, ref, result = T.unsafe(nil)); end

    private

    def frame_class(ref); end
  end
end

class Aws::Xml::Parser::IntegerFrame < ::Aws::Xml::Parser::Frame
  def result; end
end

class Aws::Xml::Parser::ListFrame < ::Aws::Xml::Parser::Frame
  def initialize(*args); end

  def child_frame(xml_name); end
  def consume_child_frame(child); end
end

class Aws::Xml::Parser::MapEntryFrame < ::Aws::Xml::Parser::Frame
  def initialize(xml_name, *args); end

  def child_frame(xml_name); end
  def key; end
  def value; end
end

class Aws::Xml::Parser::MapFrame < ::Aws::Xml::Parser::Frame
  def initialize(*args); end

  def child_frame(xml_name); end
  def consume_child_frame(child); end
end

class Aws::Xml::Parser::NokogiriEngine
  def initialize(stack); end

  def characters(chars); end
  def comment(*args); end
  def end_document; end
  def end_element_namespace(*ignored); end
  def error(msg); end
  def parse(xml); end
  def start_document; end
  def start_element_namespace(element_name, attributes = T.unsafe(nil), *ignored); end
  def xmldecl(*args); end
end

class Aws::Xml::Parser::NullFrame < ::Aws::Xml::Parser::Frame
  def set_text(value); end

  class << self
    def new(xml_name, parent); end
  end
end

class Aws::Xml::Parser::ParsingError < ::RuntimeError
  def initialize(msg, line, column); end

  def column; end
  def line; end
end

class Aws::Xml::Parser::Stack
  def initialize(ref, result = T.unsafe(nil), &unhandled_callback); end

  def attr(name, value); end
  def child_frame(name); end
  def consume_child_frame(frame); end
  def end_element(*args); end
  def error(msg, line = T.unsafe(nil), column = T.unsafe(nil)); end
  def frame; end
  def result; end
  def start_element(name); end
  def text(value); end
  def yield_unhandled_value(path, value); end
end

class Aws::Xml::Parser::StringFrame < ::Aws::Xml::Parser::Frame
  def result; end
end

class Aws::Xml::Parser::StructureFrame < ::Aws::Xml::Parser::Frame
  def initialize(xml_name, parent, ref, result = T.unsafe(nil)); end

  def child_frame(xml_name); end
  def consume_child_frame(child); end

  private

  def apply_default_value(name, ref); end
  def flattened_list?(ref); end
  def xml_name(ref); end
end

class Aws::Xml::Parser::TimestampFrame < ::Aws::Xml::Parser::Frame
  def parse(value); end
  def result; end
end

class Aws::Xml::Parser::UnknownMemberFrame < ::Aws::Xml::Parser::Frame
  def result; end
end

module Seahorse; end
module Seahorse::Client; end

class Seahorse::Client::AsyncBase < ::Seahorse::Client::Base
  def initialize(plugins, options); end

  def close_connection; end
  def connection; end
  def connection_errors; end
  def new_connection; end
  def operation_names; end
end

class Seahorse::Client::AsyncResponse
  def initialize(options = T.unsafe(nil)); end

  def context; end
  def error; end
  def join!; end
  def on(range, &block); end
  def on_complete(&block); end
  def wait; end
end

class Seahorse::Client::Base
  include ::Seahorse::Client::HandlerBuilder

  def initialize(plugins, options); end

  def build_request(operation_name, params = T.unsafe(nil)); end
  def config; end
  def handlers; end
  def inspect; end
  def operation_names; end

  private

  def after_initialize(plugins); end
  def build_config(plugins, options); end
  def build_handler_list(plugins); end
  def context_for(operation_name, params); end

  class << self
    def add_plugin(plugin); end
    def api; end
    def clear_plugins; end
    def define(options = T.unsafe(nil)); end
    def extend(options = T.unsafe(nil)); end
    def new(options = T.unsafe(nil)); end
    def plugins; end
    def remove_plugin(plugin); end
    def set_api(api); end
    def set_plugins(plugins); end

    private

    def before_initialize(plugins, options); end
    def build_plugins; end
    def define_operation_methods; end
    def inherited(subclass); end
  end
end

class Seahorse::Client::BlockIO
  def initialize(headers = T.unsafe(nil), &block); end

  def read(bytes = T.unsafe(nil), output_buffer = T.unsafe(nil)); end
  def size; end
  def write(chunk); end
end

class Seahorse::Client::Configuration
  def initialize; end

  def add_option(name, default = T.unsafe(nil), &block); end
  def build!(options = T.unsafe(nil)); end

  private

  def apply_defaults(struct, options); end
  def apply_options(struct, options); end
  def empty_struct; end
end

class Seahorse::Client::Configuration::DefaultResolver
  def initialize(struct); end

  def override_config(k, v); end
  def resolve; end
  def respond_to?(method_name, *args); end

  private

  def method_missing(method_name, *args); end
  def resolve_defaults(opt_name, defaults); end
  def value_at(opt_name); end
end

class Seahorse::Client::Configuration::Defaults < ::Array
  def each(&block); end
end

class Seahorse::Client::Configuration::DynamicDefault
  def initialize(block = T.unsafe(nil)); end

  def block; end
  def block=(_arg0); end
  def call(*args); end
end

module Seahorse::Client::H2; end

class Seahorse::Client::H2::Connection
  def initialize(options = T.unsafe(nil)); end

  def close!; end
  def closed?; end
  def connect(endpoint); end
  def connection_read_timeout; end
  def connection_timeout; end
  def debug_output(msg, type = T.unsafe(nil)); end
  def enable_alpn; end
  def errors; end
  def http_wire_trace; end
  def input_signal_thread; end
  def input_signal_thread=(_arg0); end
  def logger; end
  def max_concurrent_streams; end
  def new_stream; end
  def ssl_ca_bundle; end
  def ssl_ca_directory; end
  def ssl_ca_store; end
  def ssl_verify_peer; end
  def ssl_verify_peer?; end
  def start(stream); end

  private

  def _debug_entry(str); end
  def _default_ca_bundle; end
  def _default_ca_directory; end
  def _nonblocking_connect(tcp, addr); end
  def _register_h2_callbacks; end
  def _tcp_socket(endpoint); end
  def _tls_context; end
end

Seahorse::Client::H2::Connection::CHUNKSIZE = T.let(T.unsafe(nil), Integer)
Seahorse::Client::H2::Connection::OPTIONS = T.let(T.unsafe(nil), Hash)
Seahorse::Client::H2::Connection::SOCKET_FAMILY = T.let(T.unsafe(nil), Integer)
Seahorse::Client::H2::DNS_ERROR_MESSAGES = T.let(T.unsafe(nil), Array)

class Seahorse::Client::H2::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def _h2_headers(req); end
  def _register_callbacks(resp, stream, stream_mutex, close_condition, sync_queue); end
  def _send_initial_data(req, stream); end
  def _send_initial_headers(req, stream); end
  def error_message(req, error); end
end

Seahorse::Client::H2::NETWORK_ERRORS = T.let(T.unsafe(nil), Array)

class Seahorse::Client::Handler
  def initialize(handler = T.unsafe(nil)); end

  def call(context); end
  def handler; end
  def handler=(_arg0); end
  def inspect; end
end

module Seahorse::Client::HandlerBuilder
  def handle(*args, &block); end
  def handle_request(*args, &block); end
  def handle_response(*args, &block); end
  def handler(*args, &block); end
  def handler_for(name = T.unsafe(nil), &block); end
  def new_handler(block); end
end

class Seahorse::Client::HandlerList
  include ::Enumerable

  def initialize(options = T.unsafe(nil)); end

  def add(handler_class, options = T.unsafe(nil)); end
  def copy_from(source_list, &block); end
  def each(&block); end
  def entries; end
  def for(operation); end
  def remove(handler_class); end
  def to_stack; end

  private

  def add_entries(entries); end
  def add_entry(entry); end
  def filter(operation); end
  def next_index; end
end

class Seahorse::Client::HandlerListEntry
  def initialize(options); end

  def <=>(other); end
  def copy(options = T.unsafe(nil)); end
  def handler_class; end
  def inserted; end
  def operations; end
  def priority; end
  def step; end
  def weight; end

  private

  def compute_weight; end
  def option(name, options); end
  def set_priority(priority); end
  def set_step(step); end
end

Seahorse::Client::HandlerListEntry::STEPS = T.let(T.unsafe(nil), Hash)
module Seahorse::Client::Http; end
class Seahorse::Client::Http2ConnectionClosedError < ::StandardError; end

class Seahorse::Client::Http2InitialRequestError < ::StandardError
  def initialize(error); end

  def original_error; end
end

class Seahorse::Client::Http2StreamInitializeError < ::StandardError
  def initialize(error); end

  def original_error; end
end

class Seahorse::Client::Http::AsyncResponse < ::Seahorse::Client::Http::Response
  def initialize(options = T.unsafe(nil)); end

  def signal_done(options = T.unsafe(nil)); end
  def signal_headers(headers); end
end

class Seahorse::Client::Http::Headers
  include ::Enumerable

  def initialize(headers = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def each(&block); end
  def each_pair(&block); end
  def has_key?(key); end
  def include?(key); end
  def inspect; end
  def key?(key); end
  def keys; end
  def to_h; end
  def to_hash; end
  def update(headers); end
  def values; end
  def values_at(*keys); end
end

class Seahorse::Client::Http::Request
  def initialize(options = T.unsafe(nil)); end

  def body; end
  def body=(io); end
  def body_contents; end
  def endpoint; end
  def endpoint=(endpoint); end
  def headers; end
  def headers=(_arg0); end
  def http_method; end
  def http_method=(_arg0); end
end

class Seahorse::Client::Http::Response
  def initialize(options = T.unsafe(nil)); end

  def body; end
  def body=(io); end
  def body_contents; end
  def error; end
  def headers; end
  def headers=(_arg0); end
  def on_data(&callback); end
  def on_done(status_code_range = T.unsafe(nil), &callback); end
  def on_error(&callback); end
  def on_headers(status_code_range = T.unsafe(nil), &block); end
  def on_success(status_code_range = T.unsafe(nil), &callback); end
  def reset; end
  def signal_data(chunk); end
  def signal_done(options = T.unsafe(nil)); end
  def signal_error(networking_error); end
  def signal_headers(status_code, headers); end
  def status_code; end
  def status_code=(_arg0); end

  private

  def emit(event_name, *args); end
  def listener(range, callback); end
end

module Seahorse::Client::Logging; end

class Seahorse::Client::Logging::Formatter
  def initialize(pattern, options = T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def format(response); end
  def max_string_size; end
  def pattern; end

  private

  def _client_class(response); end
  def _error_class(response); end
  def _error_message(response); end
  def _http_request_body(response); end
  def _http_request_endpoint(response); end
  def _http_request_headers(response); end
  def _http_request_host(response); end
  def _http_request_method(response); end
  def _http_request_port(response); end
  def _http_request_scheme(response); end
  def _http_response_body(response); end
  def _http_response_headers(response); end
  def _http_response_status_code(response); end
  def _operation(response); end
  def _request_params(response); end
  def _retries(response); end
  def _time(response); end
  def method_missing(method_name, *args); end
  def summarize_array(array); end
  def summarize_file(path); end
  def summarize_hash(hash); end
  def summarize_string(str); end
  def summarize_string_hash(hash); end
  def summarize_symbol_hash(hash); end
  def summarize_value(value); end

  class << self
    def colored; end
    def default; end
    def short; end
  end
end

class Seahorse::Client::Logging::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def format(config, response); end
  def log(config, response); end
end

class Seahorse::Client::ManagedFile < ::File
  def open?; end
end

module Seahorse::Client::NetHttp; end

class Seahorse::Client::NetHttp::ConnectionPool
  def initialize(options = T.unsafe(nil)); end

  def clean!; end
  def empty!; end
  def http_continue_timeout; end
  def http_idle_timeout; end
  def http_open_timeout; end
  def http_proxy; end
  def http_read_timeout; end
  def http_wire_trace; end
  def http_wire_trace?; end
  def logger; end
  def request(endpoint, request, &block); end
  def session_for(endpoint, &block); end
  def size; end
  def ssl_ca_bundle; end
  def ssl_ca_directory; end
  def ssl_ca_store; end
  def ssl_timeout; end
  def ssl_verify_peer; end
  def ssl_verify_peer?; end

  private

  def _clean; end
  def http_proxy_parts; end
  def remove_path_and_query(endpoint); end
  def start_session(endpoint); end

  class << self
    def for(options = T.unsafe(nil)); end
    def pools; end

    private

    def pool_options(options); end
  end
end

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
  def initialize(http); end

  def __getobj__; end
  def __setobj__(obj); end
  def finish; end
  def last_used; end
  def request(*args, &block); end
end

Seahorse::Client::NetHttp::ConnectionPool::OPTIONS = T.let(T.unsafe(nil), Hash)

class Seahorse::Client::NetHttp::Handler < ::Seahorse::Client::Handler
  def call(context); end
  def pool_for(config); end

  private

  def build_net_request(request); end
  def complete_response(req, resp, bytes_received); end
  def error_message(req, error); end
  def extract_headers(response); end
  def headers(request); end
  def net_http_request_class(request); end
  def pool_options(config); end
  def session(config, req, &block); end
  def should_verify_bytes?(req, resp); end
  def transmit(config, req, resp); end
  def verify_bytes_received(resp, bytes_received); end
end

Seahorse::Client::NetHttp::Handler::DNS_ERROR_MESSAGES = T.let(T.unsafe(nil), Array)
class Seahorse::Client::NetHttp::Handler::InvalidHttpVerbError < ::StandardError; end
Seahorse::Client::NetHttp::Handler::NETWORK_ERRORS = T.let(T.unsafe(nil), Array)

class Seahorse::Client::NetHttp::Handler::TruncatedBodyError < ::IOError
  def initialize(bytes_expected, bytes_received); end
end

module Seahorse::Client::NetHttp::Patches
  class << self
    def apply!; end
  end
end

module Seahorse::Client::NetHttp::Patches::PatchDefaultContentType
  def supply_default_content_type; end
end

class Seahorse::Client::NetworkingError < ::StandardError
  def initialize(error, msg = T.unsafe(nil)); end

  def original_error; end
end

class Seahorse::Client::Plugin
  extend ::Seahorse::Client::HandlerBuilder

  def add_handlers(handlers, config); end
  def add_options(config); end
  def after_initialize(client); end
  def before_initialize(client_class, options); end

  class << self
    def after_initialize(&block); end
    def after_initialize_hooks; end
    def before_initialize(&block); end
    def before_initialize_hooks; end
    def handlers; end
    def literal(string); end
    def option(name, default = T.unsafe(nil), options = T.unsafe(nil), &block); end
    def options; end
  end
end

class Seahorse::Client::Plugin::PluginOption
  def initialize(name, options = T.unsafe(nil)); end

  def default; end
  def default=(_arg0); end
  def default_block; end
  def default_block=(_arg0); end
  def doc_default(options); end
  def doc_default=(_arg0); end
  def doc_type; end
  def doc_type=(_arg0); end
  def docstring; end
  def docstring=(_arg0); end
  def documented?; end
  def name; end
  def required; end
  def required=(_arg0); end
end

class Seahorse::Client::PluginList
  include ::Enumerable

  def initialize(plugins = T.unsafe(nil), options = T.unsafe(nil)); end

  def add(plugin); end
  def each(&block); end
  def remove(plugin); end
  def set(plugins); end

  private

  def _add(plugin); end
  def each_plugin(&block); end
end

class Seahorse::Client::PluginList::PluginWrapper
  def initialize(plugin); end

  def canonical_name; end
  def eql?(other); end
  def hash; end
  def plugin; end

  private

  def require_plugin; end

  class << self
    def new(plugin); end
  end
end

module Seahorse::Client::Plugins; end
class Seahorse::Client::Plugins::ContentLength < ::Seahorse::Client::Plugin; end

class Seahorse::Client::Plugins::ContentLength::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

Seahorse::Client::Plugins::ContentLength::Handler::METHODS_WITHOUT_BODY = T.let(T.unsafe(nil), Set)

class Seahorse::Client::Plugins::Endpoint < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def after_initialize(client); end
end

class Seahorse::Client::Plugins::Endpoint::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

class Seahorse::Client::Plugins::H2 < ::Seahorse::Client::Plugin; end

class Seahorse::Client::Plugins::Logging < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

class Seahorse::Client::Plugins::NetHttp < ::Seahorse::Client::Plugin
  class << self
    def resolve_http_open_timeout(cfg); end
    def resolve_http_read_timeout(cfg); end
    def resolve_ssl_timeout(cfg); end
  end
end

class Seahorse::Client::Plugins::RaiseResponseErrors < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

class Seahorse::Client::Plugins::RaiseResponseErrors::Handler < ::Seahorse::Client::Handler
  def call(context); end
end

class Seahorse::Client::Plugins::ReadCallbackIO
  extend ::Forwardable

  def initialize(io, on_read = T.unsafe(nil)); end

  def io; end
  def read(*args); end
  def size(*args, &block); end

  private

  def handle_chunk(chunk); end
end

class Seahorse::Client::Plugins::RequestCallback < ::Seahorse::Client::Plugin; end

class Seahorse::Client::Plugins::RequestCallback::OptionHandler < ::Seahorse::Client::Handler
  def call(context); end
end

class Seahorse::Client::Plugins::RequestCallback::ReadCallbackHandler < ::Seahorse::Client::Handler
  def add_event_listeners(context); end
  def call(context); end
end

class Seahorse::Client::Plugins::ResponseTarget < ::Seahorse::Client::Plugin; end

class Seahorse::Client::Plugins::ResponseTarget::Handler < ::Seahorse::Client::Handler
  def call(context); end

  private

  def add_event_listeners(context, target); end
  def io(target, headers); end
end

class Seahorse::Client::Request
  include ::Seahorse::Client::HandlerBuilder

  def initialize(handlers, context); end

  def context; end
  def handlers; end
  def send_request(options = T.unsafe(nil), &block); end
end

class Seahorse::Client::RequestContext
  def initialize(options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def authorizer; end
  def authorizer=(_arg0); end
  def client; end
  def client=(_arg0); end
  def config; end
  def config=(_arg0); end
  def http_request; end
  def http_request=(_arg0); end
  def http_response; end
  def http_response=(_arg0); end
  def metadata; end
  def operation; end
  def operation=(_arg0); end
  def operation_name; end
  def operation_name=(_arg0); end
  def params; end
  def params=(_arg0); end
  def retries; end
  def retries=(_arg0); end
end

class Seahorse::Client::Response
  def initialize(options = T.unsafe(nil)); end

  def __getobj__; end
  def __setobj__(obj); end
  def context; end
  def data; end
  def data=(_arg0); end
  def error; end
  def error=(_arg0); end
  def on(range, &_block); end
  def on_complete(&block); end
  def on_success(&block); end
  def successful?; end
end

module Seahorse::Model; end

class Seahorse::Model::Api
  def initialize; end

  def add_authorizer(name, authorizer); end
  def add_operation(name, operation); end
  def async_operation_names; end
  def authorizer(name); end
  def authorizer_names; end
  def authorizers(&block); end
  def endpoint_operation; end
  def endpoint_operation=(_arg0); end
  def inspect(*args); end
  def metadata; end
  def metadata=(_arg0); end
  def operation(name); end
  def operation_names; end
  def operations(&block); end
  def require_endpoint_discovery; end
  def require_endpoint_discovery=(_arg0); end
  def version; end
  def version=(_arg0); end
end

class Seahorse::Model::Authorizer
  def initialize; end

  def name; end
  def name=(_arg0); end
  def placement; end
  def placement=(_arg0); end
  def type; end
  def type=(_arg0); end
end

class Seahorse::Model::Operation
  def initialize; end

  def [](key); end
  def []=(key, value); end
  def async; end
  def async=(_arg0); end
  def authorizer; end
  def authorizer=(_arg0); end
  def deprecated; end
  def deprecated=(_arg0); end
  def documentation; end
  def documentation=(_arg0); end
  def endpoint_discovery; end
  def endpoint_discovery=(_arg0); end
  def endpoint_operation; end
  def endpoint_operation=(_arg0); end
  def endpoint_pattern; end
  def endpoint_pattern=(_arg0); end
  def errors; end
  def errors=(_arg0); end
  def http_checksum_required; end
  def http_checksum_required=(_arg0); end
  def http_method; end
  def http_method=(_arg0); end
  def http_request_uri; end
  def http_request_uri=(_arg0); end
  def input; end
  def input=(_arg0); end
  def name; end
  def name=(_arg0); end
  def output; end
  def output=(_arg0); end
  def require_apikey; end
  def require_apikey=(_arg0); end
end

module Seahorse::Model::Shapes; end

class Seahorse::Model::Shapes::BlobShape < ::Seahorse::Model::Shapes::Shape
  def max; end
  def max=(_arg0); end
  def min; end
  def min=(_arg0); end
end

class Seahorse::Model::Shapes::BooleanShape < ::Seahorse::Model::Shapes::Shape; end
class Seahorse::Model::Shapes::DocumentShape < ::Seahorse::Model::Shapes::Shape; end

class Seahorse::Model::Shapes::FloatShape < ::Seahorse::Model::Shapes::Shape
  def max; end
  def max=(_arg0); end
  def min; end
  def min=(_arg0); end
end

class Seahorse::Model::Shapes::IntegerShape < ::Seahorse::Model::Shapes::Shape
  def max; end
  def max=(_arg0); end
  def min; end
  def min=(_arg0); end
end

class Seahorse::Model::Shapes::ListShape < ::Seahorse::Model::Shapes::Shape
  def flattened; end
  def flattened=(_arg0); end
  def max; end
  def max=(_arg0); end
  def member; end
  def member=(_arg0); end
  def min; end
  def min=(_arg0); end
end

class Seahorse::Model::Shapes::MapShape < ::Seahorse::Model::Shapes::Shape
  def flattened; end
  def flattened=(_arg0); end
  def key; end
  def key=(_arg0); end
  def max; end
  def max=(_arg0); end
  def min; end
  def min=(_arg0); end
  def value; end
  def value=(_arg0); end
end

class Seahorse::Model::Shapes::Shape
  def initialize(options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def documentation; end
  def documentation=(_arg0); end
  def name; end
  def name=(_arg0); end
  def union; end
  def union=(_arg0); end
end

class Seahorse::Model::Shapes::ShapeRef
  def initialize(options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def deprecated; end
  def deprecated=(_arg0); end
  def document; end
  def document=(_arg0); end
  def documentation; end
  def documentation=(_arg0); end
  def event; end
  def event=(_arg0); end
  def eventheader; end
  def eventheader=(_arg0); end
  def eventheader_type; end
  def eventheader_type=(_arg0); end
  def eventpayload; end
  def eventpayload=(_arg0); end
  def eventpayload_type; end
  def eventpayload_type=(_arg0); end
  def eventstream; end
  def eventstream=(_arg0); end
  def location; end
  def location=(location); end
  def location_name; end
  def location_name=(location_name); end
  def required; end
  def required=(_arg0); end
  def shape; end
  def shape=(_arg0); end
end

class Seahorse::Model::Shapes::StringShape < ::Seahorse::Model::Shapes::Shape
  def enum; end
  def enum=(_arg0); end
  def max; end
  def max=(_arg0); end
  def min; end
  def min=(_arg0); end
end

class Seahorse::Model::Shapes::StructureShape < ::Seahorse::Model::Shapes::Shape
  def initialize(options = T.unsafe(nil)); end

  def add_member(name, shape_ref); end
  def member(name); end
  def member?(member_name); end
  def member_by_location_name(location_name); end
  def member_names; end
  def members; end
  def required; end
  def required=(_arg0); end
  def struct_class; end
  def struct_class=(_arg0); end
end

class Seahorse::Model::Shapes::TimestampShape < ::Seahorse::Model::Shapes::Shape; end

class Seahorse::Model::Shapes::UnionShape < ::Seahorse::Model::Shapes::StructureShape
  def initialize(options = T.unsafe(nil)); end

  def add_member_subclass(member, subclass); end
  def member_subclass(member); end
end

module Seahorse::Util
  class << self
    def host_label?(str); end
    def uri_escape(string); end
    def uri_path_escape(path); end
  end
end
