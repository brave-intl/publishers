# typed: ignore

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activerecord-session_store` gem.
# Please instead update this file by running `bin/tapioca gem activerecord-session_store`.

module ActionDispatch
  extend ::ActiveSupport::Autoload

  def test_app; end
  def test_app=(val); end

  class << self
    def test_app; end
    def test_app=(val); end
  end
end

module ActionDispatch::Session; end

class ActionDispatch::Session::ActiveRecordStore < ::ActionDispatch::Session::AbstractSecureStore
  def session_class; end
  def session_class=(val); end

  private

  def delete_session(request, session_id, options); end
  def find_session(request, id); end
  def get_session(request, sid); end
  def get_session_model(request, id); end
  def get_session_with_fallback(sid); end
  def logger; end
  def write_session(request, sid, session_data, options); end

  class << self
    def private_session_id?(session_id); end
    def session_class; end
    def session_class=(val); end
  end
end

ActionDispatch::Session::ActiveRecordStore::ENV_SESSION_OPTIONS_KEY = T.let(T.unsafe(nil), String)

module ActionDispatch::Session::ActiveRecordStore::NilLogger
  class << self
    def silence; end
  end
end

ActionDispatch::Session::ActiveRecordStore::SESSION_RECORD_KEY = T.let(T.unsafe(nil), String)

module ActiveRecord
  extend ::ActiveSupport::Autoload

  class << self
    def eager_load!; end
    def gem_version; end
    def version; end
  end
end

class ActiveRecord::MigrationProxy < ::Struct
  def initialize(name, version, filename, scope); end

  def announce(*_arg0, &_arg1); end
  def basename; end
  def disable_ddl_transaction(*_arg0, &_arg1); end
  def filename; end
  def filename=(_); end
  def migrate(*_arg0, &_arg1); end
  def name; end
  def name=(_); end
  def scope; end
  def scope=(_); end
  def version; end
  def version=(_); end
  def write(*_arg0, &_arg1); end

  private

  def load_migration; end
  def migration; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::SessionStore; end

module ActiveRecord::SessionStore::ClassMethods
  def create_table!; end
  def deserialize(data); end
  def drop_table!; end
  def serialize(data); end
  def serializer; end
  def serializer=(val); end
  def serializer_class; end

  class << self
    def serializer; end
    def serializer=(val); end
  end
end

class ActiveRecord::SessionStore::ClassMethods::HybridSerializer < ::ActiveRecord::SessionStore::ClassMethods::JsonSerializer
  class << self
    def load(value); end
    def needs_migration?(value); end
  end
end

ActiveRecord::SessionStore::ClassMethods::HybridSerializer::MARSHAL_SIGNATURE = T.let(T.unsafe(nil), String)

class ActiveRecord::SessionStore::ClassMethods::JsonSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

class ActiveRecord::SessionStore::ClassMethods::MarshalSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

class ActiveRecord::SessionStore::ClassMethods::NullSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

class ActiveRecord::SessionStore::Railtie < ::Rails::Railtie; end

class ActiveRecord::SessionStore::Session < ::ActiveRecord::Base
  include ::ActiveRecord::SessionStore::Session::GeneratedAttributeMethods
  include ::ActiveRecord::SessionStore::Session::GeneratedAssociationMethods
  extend ::ActiveRecord::SessionStore::ClassMethods

  def initialize(*_arg0); end

  def data; end
  def data=(_arg0); end
  def data_column_name; end
  def data_column_name=(val); end
  def loaded?; end
  def secure!; end

  private

  def raise_on_session_data_overflow!; end
  def serialize_data!; end

  class << self
    def __callbacks; end
    def _validators; end
    def data_column_name; end
    def data_column_name=(val); end
    def data_column_size_limit; end
    def defined_enums; end
    def find_by_session_id(session_id); end

    private

    def session_id_column; end
    def setup_sessid_compatibility!; end
  end
end

module ActiveRecord::SessionStore::Session::GeneratedAssociationMethods; end
module ActiveRecord::SessionStore::Session::GeneratedAttributeMethods; end
ActiveRecord::SessionStore::Session::SEMAPHORE = T.let(T.unsafe(nil), Thread::Mutex)

class ActiveRecord::SessionStore::SqlBypass
  extend ::ActiveRecord::SessionStore::ClassMethods

  def initialize(attributes); end

  def connection(*_arg0, &_arg1); end
  def connection=(arg); end
  def connection_pool(*_arg0, &_arg1); end
  def connection_pool=(arg); end
  def data; end
  def data=(_arg0); end
  def data_column; end
  def data_column=(val); end
  def destroy; end
  def loaded?; end
  def new_record; end
  def new_record?; end
  def persisted?; end
  def save; end
  def session_id; end
  def session_id=(_arg0); end
  def session_id_column; end
  def session_id_column=(val); end
  def table_name; end
  def table_name=(val); end

  class << self
    def connection; end
    def connection=(_arg0); end
    def connection_pool; end
    def connection_pool=(_arg0); end
    def data_column; end
    def data_column=(val); end
    def data_column_name; end
    def find_by_session_id(session_id); end
    def session_id_column; end
    def session_id_column=(val); end
    def table_name; end
    def table_name=(val); end
  end
end

ActiveRecord::SessionStore::VERSION = T.let(T.unsafe(nil), String)
ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError
