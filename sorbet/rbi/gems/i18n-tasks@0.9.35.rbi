# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `i18n-tasks` gem.
# Please instead update this file by running `bin/tapioca gem i18n-tasks`.

module I18n
  extend ::I18n::Base

  class << self
    def cache_key_digest; end
    def cache_key_digest=(key_digest); end
    def cache_namespace; end
    def cache_namespace=(namespace); end
    def cache_store; end
    def cache_store=(store); end
    def fallbacks; end
    def fallbacks=(fallbacks); end
    def interpolate(string, values); end
    def interpolate_hash(string, values); end
    def new_double_nested_cache; end
    def perform_caching?; end
  end
end

I18n::DEFAULT_INTERPOLATION_PATTERNS = T.let(T.unsafe(nil), Array)
I18n::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
I18n::INTERPOLATION_PATTERN = T.let(T.unsafe(nil), Regexp)
I18n::JSON = ActiveSupport::JSON
I18n::RESERVED_KEYS = T.let(T.unsafe(nil), Array)
I18n::RESERVED_KEYS_PATTERN = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks
  class << self
    def add_commands(commands_module); end
    def add_scanner(scanner_class_name, scanner_opts = T.unsafe(nil)); end
    def gem_path; end
    def verbose=(_arg0); end
    def verbose?; end
  end
end

class I18n::Tasks::BaseTask
  include ::I18n::Tasks::SplitKey
  include ::I18n::Tasks::KeyPatternMatching
  include ::I18n::Tasks::PluralKeys
  include ::I18n::Tasks::References
  include ::I18n::Tasks::HtmlKeys
  include ::I18n::Tasks::UsedKeys
  include ::I18n::Tasks::IgnoreKeys
  include ::I18n::Tasks::MissingKeys
  include ::I18n::Tasks::Interpolations
  include ::I18n::Tasks::UnusedKeys
  include ::I18n::Tasks::Translation
  include ::I18n::Tasks::Logging
  include ::I18n::Tasks::Configuration
  include ::I18n::Tasks::Data
  include ::I18n::Tasks::Stats

  def initialize(config = T.unsafe(nil), config_file: T.unsafe(nil)); end

  def inspect; end
end

class I18n::Tasks::CommandError < ::StandardError
  def initialize(error = T.unsafe(nil), message); end
end

module I18n::Tasks::Concurrent; end

class I18n::Tasks::Concurrent::Cache
  def initialize; end

  def fetch(key, &block); end
end

class I18n::Tasks::Concurrent::CachedValue
  def initialize(&computation); end

  def get; end

  private

  def get_result_volatile; end
  def set_result_volatile(value); end
end

I18n::Tasks::Concurrent::CachedValue::NULL = T.let(T.unsafe(nil), Object)

module I18n::Tasks::Configuration
  def base_locale; end
  def config; end
  def config=(conf); end
  def config_for_inspect; end
  def config_sections; end
  def data_config; end
  def file_config; end
  def ignore_config(type = T.unsafe(nil)); end
  def internal_locale; end
  def locales; end
  def translation_config; end

  private

  def to_hash_from_indifferent(value); end
end

I18n::Tasks::Configuration::CONFIG_FILES = T.let(T.unsafe(nil), Array)
I18n::Tasks::Configuration::DEFAULTS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::Configuration::IGNORE_TYPES = T.let(T.unsafe(nil), Array)

module I18n::Tasks::Data
  def build_tree(hash); end
  def data; end
  def data_forest(locales = T.unsafe(nil)); end
  def empty_forest; end
  def external_key?(key, locale = T.unsafe(nil)); end
  def key_value?(key, locale = T.unsafe(nil)); end
  def node(key, locale = T.unsafe(nil)); end
  def non_normalized_paths(locales: T.unsafe(nil)); end
  def normalize_store!(locales: T.unsafe(nil), force_pattern_router: T.unsafe(nil)); end
  def t(key, locale = T.unsafe(nil)); end
  def t_proc(locale = T.unsafe(nil)); end
  def tree(sel); end
end

module I18n::Tasks::Data::Adapter; end

module I18n::Tasks::Data::Adapter::JsonAdapter
  class << self
    def dump(tree, opts); end
    def parse(str, opts); end

    private

    def parse_opts(opts); end
  end
end

module I18n::Tasks::Data::Adapter::YamlAdapter
  class << self
    def dump(tree, options); end
    def parse(str, options); end
  end
end

I18n::Tasks::Data::DATA_DEFAULTS = T.let(T.unsafe(nil), Hash)

module I18n::Tasks::Data::FileFormats
  mixes_in_class_methods ::I18n::Tasks::Data::FileFormats::ClassMethods

  def adapter_dump(tree, format); end
  def adapter_op(op, format, tree, config); end
  def adapter_parse(tree, format); end

  protected

  def load_file(path); end
  def normalized?(path, tree); end
  def read_config(format); end
  def read_file(path); end
  def write_config(format); end
  def write_tree(path, tree, sort = T.unsafe(nil)); end

  class << self
    def included(base); end
  end
end

module I18n::Tasks::Data::FileFormats::ClassMethods
  def adapter_by_name(name); end
  def adapter_name_for_path(path); end
  def adapter_names; end
  def register_adapter(name, pattern, adapter); end
end

class I18n::Tasks::Data::FileSystem < ::I18n::Tasks::Data::FileSystemBase; end

class I18n::Tasks::Data::FileSystemBase
  include ::I18n::Tasks::Data::FileFormats
  include ::I18n::Tasks::Logging
  extend ::I18n::Tasks::Data::FileFormats::ClassMethods

  def initialize(config = T.unsafe(nil)); end

  def [](locale); end
  def []=(locale, tree); end
  def available_locales; end
  def base_locale; end
  def config; end
  def config=(config); end
  def external(locale); end
  def get(locale); end
  def locales; end
  def locales=(_arg0); end
  def merge!(forest); end
  def non_normalized_paths(locale); end
  def reload; end
  def remove_by_key!(forest); end
  def router; end
  def router=(_arg0); end
  def set(locale, tree); end
  def t(key, locale); end
  def with_router(router); end
  def write(forest); end

  protected

  def filter_nil_keys!(path, data, suffix = T.unsafe(nil)); end
  def read_locale(locale, paths: T.unsafe(nil)); end
end

I18n::Tasks::Data::FileSystemBase::DEFAULTS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::Data::FileSystemBase::ROUTER_NAME_ALIASES = T.let(T.unsafe(nil), Hash)
module I18n::Tasks::Data::Router; end

class I18n::Tasks::Data::Router::ConservativeRouter < ::I18n::Tasks::Data::Router::PatternRouter
  def initialize(adapter, config); end

  def route(locale, forest, &block); end

  protected

  def adapter; end
  def base_locale; end
  def base_tree; end
  def key_path(locale, key); end
  def locales; end
end

class I18n::Tasks::Data::Router::PatternRouter
  include ::I18n::Tasks::KeyPatternMatching

  def initialize(_adapter, data_config); end

  def route(locale, forest, &block); end
  def routes; end

  private

  def compile_routes(routes); end
end

module I18n::Tasks::Data::Tree; end

class I18n::Tasks::Data::Tree::Node
  include ::Enumerable
  include ::I18n::Tasks::Data::Tree::Traversal

  def initialize(key:, value: T.unsafe(nil), data: T.unsafe(nil), parent: T.unsafe(nil), children: T.unsafe(nil), warn_about_add_children_to_leaf: T.unsafe(nil)); end

  def [](key); end
  def []=(full_key, node); end
  def append(nodes); end
  def append!(nodes); end
  def attributes; end
  def children; end
  def children=(children); end
  def children?; end
  def data; end
  def data?; end
  def derive(new_attr = T.unsafe(nil)); end
  def each(&block); end
  def format_value_for_inspect(value); end
  def full_key(root: T.unsafe(nil)); end
  def get(key); end
  def inspect(level = T.unsafe(nil)); end
  def key; end
  def leaf?; end
  def parent; end
  def parent?; end
  def reference?; end
  def root; end
  def root?; end
  def set(full_key, node); end
  def to_hash(sort = T.unsafe(nil)); end
  def to_json(*_arg0, &_arg1); end
  def to_nodes; end
  def to_siblings; end
  def to_yaml(*_arg0, &_arg1); end
  def value; end
  def value=(_arg0); end
  def value_or_children_hash; end
  def walk_from_root(&visitor); end
  def walk_to_root(&visitor); end

  protected

  def dirty!; end

  class << self
    def from_key_value(key, value); end
  end
end

class I18n::Tasks::Data::Tree::Nodes
  include ::Enumerable
  include ::I18n::Tasks::Data::Tree::Traversal

  def initialize(opts = T.unsafe(nil)); end

  def +(nodes); end
  def <<(other); end
  def append(other); end
  def append!(other); end
  def attributes; end
  def blank?(*_arg0, &_arg1); end
  def children(&block); end
  def children?(*_arg0); end
  def derive(new_attr = T.unsafe(nil)); end
  def each(*_arg0, &_arg1); end
  def empty?(*_arg0, &_arg1); end
  def inspect; end
  def list; end
  def merge!(nodes); end
  def present?(*_arg0, &_arg1); end
  def remove!(node); end
  def size(*_arg0, &_arg1); end
  def to_a(*_arg0, &_arg1); end
  def to_hash(sort = T.unsafe(nil)); end
  def to_json(*_arg0, &_arg1); end
  def to_nodes; end
  def to_yaml(*_arg0, &_arg1); end

  protected

  def dirty!; end
end

class I18n::Tasks::Data::Tree::Siblings < ::I18n::Tasks::Data::Tree::Nodes
  include ::I18n::Tasks::SplitKey
  include ::I18n::Tasks::PluralKeys
  extend ::I18n::Tasks::SplitKey

  def initialize(opts = T.unsafe(nil)); end

  def [](full_key); end
  def []=(full_key, node); end
  def append(nodes); end
  def append!(nodes); end
  def attributes; end
  def get(full_key); end
  def key_to_node; end
  def merge(nodes); end
  def merge!(nodes, on_leaves_merge: T.unsafe(nil)); end
  def merge_node!(node, on_leaves_merge: T.unsafe(nil)); end
  def mv_key!(from_pattern, to_pattern, root: T.unsafe(nil)); end
  def parent; end
  def remove!(node); end
  def remove_nodes_and_emptied_ancestors(nodes); end
  def remove_nodes_and_emptied_ancestors!(nodes); end
  def rename_key(key, new_key); end
  def replace_node!(node, new_node); end
  def set(full_key, node); end
  def set_root_key!(new_key, data = T.unsafe(nil)); end
  def subtract_by_key(other); end
  def subtract_by_key!(other); end
  def subtract_keys(keys); end
  def subtract_keys!(keys); end

  private

  def add_ancestors_that_only_contain_nodes!(nodes); end
  def conditionally_warn_add_children_to_leaf(node, children); end
  def find_nodes(keys); end
  def warn_add_children_to_leaf(node); end

  class << self
    def [](hash, opts = T.unsafe(nil)); end
    def build_forest(opts = T.unsafe(nil), &block); end
    def from_flat_pairs(pairs); end
    def from_key_attr(key_attrs, opts = T.unsafe(nil), &block); end
    def from_key_names(keys, opts = T.unsafe(nil), &block); end
    def from_key_occurrences(key_occurrences); end
    def from_nested_hash(hash, opts = T.unsafe(nil)); end
    def null; end

    private

    def parse_parent_opt!(opts); end
  end
end

module I18n::Tasks::Data::Tree::Traversal
  def breadth_first(&visitor); end
  def depth_first(&visitor); end
  def get_nodes_by_key_filter(root: T.unsafe(nil), &block); end
  def grep_keys(match, opts = T.unsafe(nil)); end
  def intersect_keys(other_tree, key_opts = T.unsafe(nil), &block); end
  def key_names(root: T.unsafe(nil)); end
  def key_values(root: T.unsafe(nil)); end
  def keys(root: T.unsafe(nil), &visitor); end
  def leaves(&visitor); end
  def levels(&block); end
  def nodes(&block); end
  def root_key_value_data(sort = T.unsafe(nil)); end
  def root_key_values(sort = T.unsafe(nil)); end
  def select_keys(root: T.unsafe(nil), &block); end
  def select_keys!(root: T.unsafe(nil), &block); end
  def select_nodes(&block); end
  def select_nodes!(&block); end
  def set_each_value!(val_pattern, key_pattern = T.unsafe(nil), &value_proc); end
end

module I18n::Tasks::HtmlKeys
  def html_key?(full_key, locale); end
end

I18n::Tasks::HtmlKeys::HTML_KEY_PATTERN = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::HtmlKeys::MAYBE_PLURAL_HTML_KEY_PATTERN = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks::IgnoreKeys
  def ignore_key?(key, ignore_type, locale = T.unsafe(nil)); end
  def ignore_pattern(type, locale = T.unsafe(nil)); end
end

module I18n::Tasks::Interpolations
  def inconsistent_interpolations(locales: T.unsafe(nil), base_locale: T.unsafe(nil)); end
end

I18n::Tasks::Interpolations::VARIABLE_REGEX = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks::KeyPatternMatching
  extend ::I18n::Tasks::KeyPatternMatching

  def compile_key_pattern(key_pattern); end
  def compile_patterns_re(key_patterns); end
  def key_pattern_re_body(key_pattern); end
end

I18n::Tasks::KeyPatternMatching::MATCH_NOTHING = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks::LocaleList
  private

  def normalize_locale_list(locales, base_locale, include_base = T.unsafe(nil)); end

  class << self
    def normalize_locale_list(locales, base_locale, include_base = T.unsafe(nil)); end
  end
end

module I18n::Tasks::LocalePathname
  class << self
    def replace_locale(path, from, to); end

    private

    def path_locale_re(locale); end
  end
end

module I18n::Tasks::Logging
  private

  def log_error(message); end
  def log_stderr(*args); end
  def log_verbose(message = T.unsafe(nil)); end
  def log_warn(message); end
  def program_name; end
  def warn_deprecated(message); end

  class << self
    def log_error(message); end
    def log_stderr(*args); end
    def log_verbose(message = T.unsafe(nil)); end
    def log_warn(message); end
    def program_name; end
    def warn_deprecated(message); end
  end
end

I18n::Tasks::Logging::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
I18n::Tasks::Logging::PROGRAM_NAME = T.let(T.unsafe(nil), String)

module I18n::Tasks::MissingKeys
  def collapse_same_key_in_locales!(forest); end
  def eq_base_keys(opts = T.unsafe(nil)); end
  def equal_values_tree(locale, compare_to = T.unsafe(nil)); end
  def load_rails_i18n_pluralization!(locale); end
  def locale_key_missing?(locale, key); end
  def missing_diff_forest(locales, base = T.unsafe(nil)); end
  def missing_diff_tree(locale, compared_to = T.unsafe(nil)); end
  def missing_keys(locales: T.unsafe(nil), types: T.unsafe(nil), base_locale: T.unsafe(nil)); end
  def missing_keys_types; end
  def missing_plural_forest(locales, _base = T.unsafe(nil)); end
  def missing_used_forest(locales, _base = T.unsafe(nil)); end
  def missing_used_tree(locale); end
  def required_plural_keys_for_locale(locale); end

  private

  def alternate_locale_from(locale); end
  def plural_keys_for_locale(locale); end
  def set_from_rails_i18n_pluralization(configuration, locale); end

  class << self
    def missing_keys_types; end
  end
end

I18n::Tasks::MissingKeys::MISSING_TYPES = T.let(T.unsafe(nil), Array)

module I18n::Tasks::PluralKeys
  def collapse_plural_nodes!(tree); end
  def depluralize_key(key, locale = T.unsafe(nil)); end
  def non_plural_other?(s); end
  def plural_forms?(s); end
  def plural_nodes(tree); end
  def plural_suffix?(key); end
end

I18n::Tasks::PluralKeys::CLDR_CATEGORY_KEYS = T.let(T.unsafe(nil), Array)
I18n::Tasks::PluralKeys::PLURAL_KEY_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::PluralKeys::PLURAL_KEY_SUFFIXES = T.let(T.unsafe(nil), Set)

module I18n::Tasks::References
  def process_references(usages, data_refs = T.unsafe(nil)); end

  private

  def add_occurences!(ref_data, new_resolved_refs); end
  def merge_reference_trees(roots); end
  def process_leaf!(ref, usage, raw_refs, resolved_refs, refs); end
  def process_non_leaf!(ref, usage, raw_refs, resolved_refs, refs); end
end

module I18n::Tasks::Scanners; end

class I18n::Tasks::Scanners::FileScanner < ::I18n::Tasks::Scanners::Scanner
  def initialize(config: T.unsafe(nil), file_finder_provider: T.unsafe(nil), file_reader: T.unsafe(nil)); end

  def config; end
  def keys; end

  protected

  def find_files; end
  def read_file(path); end
  def scan_file(_path); end
  def traverse_files(&block); end
end

module I18n::Tasks::Scanners::Files; end

class I18n::Tasks::Scanners::Files::CachingFileFinder < ::I18n::Tasks::Scanners::Files::FileFinder
  def initialize(**args); end

  def find_files; end

  private

  def uncached_find_files; end
end

class I18n::Tasks::Scanners::Files::CachingFileFinderProvider
  def initialize(exclude: T.unsafe(nil)); end

  def get(**file_finder_args); end
end

class I18n::Tasks::Scanners::Files::CachingFileReader < ::I18n::Tasks::Scanners::Files::FileReader
  def initialize; end

  def read_file(path); end
end

class I18n::Tasks::Scanners::Files::FileFinder
  include ::I18n::Tasks::Logging

  def initialize(paths: T.unsafe(nil), only: T.unsafe(nil), exclude: T.unsafe(nil)); end

  def find_files; end
  def traverse_files(&block); end

  private

  def path_fnmatch_any?(path, globs); end
end

class I18n::Tasks::Scanners::Files::FileReader
  def read_file(path); end
end

module I18n::Tasks::Scanners::OccurrenceFromPosition
  def occurrence_from_position(path, contents, position, raw_key: T.unsafe(nil)); end
end

class I18n::Tasks::Scanners::PatternMapper < ::I18n::Tasks::Scanners::FileScanner
  include ::I18n::Tasks::Scanners::RelativeKeys
  include ::I18n::Tasks::Scanners::OccurrenceFromPosition
  include ::I18n::Tasks::Scanners::RubyKeyLiterals

  def initialize(config:, **args); end

  protected

  def scan_file(path); end

  private

  def configure_patterns(patterns); end
end

I18n::Tasks::Scanners::PatternMapper::KEY_GROUP = T.let(T.unsafe(nil), String)

class I18n::Tasks::Scanners::PatternScanner < ::I18n::Tasks::Scanners::FileScanner
  include ::I18n::Tasks::Scanners::RelativeKeys
  include ::I18n::Tasks::Scanners::OccurrenceFromPosition
  include ::I18n::Tasks::Scanners::RubyKeyLiterals

  def initialize(**args); end

  protected

  def closest_method(occurrence); end
  def default_pattern; end
  def exclude_line?(line, path); end
  def first_argument_re; end
  def key_relative_to_method?(path); end
  def match_to_key(match, path, location); end
  def scan_file(path); end
  def translate_call_re; end
  def valid_key?(key); end
end

I18n::Tasks::Scanners::PatternScanner::IGNORE_LINES = T.let(T.unsafe(nil), Hash)
I18n::Tasks::Scanners::PatternScanner::TRANSLATE_CALL_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Scanners::PatternScanner::VALID_KEY_RE_DYNAMIC = T.let(T.unsafe(nil), Regexp)

class I18n::Tasks::Scanners::PatternWithScopeScanner < ::I18n::Tasks::Scanners::PatternScanner
  protected

  def default_pattern; end
  def expr_re; end
  def extract_literal_or_array_of_literals(s); end
  def first_argument_re; end
  def match_to_key(match, path, location); end
  def scope_arg_re; end
  def strip_literal(val); end
end

module I18n::Tasks::Scanners::RelativeKeys
  def absolute_key(key, path, roots: T.unsafe(nil), exclude_method_name_paths: T.unsafe(nil), calling_method: T.unsafe(nil)); end

  private

  def expand_path(path); end
  def path_root(path, roots); end
  def prefix(normalized_path, calling_method: T.unsafe(nil)); end
end

I18n::Tasks::Scanners::RelativeKeys::DOT = T.let(T.unsafe(nil), String)
module I18n::Tasks::Scanners::Results; end

class I18n::Tasks::Scanners::Results::KeyOccurrences
  def initialize(key:, occurrences:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def key; end
  def occurrences; end

  class << self
    def merge_keys(keys_occurrences); end
  end
end

class I18n::Tasks::Scanners::Results::Occurrence
  def initialize(path:, pos:, line_num:, line_pos:, line:, raw_key: T.unsafe(nil), default_arg: T.unsafe(nil)); end

  def ==(other); end
  def default_arg; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def line; end
  def line_num; end
  def line_pos; end
  def path; end
  def pos; end
  def raw_key; end
  def raw_key=(_arg0); end
end

class I18n::Tasks::Scanners::RubyAstCallFinder
  include ::AST::Processor::Mixin

  def initialize(receiver_messages:); end

  def collect_calls(root_node); end
  def find_calls(root_node, &block); end
  def handler_missing(node); end
  def on_def(node); end
  def on_send(send_node); end
end

class I18n::Tasks::Scanners::RubyAstScanner < ::I18n::Tasks::Scanners::FileScanner
  include ::I18n::Tasks::Scanners::RelativeKeys
  include ::AST::Sexp

  def initialize(**args); end

  protected

  def extract_array_as_string(node, array_join_with:, array_flatten: T.unsafe(nil), array_reject_blank: T.unsafe(nil)); end
  def extract_hash_pair(node, key); end
  def extract_string(node, array_join_with: T.unsafe(nil), array_flatten: T.unsafe(nil), array_reject_blank: T.unsafe(nil)); end
  def keys_relative_to_calling_method?(path); end
  def make_buffer(path, contents = T.unsafe(nil)); end
  def range_to_occurrence(raw_key, range, default_arg: T.unsafe(nil)); end
  def scan_file(path); end
  def send_node_to_key_occurrence(send_node, method_name, location: T.unsafe(nil)); end
end

I18n::Tasks::Scanners::RubyAstScanner::MAGIC_COMMENT_PREFIX = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Scanners::RubyAstScanner::RECEIVER_MESSAGES = T.let(T.unsafe(nil), Array)

module I18n::Tasks::Scanners::RubyKeyLiterals
  def literal_re; end
  def strip_literal(literal); end
  def valid_key?(key); end
end

I18n::Tasks::Scanners::RubyKeyLiterals::LITERAL_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Scanners::RubyKeyLiterals::VALID_KEY_CHARS = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Scanners::RubyKeyLiterals::VALID_KEY_RE = T.let(T.unsafe(nil), Regexp)

class I18n::Tasks::Scanners::Scanner
  def keys; end
end

class I18n::Tasks::Scanners::ScannerMultiplexer < ::I18n::Tasks::Scanners::Scanner
  def initialize(scanners:); end

  def keys; end

  private

  def collect_results; end
end

module I18n::Tasks::SplitKey
  private

  def key_parts(key, &block); end
  def last_key_part(key); end
  def split_key(key, max = T.unsafe(nil)); end

  class << self
    def key_parts(key, &block); end
    def last_key_part(key); end
    def split_key(key, max = T.unsafe(nil)); end
  end
end

I18n::Tasks::SplitKey::PARENS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::SplitKey::PARENS_ZEROS = T.let(T.unsafe(nil), Array)

module I18n::Tasks::Stats
  def forest_stats(forest); end
end

module I18n::Tasks::StringInterpolation
  private

  def interpolate_soft(s, t = T.unsafe(nil)); end

  class << self
    def interpolate_soft(s, t = T.unsafe(nil)); end
  end
end

module I18n::Tasks::Translation
  def translate_forest(forest, from:, backend: T.unsafe(nil)); end
end

module I18n::Tasks::Translators; end

class I18n::Tasks::Translators::BaseTranslator
  def initialize(i18n_tasks); end

  def translate_forest(forest, from); end

  protected

  def dump_value(value); end
  def fetch_translations(list, opts); end
  def from_values(list, translated_values); end
  def no_results_error_message; end
  def options_for_html; end
  def options_for_plain; end
  def options_for_translate_values(options); end
  def parse_value(untranslated, each_translated); end
  def raise_interpolation_error(untranslated, translated, e); end
  def replace_interpolations(value); end
  def restore_interpolations(untranslated, translated); end
  def to_values(list); end
  def translate_pairs(list, opts); end
  def translate_values(list, **options); end
end

I18n::Tasks::Translators::BaseTranslator::INTERPOLATION_KEY_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Translators::BaseTranslator::UNTRANSLATABLE_STRING = T.let(T.unsafe(nil), String)

class I18n::Tasks::Translators::DeeplTranslator < ::I18n::Tasks::Translators::BaseTranslator
  def initialize(*_arg0); end

  protected

  def no_results_error_message; end
  def options_for_html; end
  def options_for_plain; end
  def options_for_translate_values(**options); end
  def replace_interpolations(value); end
  def restore_interpolations(untranslated, translated); end
  def translate_values(list, from:, to:, **options); end

  private

  def configure_api_key!; end
  def to_deepl_compatible_locale(locale); end
end

class I18n::Tasks::Translators::GoogleTranslator < ::I18n::Tasks::Translators::BaseTranslator
  def initialize(*_arg0); end

  protected

  def no_results_error_message; end
  def options_for_html; end
  def options_for_plain; end
  def options_for_translate_values(from:, to:, **options); end
  def translate_values(list, **options); end

  private

  def api_key; end
  def to_google_translate_compatible_locale(locale); end
end

I18n::Tasks::Translators::GoogleTranslator::SUPPORTED_LOCALES_WITH_REGION = T.let(T.unsafe(nil), Array)

class I18n::Tasks::Translators::YandexTranslator < ::I18n::Tasks::Translators::BaseTranslator
  def initialize(*_arg0); end

  protected

  def no_results_error_message; end
  def options_for_html; end
  def options_for_plain; end
  def options_for_translate_values(from:, to:, **options); end
  def translate_values(list, **options); end

  private

  def api_key; end
  def to_yandex_compatible_locale(locale); end
  def translator; end
end

module I18n::Tasks::UnusedKeys
  def unused_keys(locales: T.unsafe(nil), strict: T.unsafe(nil)); end
  def unused_tree(locale: T.unsafe(nil), strict: T.unsafe(nil)); end
end

module I18n::Tasks::UsedKeys
  def caching_file_finder_provider; end
  def caching_file_reader; end
  def merge_scanner_configs(a, b); end
  def scanner(strict: T.unsafe(nil)); end
  def search_config; end
  def used_in_expr?(key); end
  def used_in_source_tree(key_filter: T.unsafe(nil), strict: T.unsafe(nil)); end
  def used_tree(key_filter: T.unsafe(nil), strict: T.unsafe(nil), include_raw_references: T.unsafe(nil)); end

  private

  def expr_key_re(replacement: T.unsafe(nil)); end
  def replace_key_exp(key, replacement); end
  def strict?(strict); end
end

I18n::Tasks::UsedKeys::ALWAYS_EXCLUDE = T.let(T.unsafe(nil), Array)
I18n::Tasks::UsedKeys::SEARCH_DEFAULTS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::VERSION = T.let(T.unsafe(nil), String)
I18n::VERSION = T.let(T.unsafe(nil), String)
