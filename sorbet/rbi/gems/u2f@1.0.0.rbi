# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `u2f` gem.
# Please instead update this file by running `bin/tapioca gem u2f`.

module U2F
  class << self
    def urlsafe_decode64(string); end
    def urlsafe_encode64(string); end
  end
end

class U2F::AttestationDecodeError < ::U2F::Error; end
class U2F::AttestationSignatureError < ::U2F::Error; end
class U2F::AttestationVerificationError < ::U2F::Error; end
class U2F::AuthenticationFailedError < ::U2F::Error; end

class U2F::ClientData
  def authentication?; end
  def challenge; end
  def challenge=(_arg0); end
  def origin; end
  def origin=(_arg0); end
  def registration?; end
  def typ; end
  def typ=(_arg0); end
  def type; end

  class << self
    def load_from_json(json); end
  end
end

U2F::ClientData::AUTHENTICATION_TYP = T.let(T.unsafe(nil), String)
U2F::ClientData::REGISTRATION_TYP = T.let(T.unsafe(nil), String)
class U2F::ClientDataTypeError < ::U2F::Error; end
class U2F::CounterTooLowError < ::U2F::Error; end
U2F::DIGEST = OpenSSL::Digest::SHA256
class U2F::Error < ::StandardError; end

class U2F::FakeU2F
  def initialize(app_id, options = T.unsafe(nil)); end

  def app_id; end
  def app_id=(_arg0); end
  def cert_raw; end
  def cert_subject; end
  def cert_subject=(_arg0); end
  def counter; end
  def counter=(_arg0); end
  def key_handle_raw; end
  def key_handle_raw=(_arg0); end
  def origin_public_key_raw; end
  def register_response(challenge, error = T.unsafe(nil)); end
  def sign_response(challenge); end

  private

  def auth_signature(client_data_json); end
  def auth_signature_data(client_data_json); end
  def cert; end
  def cert_key; end
  def client_data(typ, challenge); end
  def generate_ec_key; end
  def origin_key; end
  def reg_registration_data(client_data_json); end
  def reg_signature(client_data_json); end
end

U2F::FakeU2F::CURVE_NAME = T.let(T.unsafe(nil), String)
class U2F::NoMatchingRegistrationError < ::U2F::Error; end
class U2F::NoMatchingRequestError < ::U2F::Error; end
class U2F::PublicKeyDecodeError < ::U2F::Error; end

class U2F::RegisterRequest
  include ::U2F::RequestBase

  def initialize(challenge); end

  def as_json(options = T.unsafe(nil)); end
  def challenge; end
  def challenge=(_arg0); end
end

class U2F::RegisterResponse
  def certificate; end
  def certificate_length; end
  def client_data; end
  def client_data=(_arg0); end
  def client_data_json; end
  def client_data_json=(_arg0); end
  def key_handle; end
  def key_handle_length; end
  def key_handle_raw; end
  def parsed_certificate; end
  def public_key; end
  def public_key_raw; end
  def registration_data_raw; end
  def registration_data_raw=(_arg0); end
  def signature; end
  def verify(app_id); end

  private

  def certificate_bytes; end

  class << self
    def load_from_json(json); end
  end
end

U2F::RegisterResponse::KEY_HANDLE_LENGTH_LENGTH = T.let(T.unsafe(nil), Integer)
U2F::RegisterResponse::KEY_HANDLE_LENGTH_OFFSET = T.let(T.unsafe(nil), Integer)
U2F::RegisterResponse::KEY_HANDLE_OFFSET = T.let(T.unsafe(nil), Integer)
U2F::RegisterResponse::PUBLIC_KEY_LENGTH = T.let(T.unsafe(nil), Integer)
U2F::RegisterResponse::PUBLIC_KEY_OFFSET = T.let(T.unsafe(nil), Integer)

class U2F::Registration
  def initialize(key_handle, public_key, certificate); end

  def certificate; end
  def certificate=(_arg0); end
  def counter; end
  def counter=(_arg0); end
  def key_handle; end
  def key_handle=(_arg0); end
  def public_key; end
  def public_key=(_arg0); end
end

class U2F::RegistrationError < ::U2F::Error
  def initialize(options = T.unsafe(nil)); end

  def code; end
end

U2F::RegistrationError::CODES = T.let(T.unsafe(nil), Hash)

module U2F::RequestBase
  def to_json(options = T.unsafe(nil)); end
  def version; end
  def version=(_arg0); end
end

class U2F::SignRequest
  include ::U2F::RequestBase

  def initialize(key_handle); end

  def as_json(options = T.unsafe(nil)); end
  def key_handle; end
  def key_handle=(_arg0); end
end

class U2F::SignResponse
  def client_data; end
  def client_data=(_arg0); end
  def client_data_json; end
  def client_data_json=(_arg0); end
  def counter; end
  def key_handle; end
  def key_handle=(_arg0); end
  def signature; end
  def signature_data; end
  def signature_data=(_arg0); end
  def user_present?; end
  def verify(app_id, public_key_pem); end

  class << self
    def load_from_json(json); end
  end
end

U2F::SignResponse::USER_PRESENCE_MASK = T.let(T.unsafe(nil), Integer)

class U2F::U2F
  def initialize(app_id); end

  def app_id; end
  def app_id=(_arg0); end
  def authenticate!(challenge, response, registration_public_key, registration_counter); end
  def authentication_requests(key_handles); end
  def challenge; end
  def register!(challenges, response); end
  def registration_requests; end

  class << self
    def public_key_pem(key); end
  end
end

class U2F::UnmatchedChallengeError < ::U2F::Error; end
class U2F::UserNotPresentError < ::U2F::Error; end
